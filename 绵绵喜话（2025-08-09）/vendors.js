/*! For license information please see vendors.js.LICENSE.txt */
    (wx.webpackJsonp = wx.webpackJsonp || []).push([
        [216], {
            6048: function(t, e, n) {
                "use strict";

                function r(t, e = {}) {
                    const n = [];
                    return Object.keys(e).forEach(t => {
                        n.push(`${t}=${e[t]}`)
                    }), 0 === n.length ? "/" + t : `/${t}${-1!==t.indexOf("?")?"&":"?"}${n.join("&")}`
                }
                n.d(e, {
                    ZP: function() {
                        return p
                    }
                });
                var i = Object.defineProperty,
                    s = Object.getOwnPropertySymbols,
                    o = Object.prototype.hasOwnProperty,
                    a = Object.prototype.propertyIsEnumerable,
                    c = (t, e, n) => e in t ? i(t, e, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: n
                    }) : t[e] = n;

                function l(t) {
                    const e = () => "function" != typeof getCurrentPages ? [] : getCurrentPages();
                    return {
                        getStorageSync: e => "function" == typeof t.getStorageSync ? t.getStorageSync(e) : null,
                        setStorageSync: (e, n) => {
                            "function" == typeof t.setStorageSync && t.setStorageSync(e, n)
                        },
                        getCurrentPagesInterop: e,
                        getNavigateBackUrl: (t = 1) => {
                            const e = getCurrentPages();
                            if (!e.length) return "";
                            const n = e[e.length - t];
                            return r(n.route, n.options)
                        },
                        getCurrentUrl: () => {
                            const t = e();
                            if (!t.length) return "";
                            const n = t.pop();
                            return r(n.route, n.options)
                        }
                    }
                }
                const u = t => {
                    let e = {
                            request: () => {},
                            httpRequest: () => {},
                            getSystemInfoSync: () => {}
                        },
                        n = "unknown";
                    if ("object" == typeof wx) e = wx, n = "wechat";
                    else if ("object" == typeof dd) e = dd, n = "dingtalk";
                    else if ("object" == typeof my) e = my, n = "alipay";
                    else if ("object" == typeof tt) e = tt, n = "bytedance";
                    else if ("object" == typeof qq) e = qq, n = "qq";
                    else if ("object" == typeof swan) e = swan, n = "swan";
                    else {
                        if (!t.platformSDK) throw new Error("Current platform is not default supported by SLS API, Pleace config platformSDK or contack Aliyun SLS team.");
                        e = t.platformSDK
                    }
                    return ((t, e) => {
                        for (var n in e || (e = {})) o.call(e, n) && c(t, n, e[n]);
                        if (s)
                            for (var n of s(e)) a.call(e, n) && c(t, n, e[n]);
                        return t
                    })({
                        sdk: e,
                        appName: n
                    }, l(e))
                };

                function h(t, e) {
                    let n, r = "unknown";
                    if (e && t[e]) n = t[e], r = e;
                    else if (t.request) n = t.request, r = "request";
                    else {
                        if (!t.httpRequest) throw new Error("Current platform is not default supported by SLS API, Pleace config platformRequestName or contack Aliyun SLS team.");
                        n = t.httpRequest, r = "httpRequest"
                    }
                    return {
                        request: n,
                        requestName: r
                    }
                }

                function d(t, e, n, r, i, s) {
                    return ((t, e, n) => new Promise((r, i) => {
                        var s = t => {
                                try {
                                    a(n.next(t))
                                } catch (t) {
                                    i(t)
                                }
                            },
                            o = t => {
                                try {
                                    a(n.throw(t))
                                } catch (t) {
                                    i(t)
                                }
                            },
                            a = t => t.done ? r(t.value) : Promise.resolve(t.value).then(s, o);
                        a((n = n.apply(t, e)).next())
                    }))(this, null, (function*() {
                        t = t.slice(0, -6);
                        const {
                            data: o,
                            header: a
                        } =
                        yield i.process(t, e), {
                            request: c
                        } = h(n, s);
                        c(!r || "alipay" != r && "dingtalk" != r ? {
                            url: t,
                            method: "POST",
                            data: o,
                            header: a
                        } : {
                            url: t,
                            method: "POST",
                            data: o,
                            headers: a
                        })
                    }))
                }
                class p extends class {
                    constructor(t) {
                        var e, n;
                        this.timer = null, this.time = 10, this.count = 10, this.arr = [], this.time = null != (e = t.time) ? e : 10, this.count = null != (n = t.count) ? n : 10, t.host.startsWith("http://") || t.host.startsWith("https://") ? this.url = t.host + "/logstores/" + t.logstore + "/track" : this.url = "https://" + t.project + "." + t.host + "/logstores/" + t.logstore + "/track", this.opt = t, t.installUnloadHook && "function" == typeof t.installUnloadHook && t.installUnloadHook(() => {
                            this.sendImmediateInner()
                        })
                    }
                    assemblePayload(t) {
                        const e = {
                            __logs__: t
                        };
                        return this.opt.tags && (e.__tags__ = this.opt.tags), this.opt.topic && (e.__topic__ = this.opt.topic), this.opt.source && (e.__source__ = this.opt.source), JSON.stringify(e)
                    }
                    platformSend() {
                        if (this.opt.sendPayload && "function" == typeof this.opt.sendPayload) {
                            const t = this.assemblePayload(this.arr);
                            this.opt.sendPayload(this.url, t)
                        }
                    }
                    transString(t) {
                        let e = {};
                        for (let n in t) "object" == typeof t[n] ? e[n] = JSON.stringify(t[n]) : e[n] = String(t[n]);
                        return e
                    }
                    sendImmediateInner() {
                        this.arr && this.arr.length > 0 && (this.platformSend(), null != this.timer && (clearTimeout(this.timer), this.timer = null), this.arr = [])
                    }
                    sendInner() {
                        if (this.timer) this.arr.length >= this.count && (clearTimeout(this.timer), this.timer = null, this.sendImmediateInner());
                        else {
                            const t = this;
                            this.arr.length >= this.count || this.time <= 0 ? this.sendImmediateInner() : this.timer = setTimeout((function() {
                                t.sendImmediateInner()
                            }), 1e3 * this.time)
                        }
                    }
                    send(t) {
                        const e = this.transString(t);
                        this.arr.push(e), this.sendInner()
                    }
                    sendImmediate(t) {
                        const e = this.transString(t);
                        this.arr.push(e), this.sendImmediateInner()
                    }
                    sendBatchLogs(t) {
                        const e = t.map(t => this.transString(t));
                        this.arr.push(...e), this.sendInner()
                    }
                    sendBatchLogsImmediate(t) {
                        const e = t.map(t => this.transString(t));
                        this.arr.push(...e), this.sendImmediateInner()
                    }
                    overwriteTransString(t) {
                        this.transString = t.transString
                    }
                    getOpt() {
                        return this.opt
                    }
                } {
                    constructor(t) {
                        const {
                            sdk: e
                        } = u(t);
                        super(Object.assign({}, t, {
                            sendPayload: (n, r) => {
                                ! function(t, e, n, r) {
                                    const {
                                        request: i
                                    } = h(n, r);
                                    i({
                                        url: t + "?APIVersion=0.6.0",
                                        method: "POST",
                                        data: e
                                    })
                                }(n, r, e, t.platformRequestName)
                            }
                        }))
                    }
                    useStsPlugin(t) {
                        const {
                            sdk: e,
                            appName: n
                        } = u(this.getOpt());
                        this.getOpt().sendPayload = (r, i) => {
                            let s = this.getOpt();
                            d(r, i, e, n, t, s.platformRequestName)
                        }, this.overwriteTransString(t)
                    }
                }
            },
            4184: function(t, e) {
                var n;
                ! function() {
                    "use strict";
                    var r = {}.hasOwnProperty;

                    function i() {
                        for (var t = [], e = 0; e < arguments.length; e++) {
                            var n = arguments[e];
                            if (n) {
                                var s = typeof n;
                                if ("string" === s || "number" === s) t.push(n);
                                else if (Array.isArray(n)) {
                                    if (n.length) {
                                        var o = i.apply(null, n);
                                        o && t.push(o)
                                    }
                                } else if ("object" === s) {
                                    if (n.toString !== Object.prototype.toString && !n.toString.toString().includes("[native code]")) {
                                        t.push(n.toString());
                                        continue
                                    }
                                    for (var a in n) r.call(n, a) && n[a] && t.push(a)
                                }
                            }
                        }
                        return t.join(" ")
                    }
                    t.exports ? (i.default = i, t.exports = i) : void 0 === (n = function() {
                        return i
                    }.apply(e, [])) || (t.exports = n)
                }()
            },
            452: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.BlockCipher,
                            r = e.algo,
                            i = [],
                            s = [],
                            o = [],
                            a = [],
                            c = [],
                            l = [],
                            u = [],
                            h = [],
                            d = [],
                            p = [];
                        ! function() {
                            for (var t = [], e = 0; e < 256; e++) t[e] = e < 128 ? e << 1 : e << 1 ^ 283;
                            var n = 0,
                                r = 0;
                            for (e = 0; e < 256; e++) {
                                var f = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4;
                                f = f >>> 8 ^ 255 & f ^ 99, i[n] = f, s[f] = n;
                                var m = t[n],
                                    g = t[m],
                                    v = t[g],
                                    y = 257 * t[f] ^ 16843008 * f;
                                o[n] = y << 24 | y >>> 8, a[n] = y << 16 | y >>> 16, c[n] = y << 8 | y >>> 24, l[n] = y, y = 16843009 * v ^ 65537 * g ^ 257 * m ^ 16843008 * n, u[f] = y << 24 | y >>> 8, h[f] = y << 16 | y >>> 16, d[f] = y << 8 | y >>> 24, p[f] = y, n ? (n = m ^ t[t[t[v ^ m]]], r ^= t[t[r]]) : n = r = 1
                            }
                        }();
                        var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
                            m = r.AES = n.extend({
                                _doReset: function() {
                                    if (!this._nRounds || this._keyPriorReset !== this._key) {
                                        for (var t = this._keyPriorReset = this._key, e = t.words, n = t.sigBytes / 4, r = 4 * ((this._nRounds = n + 6) + 1), s = this._keySchedule = [], o = 0; o < r; o++) o < n ? s[o] = e[o] : (l = s[o - 1], o % n ? n > 6 && o % n == 4 && (l = i[l >>> 24] << 24 | i[l >>> 16 & 255] << 16 | i[l >>> 8 & 255] << 8 | i[255 & l]) : (l = i[(l = l << 8 | l >>> 24) >>> 24] << 24 | i[l >>> 16 & 255] << 16 | i[l >>> 8 & 255] << 8 | i[255 & l], l ^= f[o / n | 0] << 24), s[o] = s[o - n] ^ l);
                                        for (var a = this._invKeySchedule = [], c = 0; c < r; c++) {
                                            if (o = r - c, c % 4) var l = s[o];
                                            else l = s[o - 4];
                                            a[c] = c < 4 || o <= 4 ? l : u[i[l >>> 24]] ^ h[i[l >>> 16 & 255]] ^ d[i[l >>> 8 & 255]] ^ p[i[255 & l]]
                                        }
                                    }
                                },
                                encryptBlock: function(t, e) {
                                    this._doCryptBlock(t, e, this._keySchedule, o, a, c, l, i)
                                },
                                decryptBlock: function(t, e) {
                                    var n = t[e + 1];
                                    t[e + 1] = t[e + 3], t[e + 3] = n, this._doCryptBlock(t, e, this._invKeySchedule, u, h, d, p, s), n = t[e + 1], t[e + 1] = t[e + 3], t[e + 3] = n
                                },
                                _doCryptBlock: function(t, e, n, r, i, s, o, a) {
                                    for (var c = this._nRounds, l = t[e] ^ n[0], u = t[e + 1] ^ n[1], h = t[e + 2] ^ n[2], d = t[e + 3] ^ n[3], p = 4, f = 1; f < c; f++) {
                                        var m = r[l >>> 24] ^ i[u >>> 16 & 255] ^ s[h >>> 8 & 255] ^ o[255 & d] ^ n[p++],
                                            g = r[u >>> 24] ^ i[h >>> 16 & 255] ^ s[d >>> 8 & 255] ^ o[255 & l] ^ n[p++],
                                            v = r[h >>> 24] ^ i[d >>> 16 & 255] ^ s[l >>> 8 & 255] ^ o[255 & u] ^ n[p++],
                                            y = r[d >>> 24] ^ i[l >>> 16 & 255] ^ s[u >>> 8 & 255] ^ o[255 & h] ^ n[p++];
                                        l = m, u = g, h = v, d = y
                                    }
                                    m = (a[l >>> 24] << 24 | a[u >>> 16 & 255] << 16 | a[h >>> 8 & 255] << 8 | a[255 & d]) ^ n[p++], g = (a[u >>> 24] << 24 | a[h >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[255 & l]) ^ n[p++], v = (a[h >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[l >>> 8 & 255] << 8 | a[255 & u]) ^ n[p++], y = (a[d >>> 24] << 24 | a[l >>> 16 & 255] << 16 | a[u >>> 8 & 255] << 8 | a[255 & h]) ^ n[p++], t[e] = m, t[e + 1] = g, t[e + 2] = v, t[e + 3] = y
                                },
                                keySize: 8
                            });
                        e.AES = n._createHelper(m)
                    }(), t.AES
                }(n(8249), n(8269), n(8214), n(888), n(5109))
            },
            7407: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.BlockCipher,
                            r = e.algo;
                        const i = 16,
                            s = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731],
                            o = [
                                [3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946],
                                [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055],
                                [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504],
                                [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]
                            ];
                        var a = {
                            pbox: [],
                            sbox: []
                        };

                        function c(t, e) {
                            let n = e >> 24 & 255,
                                r = e >> 16 & 255,
                                i = e >> 8 & 255,
                                s = 255 & e,
                                o = t.sbox[0][n] + t.sbox[1][r];
                            return o ^= t.sbox[2][i], o += t.sbox[3][s], o
                        }

                        function l(t, e, n) {
                            let r, s = e,
                                o = n;
                            for (let e = 0; e < i; ++e) s ^= t.pbox[e], o = c(t, s) ^ o, r = s, s = o, o = r;
                            return r = s, s = o, o = r, o ^= t.pbox[i], s ^= t.pbox[17], {
                                left: s,
                                right: o
                            }
                        }
                        var u = r.Blowfish = n.extend({
                            _doReset: function() {
                                if (this._keyPriorReset !== this._key) {
                                    var t = this._keyPriorReset = this._key,
                                        e = t.words,
                                        n = t.sigBytes / 4;
                                    ! function(t, e, n) {
                                        for (let e = 0; e < 4; e++) {
                                            t.sbox[e] = [];
                                            for (let n = 0; n < 256; n++) t.sbox[e][n] = o[e][n]
                                        }
                                        let r = 0;
                                        for (let i = 0; i < 18; i++) t.pbox[i] = s[i] ^ e[r], r++, r >= n && (r = 0);
                                        let i = 0,
                                            a = 0,
                                            c = 0;
                                        for (let e = 0; e < 18; e += 2) c = l(t, i, a), i = c.left, a = c.right, t.pbox[e] = i, t.pbox[e + 1] = a;
                                        for (let e = 0; e < 4; e++)
                                            for (let n = 0; n < 256; n += 2) c = l(t, i, a), i = c.left, a = c.right, t.sbox[e][n] = i, t.sbox[e][n + 1] = a
                                    }(a, e, n)
                                }
                            },
                            encryptBlock: function(t, e) {
                                var n = l(a, t[e], t[e + 1]);
                                t[e] = n.left, t[e + 1] = n.right
                            },
                            decryptBlock: function(t, e) {
                                var n = function(t, e, n) {
                                    let r, i = e,
                                        s = n;
                                    for (let e = 17; e > 1; --e) i ^= t.pbox[e], s = c(t, i) ^ s, r = i, i = s, s = r;
                                    return r = i, i = s, s = r, s ^= t.pbox[1], i ^= t.pbox[0], {
                                        left: i,
                                        right: s
                                    }
                                }(a, t[e], t[e + 1]);
                                t[e] = n.left, t[e + 1] = n.right
                            },
                            blockSize: 2,
                            keySize: 4,
                            ivSize: 2
                        });
                        e.Blowfish = n._createHelper(u)
                    }(), t.Blowfish
                }(n(8249), n(8269), n(8214), n(888), n(5109))
            },
            5109: function(t, e, n) {
                t.exports = function(t) {
                    t.lib.Cipher || function(e) {
                        var n = t,
                            r = n.lib,
                            i = r.Base,
                            s = r.WordArray,
                            o = r.BufferedBlockAlgorithm,
                            a = n.enc,
                            c = (a.Utf8, a.Base64),
                            l = n.algo.EvpKDF,
                            u = r.Cipher = o.extend({
                                cfg: i.extend(),
                                createEncryptor: function(t, e) {
                                    return this.create(this._ENC_XFORM_MODE, t, e)
                                },
                                createDecryptor: function(t, e) {
                                    return this.create(this._DEC_XFORM_MODE, t, e)
                                },
                                init: function(t, e, n) {
                                    this.cfg = this.cfg.extend(n), this._xformMode = t, this._key = e, this.reset()
                                },
                                reset: function() {
                                    o.reset.call(this), this._doReset()
                                },
                                process: function(t) {
                                    return this._append(t), this._process()
                                },
                                finalize: function(t) {
                                    return t && this._append(t), this._doFinalize()
                                },
                                keySize: 4,
                                ivSize: 4,
                                _ENC_XFORM_MODE: 1,
                                _DEC_XFORM_MODE: 2,
                                _createHelper: function() {
                                    function t(t) {
                                        return "string" == typeof t ? x : v
                                    }
                                    return function(e) {
                                        return {
                                            encrypt: function(n, r, i) {
                                                return t(r).encrypt(e, n, r, i)
                                            },
                                            decrypt: function(n, r, i) {
                                                return t(r).decrypt(e, n, r, i)
                                            }
                                        }
                                    }
                                }()
                            }),
                            h = (r.StreamCipher = u.extend({
                                _doFinalize: function() {
                                    return this._process(!0)
                                },
                                blockSize: 1
                            }), n.mode = {}),
                            d = r.BlockCipherMode = i.extend({
                                createEncryptor: function(t, e) {
                                    return this.Encryptor.create(t, e)
                                },
                                createDecryptor: function(t, e) {
                                    return this.Decryptor.create(t, e)
                                },
                                init: function(t, e) {
                                    this._cipher = t, this._iv = e
                                }
                            }),
                            p = h.CBC = function() {
                                var t = d.extend();

                                function e(t, e, n) {
                                    var r, i = this._iv;
                                    i ? (r = i, this._iv = void 0) : r = this._prevBlock;
                                    for (var s = 0; s < n; s++) t[e + s] ^= r[s]
                                }
                                return t.Encryptor = t.extend({
                                    processBlock: function(t, n) {
                                        var r = this._cipher,
                                            i = r.blockSize;
                                        e.call(this, t, n, i), r.encryptBlock(t, n), this._prevBlock = t.slice(n, n + i)
                                    }
                                }), t.Decryptor = t.extend({
                                    processBlock: function(t, n) {
                                        var r = this._cipher,
                                            i = r.blockSize,
                                            s = t.slice(n, n + i);
                                        r.decryptBlock(t, n), e.call(this, t, n, i), this._prevBlock = s
                                    }
                                }), t
                            }(),
                            f = (n.pad = {}).Pkcs7 = {
                                pad: function(t, e) {
                                    for (var n = 4 * e, r = n - t.sigBytes % n, i = r << 24 | r << 16 | r << 8 | r, o = [], a = 0; a < r; a += 4) o.push(i);
                                    var c = s.create(o, r);
                                    t.concat(c)
                                },
                                unpad: function(t) {
                                    var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                                    t.sigBytes -= e
                                }
                            },
                            m = (r.BlockCipher = u.extend({
                                cfg: u.cfg.extend({
                                    mode: p,
                                    padding: f
                                }),
                                reset: function() {
                                    var t;
                                    u.reset.call(this);
                                    var e = this.cfg,
                                        n = e.iv,
                                        r = e.mode;
                                    this._xformMode == this._ENC_XFORM_MODE ? t = r.createEncryptor : (t = r.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == t ? this._mode.init(this, n && n.words) : (this._mode = t.call(r, this, n && n.words), this._mode.__creator = t)
                                },
                                _doProcessBlock: function(t, e) {
                                    this._mode.processBlock(t, e)
                                },
                                _doFinalize: function() {
                                    var t, e = this.cfg.padding;
                                    return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize), t = this._process(!0)) : (t = this._process(!0), e.unpad(t)), t
                                },
                                blockSize: 4
                            }), r.CipherParams = i.extend({
                                init: function(t) {
                                    this.mixIn(t)
                                },
                                toString: function(t) {
                                    return (t || this.formatter).stringify(this)
                                }
                            })),
                            g = (n.format = {}).OpenSSL = {
                                stringify: function(t) {
                                    var e = t.ciphertext,
                                        n = t.salt;
                                    return (n ? s.create([1398893684, 1701076831]).concat(n).concat(e) : e).toString(c)
                                },
                                parse: function(t) {
                                    var e, n = c.parse(t),
                                        r = n.words;
                                    return 1398893684 == r[0] && 1701076831 == r[1] && (e = s.create(r.slice(2, 4)), r.splice(0, 4), n.sigBytes -= 16), m.create({
                                        ciphertext: n,
                                        salt: e
                                    })
                                }
                            },
                            v = r.SerializableCipher = i.extend({
                                cfg: i.extend({
                                    format: g
                                }),
                                encrypt: function(t, e, n, r) {
                                    r = this.cfg.extend(r);
                                    var i = t.createEncryptor(n, r),
                                        s = i.finalize(e),
                                        o = i.cfg;
                                    return m.create({
                                        ciphertext: s,
                                        key: n,
                                        iv: o.iv,
                                        algorithm: t,
                                        mode: o.mode,
                                        padding: o.padding,
                                        blockSize: t.blockSize,
                                        formatter: r.format
                                    })
                                },
                                decrypt: function(t, e, n, r) {
                                    return r = this.cfg.extend(r), e = this._parse(e, r.format), t.createDecryptor(n, r).finalize(e.ciphertext)
                                },
                                _parse: function(t, e) {
                                    return "string" == typeof t ? e.parse(t, this) : t
                                }
                            }),
                            y = (n.kdf = {}).OpenSSL = {
                                execute: function(t, e, n, r, i) {
                                    if (r || (r = s.random(8)), i) o = l.create({
                                        keySize: e + n,
                                        hasher: i
                                    }).compute(t, r);
                                    else var o = l.create({
                                        keySize: e + n
                                    }).compute(t, r);
                                    var a = s.create(o.words.slice(e), 4 * n);
                                    return o.sigBytes = 4 * e, m.create({
                                        key: o,
                                        iv: a,
                                        salt: r
                                    })
                                }
                            },
                            x = r.PasswordBasedCipher = v.extend({
                                cfg: v.cfg.extend({
                                    kdf: y
                                }),
                                encrypt: function(t, e, n, r) {
                                    var i = (r = this.cfg.extend(r)).kdf.execute(n, t.keySize, t.ivSize, r.salt, r.hasher);
                                    r.iv = i.iv;
                                    var s = v.encrypt.call(this, t, e, i.key, r);
                                    return s.mixIn(i), s
                                },
                                decrypt: function(t, e, n, r) {
                                    r = this.cfg.extend(r), e = this._parse(e, r.format);
                                    var i = r.kdf.execute(n, t.keySize, t.ivSize, e.salt, r.hasher);
                                    return r.iv = i.iv, v.decrypt.call(this, t, e, i.key, r)
                                }
                            })
                    }()
                }(n(8249), n(888))
            },
            8249: function(t, e, n) {
                var r = n(2180).window;
                ! function(e, n) {
                    t.exports = n()
                }(0, (function() {
                    var t = t || function(t, e) {
                        var i;
                        if (void 0 !== r && r.crypto && (i = r.crypto), "undefined" != typeof self && self.crypto && (i = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (i = globalThis.crypto), !i && void 0 !== r && r.msCrypto && (i = r.msCrypto), !i && void 0 !== n.g && n.g.crypto && (i = n.g.crypto), !i) try {
                            i = n(2480)
                        } catch (t) {}
                        var s = function() {
                                if (i) {
                                    if ("function" == typeof i.getRandomValues) try {
                                        return i.getRandomValues(new Uint32Array(1))[0]
                                    } catch (t) {}
                                    if ("function" == typeof i.randomBytes) try {
                                        return i.randomBytes(4).readInt32LE()
                                    } catch (t) {}
                                }
                                throw new Error("Native crypto module could not be used to get secure random number.")
                            },
                            o = Object.create || function() {
                                function t() {}
                                return function(e) {
                                    var n;
                                    return t.prototype = e, n = new t, t.prototype = null, n
                                }
                            }(),
                            a = {},
                            c = a.lib = {},
                            l = c.Base = {
                                extend: function(t) {
                                    var e = o(this);
                                    return t && e.mixIn(t), e.hasOwnProperty("init") && this.init !== e.init || (e.init = function() {
                                        e.$super.init.apply(this, arguments)
                                    }), e.init.prototype = e, e.$super = this, e
                                },
                                create: function() {
                                    var t = this.extend();
                                    return t.init.apply(t, arguments), t
                                },
                                init: function() {},
                                mixIn: function(t) {
                                    for (var e in t) t.hasOwnProperty(e) && (this[e] = t[e]);
                                    t.hasOwnProperty("toString") && (this.toString = t.toString)
                                },
                                clone: function() {
                                    return this.init.prototype.extend(this)
                                }
                            },
                            u = c.WordArray = l.extend({
                                init: function(t, e) {
                                    t = this.words = t || [], this.sigBytes = null != e ? e : 4 * t.length
                                },
                                toString: function(t) {
                                    return (t || d).stringify(this)
                                },
                                concat: function(t) {
                                    var e = this.words,
                                        n = t.words,
                                        r = this.sigBytes,
                                        i = t.sigBytes;
                                    if (this.clamp(), r % 4)
                                        for (var s = 0; s < i; s++) {
                                            var o = n[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                                            e[r + s >>> 2] |= o << 24 - (r + s) % 4 * 8
                                        } else
                                            for (var a = 0; a < i; a += 4) e[r + a >>> 2] = n[a >>> 2];
                                    return this.sigBytes += i, this
                                },
                                clamp: function() {
                                    var e = this.words,
                                        n = this.sigBytes;
                                    e[n >>> 2] &= 4294967295 << 32 - n % 4 * 8, e.length = t.ceil(n / 4)
                                },
                                clone: function() {
                                    var t = l.clone.call(this);
                                    return t.words = this.words.slice(0), t
                                },
                                random: function(t) {
                                    for (var e = [], n = 0; n < t; n += 4) e.push(s());
                                    return new u.init(e, t)
                                }
                            }),
                            h = a.enc = {},
                            d = h.Hex = {
                                stringify: function(t) {
                                    for (var e = t.words, n = t.sigBytes, r = [], i = 0; i < n; i++) {
                                        var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                        r.push((s >>> 4).toString(16)), r.push((15 & s).toString(16))
                                    }
                                    return r.join("")
                                },
                                parse: function(t) {
                                    for (var e = t.length, n = [], r = 0; r < e; r += 2) n[r >>> 3] |= parseInt(t.substr(r, 2), 16) << 24 - r % 8 * 4;
                                    return new u.init(n, e / 2)
                                }
                            },
                            p = h.Latin1 = {
                                stringify: function(t) {
                                    for (var e = t.words, n = t.sigBytes, r = [], i = 0; i < n; i++) {
                                        var s = e[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                                        r.push(String.fromCharCode(s))
                                    }
                                    return r.join("")
                                },
                                parse: function(t) {
                                    for (var e = t.length, n = [], r = 0; r < e; r++) n[r >>> 2] |= (255 & t.charCodeAt(r)) << 24 - r % 4 * 8;
                                    return new u.init(n, e)
                                }
                            },
                            f = h.Utf8 = {
                                stringify: function(t) {
                                    try {
                                        return decodeURIComponent(escape(p.stringify(t)))
                                    } catch (t) {
                                        throw new Error("Malformed UTF-8 data")
                                    }
                                },
                                parse: function(t) {
                                    return p.parse(unescape(encodeURIComponent(t)))
                                }
                            },
                            m = c.BufferedBlockAlgorithm = l.extend({
                                reset: function() {
                                    this._data = new u.init, this._nDataBytes = 0
                                },
                                _append: function(t) {
                                    "string" == typeof t && (t = f.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes
                                },
                                _process: function(e) {
                                    var n, r = this._data,
                                        i = r.words,
                                        s = r.sigBytes,
                                        o = this.blockSize,
                                        a = s / (4 * o),
                                        c = (a = e ? t.ceil(a) : t.max((0 | a) - this._minBufferSize, 0)) * o,
                                        l = t.min(4 * c, s);
                                    if (c) {
                                        for (var h = 0; h < c; h += o) this._doProcessBlock(i, h);
                                        n = i.splice(0, c), r.sigBytes -= l
                                    }
                                    return new u.init(n, l)
                                },
                                clone: function() {
                                    var t = l.clone.call(this);
                                    return t._data = this._data.clone(), t
                                },
                                _minBufferSize: 0
                            }),
                            g = (c.Hasher = m.extend({
                                cfg: l.extend(),
                                init: function(t) {
                                    this.cfg = this.cfg.extend(t), this.reset()
                                },
                                reset: function() {
                                    m.reset.call(this), this._doReset()
                                },
                                update: function(t) {
                                    return this._append(t), this._process(), this
                                },
                                finalize: function(t) {
                                    return t && this._append(t), this._doFinalize()
                                },
                                blockSize: 16,
                                _createHelper: function(t) {
                                    return function(e, n) {
                                        return new t.init(n).finalize(e)
                                    }
                                },
                                _createHmacHelper: function(t) {
                                    return function(e, n) {
                                        return new g.HMAC.init(t, n).finalize(e)
                                    }
                                }
                            }), a.algo = {});
                        return a
                    }(Math);
                    return t
                }))
            },
            8269: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.WordArray;

                        function r(t, e, r) {
                            for (var i = [], s = 0, o = 0; o < e; o++)
                                if (o % 4) {
                                    var a = r[t.charCodeAt(o - 1)] << o % 4 * 2 | r[t.charCodeAt(o)] >>> 6 - o % 4 * 2;
                                    i[s >>> 2] |= a << 24 - s % 4 * 8, s++
                                }
                            return n.create(i, s)
                        }
                        e.enc.Base64 = {
                            stringify: function(t) {
                                var e = t.words,
                                    n = t.sigBytes,
                                    r = this._map;
                                t.clamp();
                                for (var i = [], s = 0; s < n; s += 3)
                                    for (var o = (e[s >>> 2] >>> 24 - s % 4 * 8 & 255) << 16 | (e[s + 1 >>> 2] >>> 24 - (s + 1) % 4 * 8 & 255) << 8 | e[s + 2 >>> 2] >>> 24 - (s + 2) % 4 * 8 & 255, a = 0; a < 4 && s + .75 * a < n; a++) i.push(r.charAt(o >>> 6 * (3 - a) & 63));
                                var c = r.charAt(64);
                                if (c)
                                    for (; i.length % 4;) i.push(c);
                                return i.join("")
                            },
                            parse: function(t) {
                                var e = t.length,
                                    n = this._map,
                                    i = this._reverseMap;
                                if (!i) {
                                    i = this._reverseMap = [];
                                    for (var s = 0; s < n.length; s++) i[n.charCodeAt(s)] = s
                                }
                                var o = n.charAt(64);
                                if (o) {
                                    var a = t.indexOf(o); - 1 !== a && (e = a)
                                }
                                return r(t, e, i)
                            },
                            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                        }
                    }(), t.enc.Base64
                }(n(8249))
            },
            3786: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.WordArray;

                        function r(t, e, r) {
                            for (var i = [], s = 0, o = 0; o < e; o++)
                                if (o % 4) {
                                    var a = r[t.charCodeAt(o - 1)] << o % 4 * 2 | r[t.charCodeAt(o)] >>> 6 - o % 4 * 2;
                                    i[s >>> 2] |= a << 24 - s % 4 * 8, s++
                                }
                            return n.create(i, s)
                        }
                        e.enc.Base64url = {
                            stringify: function(t, e) {
                                void 0 === e && (e = !0);
                                var n = t.words,
                                    r = t.sigBytes,
                                    i = e ? this._safe_map : this._map;
                                t.clamp();
                                for (var s = [], o = 0; o < r; o += 3)
                                    for (var a = (n[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (n[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | n[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, c = 0; c < 4 && o + .75 * c < r; c++) s.push(i.charAt(a >>> 6 * (3 - c) & 63));
                                var l = i.charAt(64);
                                if (l)
                                    for (; s.length % 4;) s.push(l);
                                return s.join("")
                            },
                            parse: function(t, e) {
                                void 0 === e && (e = !0);
                                var n = t.length,
                                    i = e ? this._safe_map : this._map,
                                    s = this._reverseMap;
                                if (!s) {
                                    s = this._reverseMap = [];
                                    for (var o = 0; o < i.length; o++) s[i.charCodeAt(o)] = o
                                }
                                var a = i.charAt(64);
                                if (a) {
                                    var c = t.indexOf(a); - 1 !== c && (n = c)
                                }
                                return r(t, n, s)
                            },
                            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                            _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                        }
                    }(), t.enc.Base64url
                }(n(8249))
            },
            298: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.WordArray,
                            r = e.enc;

                        function i(t) {
                            return t << 8 & 4278255360 | t >>> 8 & 16711935
                        }
                        r.Utf16 = r.Utf16BE = {
                            stringify: function(t) {
                                for (var e = t.words, n = t.sigBytes, r = [], i = 0; i < n; i += 2) {
                                    var s = e[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                                    r.push(String.fromCharCode(s))
                                }
                                return r.join("")
                            },
                            parse: function(t) {
                                for (var e = t.length, r = [], i = 0; i < e; i++) r[i >>> 1] |= t.charCodeAt(i) << 16 - i % 2 * 16;
                                return n.create(r, 2 * e)
                            }
                        }, r.Utf16LE = {
                            stringify: function(t) {
                                for (var e = t.words, n = t.sigBytes, r = [], s = 0; s < n; s += 2) {
                                    var o = i(e[s >>> 2] >>> 16 - s % 4 * 8 & 65535);
                                    r.push(String.fromCharCode(o))
                                }
                                return r.join("")
                            },
                            parse: function(t) {
                                for (var e = t.length, r = [], s = 0; s < e; s++) r[s >>> 1] |= i(t.charCodeAt(s) << 16 - s % 2 * 16);
                                return n.create(r, 2 * e)
                            }
                        }
                    }(), t.enc.Utf16
                }(n(8249))
            },
            888: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib,
                            r = n.Base,
                            i = n.WordArray,
                            s = e.algo,
                            o = s.MD5,
                            a = s.EvpKDF = r.extend({
                                cfg: r.extend({
                                    keySize: 4,
                                    hasher: o,
                                    iterations: 1
                                }),
                                init: function(t) {
                                    this.cfg = this.cfg.extend(t)
                                },
                                compute: function(t, e) {
                                    for (var n, r = this.cfg, s = r.hasher.create(), o = i.create(), a = o.words, c = r.keySize, l = r.iterations; a.length < c;) {
                                        n && s.update(n), n = s.update(t).finalize(e), s.reset();
                                        for (var u = 1; u < l; u++) n = s.finalize(n), s.reset();
                                        o.concat(n)
                                    }
                                    return o.sigBytes = 4 * c, o
                                }
                            });
                        e.EvpKDF = function(t, e, n) {
                            return a.create(n).compute(t, e)
                        }
                    }(), t.EvpKDF
                }(n(8249), n(2783), n(9824))
            },
            2209: function(t, e, n) {
                t.exports = function(t) {
                    return function(e) {
                        var n = t,
                            r = n.lib.CipherParams,
                            i = n.enc.Hex;
                        n.format.Hex = {
                            stringify: function(t) {
                                return t.ciphertext.toString(i)
                            },
                            parse: function(t) {
                                var e = i.parse(t);
                                return r.create({
                                    ciphertext: e
                                })
                            }
                        }
                    }(), t.format.Hex
                }(n(8249), n(5109))
            },
            9824: function(t, e, n) {
                t.exports = function(t) {
                    ! function() {
                        var e = t,
                            n = e.lib.Base,
                            r = e.enc.Utf8;
                        e.algo.HMAC = n.extend({
                            init: function(t, e) {
                                t = this._hasher = new t.init, "string" == typeof e && (e = r.parse(e));
                                var n = t.blockSize,
                                    i = 4 * n;
                                e.sigBytes > i && (e = t.finalize(e)), e.clamp();
                                for (var s = this._oKey = e.clone(), o = this._iKey = e.clone(), a = s.words, c = o.words, l = 0; l < n; l++) a[l] ^= 1549556828, c[l] ^= 909522486;
                                s.sigBytes = o.sigBytes = i, this.reset()
                            },
                            reset: function() {
                                var t = this._hasher;
                                t.reset(), t.update(this._iKey)
                            },
                            update: function(t) {
                                return this._hasher.update(t), this
                            },
                            finalize: function(t) {
                                var e = this._hasher,
                                    n = e.finalize(t);
                                return e.reset(), e.finalize(this._oKey.clone().concat(n))
                            }
                        })
                    }()
                }(n(8249))
            },
            1354: function(t, e, n) {
                t.exports = function(t) {
                    return t
                }(n(8249), n(4938), n(2422), n(298), n(8269), n(3786), n(8214), n(2783), n(2153), n(7792), n(34), n(7460), n(3327), n(706), n(9824), n(2112), n(888), n(5109), n(8568), n(4242), n(9968), n(7660), n(1148), n(3615), n(2807), n(1077), n(6475), n(6991), n(2209), n(452), n(4253), n(1857), n(4454), n(3974), n(7407))
            },
            2422: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        if ("function" == typeof ArrayBuffer) {
                            var e = t.lib.WordArray,
                                n = e.init;
                            (e.init = function(t) {
                                if (t instanceof ArrayBuffer && (t = new Uint8Array(t)), (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength)), t instanceof Uint8Array) {
                                    for (var e = t.byteLength, r = [], i = 0; i < e; i++) r[i >>> 2] |= t[i] << 24 - i % 4 * 8;
                                    n.call(this, r, e)
                                } else n.apply(this, arguments)
                            }).prototype = e
                        }
                    }(), t.lib.WordArray
                }(n(8249))
            },
            8214: function(t, e, n) {
                t.exports = function(t) {
                    return function(e) {
                        var n = t,
                            r = n.lib,
                            i = r.WordArray,
                            s = r.Hasher,
                            o = n.algo,
                            a = [];
                        ! function() {
                            for (var t = 0; t < 64; t++) a[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0
                        }();
                        var c = o.MD5 = s.extend({
                            _doReset: function() {
                                this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878])
                            },
                            _doProcessBlock: function(t, e) {
                                for (var n = 0; n < 16; n++) {
                                    var r = e + n,
                                        i = t[r];
                                    t[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
                                }
                                var s = this._hash.words,
                                    o = t[e + 0],
                                    c = t[e + 1],
                                    p = t[e + 2],
                                    f = t[e + 3],
                                    m = t[e + 4],
                                    g = t[e + 5],
                                    v = t[e + 6],
                                    y = t[e + 7],
                                    x = t[e + 8],
                                    _ = t[e + 9],
                                    b = t[e + 10],
                                    w = t[e + 11],
                                    M = t[e + 12],
                                    S = t[e + 13],
                                    T = t[e + 14],
                                    E = t[e + 15],
                                    A = s[0],
                                    L = s[1],
                                    R = s[2],
                                    P = s[3];
                                A = l(A, L, R, P, o, 7, a[0]), P = l(P, A, L, R, c, 12, a[1]), R = l(R, P, A, L, p, 17, a[2]), L = l(L, R, P, A, f, 22, a[3]), A = l(A, L, R, P, m, 7, a[4]), P = l(P, A, L, R, g, 12, a[5]), R = l(R, P, A, L, v, 17, a[6]), L = l(L, R, P, A, y, 22, a[7]), A = l(A, L, R, P, x, 7, a[8]), P = l(P, A, L, R, _, 12, a[9]), R = l(R, P, A, L, b, 17, a[10]), L = l(L, R, P, A, w, 22, a[11]), A = l(A, L, R, P, M, 7, a[12]), P = l(P, A, L, R, S, 12, a[13]), R = l(R, P, A, L, T, 17, a[14]), A = u(A, L = l(L, R, P, A, E, 22, a[15]), R, P, c, 5, a[16]), P = u(P, A, L, R, v, 9, a[17]), R = u(R, P, A, L, w, 14, a[18]), L = u(L, R, P, A, o, 20, a[19]), A = u(A, L, R, P, g, 5, a[20]), P = u(P, A, L, R, b, 9, a[21]), R = u(R, P, A, L, E, 14, a[22]), L = u(L, R, P, A, m, 20, a[23]), A = u(A, L, R, P, _, 5, a[24]), P = u(P, A, L, R, T, 9, a[25]), R = u(R, P, A, L, f, 14, a[26]), L = u(L, R, P, A, x, 20, a[27]), A = u(A, L, R, P, S, 5, a[28]), P = u(P, A, L, R, p, 9, a[29]), R = u(R, P, A, L, y, 14, a[30]), A = h(A, L = u(L, R, P, A, M, 20, a[31]), R, P, g, 4, a[32]), P = h(P, A, L, R, x, 11, a[33]), R = h(R, P, A, L, w, 16, a[34]), L = h(L, R, P, A, T, 23, a[35]), A = h(A, L, R, P, c, 4, a[36]), P = h(P, A, L, R, m, 11, a[37]), R = h(R, P, A, L, y, 16, a[38]), L = h(L, R, P, A, b, 23, a[39]), A = h(A, L, R, P, S, 4, a[40]), P = h(P, A, L, R, o, 11, a[41]), R = h(R, P, A, L, f, 16, a[42]), L = h(L, R, P, A, v, 23, a[43]), A = h(A, L, R, P, _, 4, a[44]), P = h(P, A, L, R, M, 11, a[45]), R = h(R, P, A, L, E, 16, a[46]), A = d(A, L = h(L, R, P, A, p, 23, a[47]), R, P, o, 6, a[48]), P = d(P, A, L, R, y, 10, a[49]), R = d(R, P, A, L, T, 15, a[50]), L = d(L, R, P, A, g, 21, a[51]), A = d(A, L, R, P, M, 6, a[52]), P = d(P, A, L, R, f, 10, a[53]), R = d(R, P, A, L, b, 15, a[54]), L = d(L, R, P, A, c, 21, a[55]), A = d(A, L, R, P, x, 6, a[56]), P = d(P, A, L, R, E, 10, a[57]), R = d(R, P, A, L, v, 15, a[58]), L = d(L, R, P, A, S, 21, a[59]), A = d(A, L, R, P, m, 6, a[60]), P = d(P, A, L, R, w, 10, a[61]), R = d(R, P, A, L, p, 15, a[62]), L = d(L, R, P, A, _, 21, a[63]), s[0] = s[0] + A | 0, s[1] = s[1] + L | 0, s[2] = s[2] + R | 0, s[3] = s[3] + P | 0
                            },
                            _doFinalize: function() {
                                var t = this._data,
                                    n = t.words,
                                    r = 8 * this._nDataBytes,
                                    i = 8 * t.sigBytes;
                                n[i >>> 5] |= 128 << 24 - i % 32;
                                var s = e.floor(r / 4294967296),
                                    o = r;
                                n[15 + (i + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), n[14 + (i + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), t.sigBytes = 4 * (n.length + 1), this._process();
                                for (var a = this._hash, c = a.words, l = 0; l < 4; l++) {
                                    var u = c[l];
                                    c[l] = 16711935 & (u << 8 | u >>> 24) | 4278255360 & (u << 24 | u >>> 8)
                                }
                                return a
                            },
                            clone: function() {
                                var t = s.clone.call(this);
                                return t._hash = this._hash.clone(), t
                            }
                        });

                        function l(t, e, n, r, i, s, o) {
                            var a = t + (e & n | ~e & r) + i + o;
                            return (a << s | a >>> 32 - s) + e
                        }

                        function u(t, e, n, r, i, s, o) {
                            var a = t + (e & r | n & ~r) + i + o;
                            return (a << s | a >>> 32 - s) + e
                        }

                        function h(t, e, n, r, i, s, o) {
                            var a = t + (e ^ n ^ r) + i + o;
                            return (a << s | a >>> 32 - s) + e
                        }

                        function d(t, e, n, r, i, s, o) {
                            var a = t + (n ^ (e | ~r)) + i + o;
                            return (a << s | a >>> 32 - s) + e
                        }
                        n.MD5 = s._createHelper(c), n.HmacMD5 = s._createHmacHelper(c)
                    }(Math), t.MD5
                }(n(8249))
            },
            8568: function(t, e, n) {
                t.exports = function(t) {
                    return t.mode.CFB = function() {
                        var e = t.lib.BlockCipherMode.extend();

                        function n(t, e, n, r) {
                            var i, s = this._iv;
                            s ? (i = s.slice(0), this._iv = void 0) : i = this._prevBlock, r.encryptBlock(i, 0);
                            for (var o = 0; o < n; o++) t[e + o] ^= i[o]
                        }
                        return e.Encryptor = e.extend({
                            processBlock: function(t, e) {
                                var r = this._cipher,
                                    i = r.blockSize;
                                n.call(this, t, e, i, r), this._prevBlock = t.slice(e, e + i)
                            }
                        }), e.Decryptor = e.extend({
                            processBlock: function(t, e) {
                                var r = this._cipher,
                                    i = r.blockSize,
                                    s = t.slice(e, e + i);
                                n.call(this, t, e, i, r), this._prevBlock = s
                            }
                        }), e
                    }(), t.mode.CFB
                }(n(8249), n(5109))
            },
            9968: function(t, e, n) {
                t.exports = function(t) {
                    return t.mode.CTRGladman = function() {
                        var e = t.lib.BlockCipherMode.extend();

                        function n(t) {
                            if (255 == (t >> 24 & 255)) {
                                var e = t >> 16 & 255,
                                    n = t >> 8 & 255,
                                    r = 255 & t;
                                255 === e ? (e = 0, 255 === n ? (n = 0, 255 === r ? r = 0 : ++r) : ++n) : ++e, t = 0, t += e << 16, t += n << 8, t += r
                            } else t += 1 << 24;
                            return t
                        }

                        function r(t) {
                            return 0 === (t[0] = n(t[0])) && (t[1] = n(t[1])), t
                        }
                        var i = e.Encryptor = e.extend({
                            processBlock: function(t, e) {
                                var n = this._cipher,
                                    i = n.blockSize,
                                    s = this._iv,
                                    o = this._counter;
                                s && (o = this._counter = s.slice(0), this._iv = void 0), r(o);
                                var a = o.slice(0);
                                n.encryptBlock(a, 0);
                                for (var c = 0; c < i; c++) t[e + c] ^= a[c]
                            }
                        });
                        return e.Decryptor = i, e
                    }(), t.mode.CTRGladman
                }(n(8249), n(5109))
            },
            4242: function(t, e, n) {
                t.exports = function(t) {
                    return t.mode.CTR = function() {
                        var e = t.lib.BlockCipherMode.extend(),
                            n = e.Encryptor = e.extend({
                                processBlock: function(t, e) {
                                    var n = this._cipher,
                                        r = n.blockSize,
                                        i = this._iv,
                                        s = this._counter;
                                    i && (s = this._counter = i.slice(0), this._iv = void 0);
                                    var o = s.slice(0);
                                    n.encryptBlock(o, 0), s[r - 1] = s[r - 1] + 1 | 0;
                                    for (var a = 0; a < r; a++) t[e + a] ^= o[a]
                                }
                            });
                        return e.Decryptor = n, e
                    }(), t.mode.CTR
                }(n(8249), n(5109))
            },
            1148: function(t, e, n) {
                t.exports = function(t) {
                    return t.mode.ECB = function() {
                        var e = t.lib.BlockCipherMode.extend();
                        return e.Encryptor = e.extend({
                            processBlock: function(t, e) {
                                this._cipher.encryptBlock(t, e)
                            }
                        }), e.Decryptor = e.extend({
                            processBlock: function(t, e) {
                                this._cipher.decryptBlock(t, e)
                            }
                        }), e
                    }(), t.mode.ECB
                }(n(8249), n(5109))
            },
            7660: function(t, e, n) {
                t.exports = function(t) {
                    return t.mode.OFB = function() {
                        var e = t.lib.BlockCipherMode.extend(),
                            n = e.Encryptor = e.extend({
                                processBlock: function(t, e) {
                                    var n = this._cipher,
                                        r = n.blockSize,
                                        i = this._iv,
                                        s = this._keystream;
                                    i && (s = this._keystream = i.slice(0), this._iv = void 0), n.encryptBlock(s, 0);
                                    for (var o = 0; o < r; o++) t[e + o] ^= s[o]
                                }
                            });
                        return e.Decryptor = n, e
                    }(), t.mode.OFB
                }(n(8249), n(5109))
            },
            3615: function(t, e, n) {
                t.exports = function(t) {
                    return t.pad.AnsiX923 = {
                        pad: function(t, e) {
                            var n = t.sigBytes,
                                r = 4 * e,
                                i = r - n % r,
                                s = n + i - 1;
                            t.clamp(), t.words[s >>> 2] |= i << 24 - s % 4 * 8, t.sigBytes += i
                        },
                        unpad: function(t) {
                            var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                            t.sigBytes -= e
                        }
                    }, t.pad.Ansix923
                }(n(8249), n(5109))
            },
            2807: function(t, e, n) {
                t.exports = function(t) {
                    return t.pad.Iso10126 = {
                        pad: function(e, n) {
                            var r = 4 * n,
                                i = r - e.sigBytes % r;
                            e.concat(t.lib.WordArray.random(i - 1)).concat(t.lib.WordArray.create([i << 24], 1))
                        },
                        unpad: function(t) {
                            var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                            t.sigBytes -= e
                        }
                    }, t.pad.Iso10126
                }(n(8249), n(5109))
            },
            1077: function(t, e, n) {
                t.exports = function(t) {
                    return t.pad.Iso97971 = {
                        pad: function(e, n) {
                            e.concat(t.lib.WordArray.create([2147483648], 1)), t.pad.ZeroPadding.pad(e, n)
                        },
                        unpad: function(e) {
                            t.pad.ZeroPadding.unpad(e), e.sigBytes--
                        }
                    }, t.pad.Iso97971
                }(n(8249), n(5109))
            },
            6991: function(t, e, n) {
                t.exports = function(t) {
                    return t.pad.NoPadding = {
                        pad: function() {},
                        unpad: function() {}
                    }, t.pad.NoPadding
                }(n(8249), n(5109))
            },
            6475: function(t, e, n) {
                t.exports = function(t) {
                    return t.pad.ZeroPadding = {
                        pad: function(t, e) {
                            var n = 4 * e;
                            t.clamp(), t.sigBytes += n - (t.sigBytes % n || n)
                        },
                        unpad: function(t) {
                            var e = t.words,
                                n = t.sigBytes - 1;
                            for (n = t.sigBytes - 1; n >= 0; n--)
                                if (e[n >>> 2] >>> 24 - n % 4 * 8 & 255) {
                                    t.sigBytes = n + 1;
                                    break
                                }
                        }
                    }, t.pad.ZeroPadding
                }(n(8249), n(5109))
            },
            2112: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib,
                            r = n.Base,
                            i = n.WordArray,
                            s = e.algo,
                            o = s.SHA256,
                            a = s.HMAC,
                            c = s.PBKDF2 = r.extend({
                                cfg: r.extend({
                                    keySize: 4,
                                    hasher: o,
                                    iterations: 25e4
                                }),
                                init: function(t) {
                                    this.cfg = this.cfg.extend(t)
                                },
                                compute: function(t, e) {
                                    for (var n = this.cfg, r = a.create(n.hasher, t), s = i.create(), o = i.create([1]), c = s.words, l = o.words, u = n.keySize, h = n.iterations; c.length < u;) {
                                        var d = r.update(e).finalize(o);
                                        r.reset();
                                        for (var p = d.words, f = p.length, m = d, g = 1; g < h; g++) {
                                            m = r.finalize(m), r.reset();
                                            for (var v = m.words, y = 0; y < f; y++) p[y] ^= v[y]
                                        }
                                        s.concat(d), l[0] ++
                                    }
                                    return s.sigBytes = 4 * u, s
                                }
                            });
                        e.PBKDF2 = function(t, e, n) {
                            return c.create(n).compute(t, e)
                        }
                    }(), t.PBKDF2
                }(n(8249), n(2153), n(9824))
            },
            3974: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.StreamCipher,
                            r = e.algo,
                            i = [],
                            s = [],
                            o = [],
                            a = r.RabbitLegacy = n.extend({
                                _doReset: function() {
                                    var t = this._key.words,
                                        e = this.cfg.iv,
                                        n = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16],
                                        r = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                                    this._b = 0;
                                    for (var i = 0; i < 4; i++) c.call(this);
                                    for (i = 0; i < 8; i++) r[i] ^= n[i + 4 & 7];
                                    if (e) {
                                        var s = e.words,
                                            o = s[0],
                                            a = s[1],
                                            l = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                                            u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                            h = l >>> 16 | 4294901760 & u,
                                            d = u << 16 | 65535 & l;
                                        for (r[0] ^= l, r[1] ^= h, r[2] ^= u, r[3] ^= d, r[4] ^= l, r[5] ^= h, r[6] ^= u, r[7] ^= d, i = 0; i < 4; i++) c.call(this)
                                    }
                                },
                                _doProcessBlock: function(t, e) {
                                    var n = this._X;
                                    c.call(this), i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16, i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16, i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16, i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;
                                    for (var r = 0; r < 4; r++) i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8), t[e + r] ^= i[r]
                                },
                                blockSize: 4,
                                ivSize: 2
                            });

                        function c() {
                            for (var t = this._X, e = this._C, n = 0; n < 8; n++) s[n] = e[n];
                            for (e[0] = e[0] + 1295307597 + this._b | 0, e[1] = e[1] + 3545052371 + (e[0] >>> 0 < s[0] >>> 0 ? 1 : 0) | 0, e[2] = e[2] + 886263092 + (e[1] >>> 0 < s[1] >>> 0 ? 1 : 0) | 0, e[3] = e[3] + 1295307597 + (e[2] >>> 0 < s[2] >>> 0 ? 1 : 0) | 0, e[4] = e[4] + 3545052371 + (e[3] >>> 0 < s[3] >>> 0 ? 1 : 0) | 0, e[5] = e[5] + 886263092 + (e[4] >>> 0 < s[4] >>> 0 ? 1 : 0) | 0, e[6] = e[6] + 1295307597 + (e[5] >>> 0 < s[5] >>> 0 ? 1 : 0) | 0, e[7] = e[7] + 3545052371 + (e[6] >>> 0 < s[6] >>> 0 ? 1 : 0) | 0, this._b = e[7] >>> 0 < s[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) {
                                var r = t[n] + e[n],
                                    i = 65535 & r,
                                    a = r >>> 16,
                                    c = ((i * i >>> 17) + i * a >>> 15) + a * a,
                                    l = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                                o[n] = c ^ l
                            }
                            t[0] = o[0] + (o[7] << 16 | o[7] >>> 16) + (o[6] << 16 | o[6] >>> 16) | 0, t[1] = o[1] + (o[0] << 8 | o[0] >>> 24) + o[7] | 0, t[2] = o[2] + (o[1] << 16 | o[1] >>> 16) + (o[0] << 16 | o[0] >>> 16) | 0, t[3] = o[3] + (o[2] << 8 | o[2] >>> 24) + o[1] | 0, t[4] = o[4] + (o[3] << 16 | o[3] >>> 16) + (o[2] << 16 | o[2] >>> 16) | 0, t[5] = o[5] + (o[4] << 8 | o[4] >>> 24) + o[3] | 0, t[6] = o[6] + (o[5] << 16 | o[5] >>> 16) + (o[4] << 16 | o[4] >>> 16) | 0, t[7] = o[7] + (o[6] << 8 | o[6] >>> 24) + o[5] | 0
                        }
                        e.RabbitLegacy = n._createHelper(a)
                    }(), t.RabbitLegacy
                }(n(8249), n(8269), n(8214), n(888), n(5109))
            },
            4454: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.StreamCipher,
                            r = e.algo,
                            i = [],
                            s = [],
                            o = [],
                            a = r.Rabbit = n.extend({
                                _doReset: function() {
                                    for (var t = this._key.words, e = this.cfg.iv, n = 0; n < 4; n++) t[n] = 16711935 & (t[n] << 8 | t[n] >>> 24) | 4278255360 & (t[n] << 24 | t[n] >>> 8);
                                    var r = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16],
                                        i = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                                    for (this._b = 0, n = 0; n < 4; n++) c.call(this);
                                    for (n = 0; n < 8; n++) i[n] ^= r[n + 4 & 7];
                                    if (e) {
                                        var s = e.words,
                                            o = s[0],
                                            a = s[1],
                                            l = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                                            u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),
                                            h = l >>> 16 | 4294901760 & u,
                                            d = u << 16 | 65535 & l;
                                        for (i[0] ^= l, i[1] ^= h, i[2] ^= u, i[3] ^= d, i[4] ^= l, i[5] ^= h, i[6] ^= u, i[7] ^= d, n = 0; n < 4; n++) c.call(this)
                                    }
                                },
                                _doProcessBlock: function(t, e) {
                                    var n = this._X;
                                    c.call(this), i[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16, i[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16, i[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16, i[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;
                                    for (var r = 0; r < 4; r++) i[r] = 16711935 & (i[r] << 8 | i[r] >>> 24) | 4278255360 & (i[r] << 24 | i[r] >>> 8), t[e + r] ^= i[r]
                                },
                                blockSize: 4,
                                ivSize: 2
                            });

                        function c() {
                            for (var t = this._X, e = this._C, n = 0; n < 8; n++) s[n] = e[n];
                            for (e[0] = e[0] + 1295307597 + this._b | 0, e[1] = e[1] + 3545052371 + (e[0] >>> 0 < s[0] >>> 0 ? 1 : 0) | 0, e[2] = e[2] + 886263092 + (e[1] >>> 0 < s[1] >>> 0 ? 1 : 0) | 0, e[3] = e[3] + 1295307597 + (e[2] >>> 0 < s[2] >>> 0 ? 1 : 0) | 0, e[4] = e[4] + 3545052371 + (e[3] >>> 0 < s[3] >>> 0 ? 1 : 0) | 0, e[5] = e[5] + 886263092 + (e[4] >>> 0 < s[4] >>> 0 ? 1 : 0) | 0, e[6] = e[6] + 1295307597 + (e[5] >>> 0 < s[5] >>> 0 ? 1 : 0) | 0, e[7] = e[7] + 3545052371 + (e[6] >>> 0 < s[6] >>> 0 ? 1 : 0) | 0, this._b = e[7] >>> 0 < s[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) {
                                var r = t[n] + e[n],
                                    i = 65535 & r,
                                    a = r >>> 16,
                                    c = ((i * i >>> 17) + i * a >>> 15) + a * a,
                                    l = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                                o[n] = c ^ l
                            }
                            t[0] = o[0] + (o[7] << 16 | o[7] >>> 16) + (o[6] << 16 | o[6] >>> 16) | 0, t[1] = o[1] + (o[0] << 8 | o[0] >>> 24) + o[7] | 0, t[2] = o[2] + (o[1] << 16 | o[1] >>> 16) + (o[0] << 16 | o[0] >>> 16) | 0, t[3] = o[3] + (o[2] << 8 | o[2] >>> 24) + o[1] | 0, t[4] = o[4] + (o[3] << 16 | o[3] >>> 16) + (o[2] << 16 | o[2] >>> 16) | 0, t[5] = o[5] + (o[4] << 8 | o[4] >>> 24) + o[3] | 0, t[6] = o[6] + (o[5] << 16 | o[5] >>> 16) + (o[4] << 16 | o[4] >>> 16) | 0, t[7] = o[7] + (o[6] << 8 | o[6] >>> 24) + o[5] | 0
                        }
                        e.Rabbit = n._createHelper(a)
                    }(), t.Rabbit
                }(n(8249), n(8269), n(8214), n(888), n(5109))
            },
            1857: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.StreamCipher,
                            r = e.algo,
                            i = r.RC4 = n.extend({
                                _doReset: function() {
                                    for (var t = this._key, e = t.words, n = t.sigBytes, r = this._S = [], i = 0; i < 256; i++) r[i] = i;
                                    i = 0;
                                    for (var s = 0; i < 256; i++) {
                                        var o = i % n,
                                            a = e[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                                        s = (s + r[i] + a) % 256;
                                        var c = r[i];
                                        r[i] = r[s], r[s] = c
                                    }
                                    this._i = this._j = 0
                                },
                                _doProcessBlock: function(t, e) {
                                    t[e] ^= s.call(this)
                                },
                                keySize: 8,
                                ivSize: 0
                            });

                        function s() {
                            for (var t = this._S, e = this._i, n = this._j, r = 0, i = 0; i < 4; i++) {
                                n = (n + t[e = (e + 1) % 256]) % 256;
                                var s = t[e];
                                t[e] = t[n], t[n] = s, r |= t[(t[e] + t[n]) % 256] << 24 - 8 * i
                            }
                            return this._i = e, this._j = n, r
                        }
                        e.RC4 = n._createHelper(i);
                        var o = r.RC4Drop = i.extend({
                            cfg: i.cfg.extend({
                                drop: 192
                            }),
                            _doReset: function() {
                                i._doReset.call(this);
                                for (var t = this.cfg.drop; t > 0; t--) s.call(this)
                            }
                        });
                        e.RC4Drop = n._createHelper(o)
                    }(), t.RC4
                }(n(8249), n(8269), n(8214), n(888), n(5109))
            },
            706: function(t, e, n) {
                t.exports = function(t) {
                    return function(e) {
                        var n = t,
                            r = n.lib,
                            i = r.WordArray,
                            s = r.Hasher,
                            o = n.algo,
                            a = i.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),
                            c = i.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),
                            l = i.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),
                            u = i.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),
                            h = i.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),
                            d = i.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),
                            p = o.RIPEMD160 = s.extend({
                                _doReset: function() {
                                    this._hash = i.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                                },
                                _doProcessBlock: function(t, e) {
                                    for (var n = 0; n < 16; n++) {
                                        var r = e + n,
                                            i = t[r];
                                        t[r] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8)
                                    }
                                    var s, o, p, _, b, w, M, S, T, E, A, L = this._hash.words,
                                        R = h.words,
                                        P = d.words,
                                        C = a.words,
                                        I = c.words,
                                        D = l.words,
                                        O = u.words;
                                    for (w = s = L[0], M = o = L[1], S = p = L[2], T = _ = L[3], E = b = L[4], n = 0; n < 80; n += 1) A = s + t[e + C[n]] | 0, A += n < 16 ? f(o, p, _) + R[0] : n < 32 ? m(o, p, _) + R[1] : n < 48 ? g(o, p, _) + R[2] : n < 64 ? v(o, p, _) + R[3] : y(o, p, _) + R[4], A = (A = x(A |= 0, D[n])) + b | 0, s = b, b = _, _ = x(p, 10), p = o, o = A, A = w + t[e + I[n]] | 0, A += n < 16 ? y(M, S, T) + P[0] : n < 32 ? v(M, S, T) + P[1] : n < 48 ? g(M, S, T) + P[2] : n < 64 ? m(M, S, T) + P[3] : f(M, S, T) + P[4], A = (A = x(A |= 0, O[n])) + E | 0, w = E, E = T, T = x(S, 10), S = M, M = A;
                                    A = L[1] + p + T | 0, L[1] = L[2] + _ + E | 0, L[2] = L[3] + b + w | 0, L[3] = L[4] + s + M | 0, L[4] = L[0] + o + S | 0, L[0] = A
                                },
                                _doFinalize: function() {
                                    var t = this._data,
                                        e = t.words,
                                        n = 8 * this._nDataBytes,
                                        r = 8 * t.sigBytes;
                                    e[r >>> 5] |= 128 << 24 - r % 32, e[14 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), t.sigBytes = 4 * (e.length + 1), this._process();
                                    for (var i = this._hash, s = i.words, o = 0; o < 5; o++) {
                                        var a = s[o];
                                        s[o] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                                    }
                                    return i
                                },
                                clone: function() {
                                    var t = s.clone.call(this);
                                    return t._hash = this._hash.clone(), t
                                }
                            });

                        function f(t, e, n) {
                            return t ^ e ^ n
                        }

                        function m(t, e, n) {
                            return t & e | ~t & n
                        }

                        function g(t, e, n) {
                            return (t | ~e) ^ n
                        }

                        function v(t, e, n) {
                            return t & n | e & ~n
                        }

                        function y(t, e, n) {
                            return t ^ (e | ~n)
                        }

                        function x(t, e) {
                            return t << e | t >>> 32 - e
                        }
                        n.RIPEMD160 = s._createHelper(p), n.HmacRIPEMD160 = s._createHmacHelper(p)
                    }(Math), t.RIPEMD160
                }(n(8249))
            },
            2783: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib,
                            r = n.WordArray,
                            i = n.Hasher,
                            s = e.algo,
                            o = [],
                            a = s.SHA1 = i.extend({
                                _doReset: function() {
                                    this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                                },
                                _doProcessBlock: function(t, e) {
                                    for (var n = this._hash.words, r = n[0], i = n[1], s = n[2], a = n[3], c = n[4], l = 0; l < 80; l++) {
                                        if (l < 16) o[l] = 0 | t[e + l];
                                        else {
                                            var u = o[l - 3] ^ o[l - 8] ^ o[l - 14] ^ o[l - 16];
                                            o[l] = u << 1 | u >>> 31
                                        }
                                        var h = (r << 5 | r >>> 27) + c + o[l];
                                        h += l < 20 ? 1518500249 + (i & s | ~i & a) : l < 40 ? 1859775393 + (i ^ s ^ a) : l < 60 ? (i & s | i & a | s & a) - 1894007588 : (i ^ s ^ a) - 899497514, c = a, a = s, s = i << 30 | i >>> 2, i = r, r = h
                                    }
                                    n[0] = n[0] + r | 0, n[1] = n[1] + i | 0, n[2] = n[2] + s | 0, n[3] = n[3] + a | 0, n[4] = n[4] + c | 0
                                },
                                _doFinalize: function() {
                                    var t = this._data,
                                        e = t.words,
                                        n = 8 * this._nDataBytes,
                                        r = 8 * t.sigBytes;
                                    return e[r >>> 5] |= 128 << 24 - r % 32, e[14 + (r + 64 >>> 9 << 4)] = Math.floor(n / 4294967296), e[15 + (r + 64 >>> 9 << 4)] = n, t.sigBytes = 4 * e.length, this._process(), this._hash
                                },
                                clone: function() {
                                    var t = i.clone.call(this);
                                    return t._hash = this._hash.clone(), t
                                }
                            });
                        e.SHA1 = i._createHelper(a), e.HmacSHA1 = i._createHmacHelper(a)
                    }(), t.SHA1
                }(n(8249))
            },
            7792: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.WordArray,
                            r = e.algo,
                            i = r.SHA256,
                            s = r.SHA224 = i.extend({
                                _doReset: function() {
                                    this._hash = new n.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
                                },
                                _doFinalize: function() {
                                    var t = i._doFinalize.call(this);
                                    return t.sigBytes -= 4, t
                                }
                            });
                        e.SHA224 = i._createHelper(s), e.HmacSHA224 = i._createHmacHelper(s)
                    }(), t.SHA224
                }(n(8249), n(2153))
            },
            2153: function(t, e, n) {
                t.exports = function(t) {
                    return function(e) {
                        var n = t,
                            r = n.lib,
                            i = r.WordArray,
                            s = r.Hasher,
                            o = n.algo,
                            a = [],
                            c = [];
                        ! function() {
                            function t(t) {
                                for (var n = e.sqrt(t), r = 2; r <= n; r++)
                                    if (!(t % r)) return !1;
                                return !0
                            }

                            function n(t) {
                                return 4294967296 * (t - (0 | t)) | 0
                            }
                            for (var r = 2, i = 0; i < 64;) t(r) && (i < 8 && (a[i] = n(e.pow(r, .5))), c[i] = n(e.pow(r, 1 / 3)), i++), r++
                        }();
                        var l = [],
                            u = o.SHA256 = s.extend({
                                _doReset: function() {
                                    this._hash = new i.init(a.slice(0))
                                },
                                _doProcessBlock: function(t, e) {
                                    for (var n = this._hash.words, r = n[0], i = n[1], s = n[2], o = n[3], a = n[4], u = n[5], h = n[6], d = n[7], p = 0; p < 64; p++) {
                                        if (p < 16) l[p] = 0 | t[e + p];
                                        else {
                                            var f = l[p - 15],
                                                m = (f << 25 | f >>> 7) ^ (f << 14 | f >>> 18) ^ f >>> 3,
                                                g = l[p - 2],
                                                v = (g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10;
                                            l[p] = m + l[p - 7] + v + l[p - 16]
                                        }
                                        var y = r & i ^ r & s ^ i & s,
                                            x = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22),
                                            _ = d + ((a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25)) + (a & u ^ ~a & h) + c[p] + l[p];
                                        d = h, h = u, u = a, a = o + _ | 0, o = s, s = i, i = r, r = _ + (x + y) | 0
                                    }
                                    n[0] = n[0] + r | 0, n[1] = n[1] + i | 0, n[2] = n[2] + s | 0, n[3] = n[3] + o | 0, n[4] = n[4] + a | 0, n[5] = n[5] + u | 0, n[6] = n[6] + h | 0, n[7] = n[7] + d | 0
                                },
                                _doFinalize: function() {
                                    var t = this._data,
                                        n = t.words,
                                        r = 8 * this._nDataBytes,
                                        i = 8 * t.sigBytes;
                                    return n[i >>> 5] |= 128 << 24 - i % 32, n[14 + (i + 64 >>> 9 << 4)] = e.floor(r / 4294967296), n[15 + (i + 64 >>> 9 << 4)] = r, t.sigBytes = 4 * n.length, this._process(), this._hash
                                },
                                clone: function() {
                                    var t = s.clone.call(this);
                                    return t._hash = this._hash.clone(), t
                                }
                            });
                        n.SHA256 = s._createHelper(u), n.HmacSHA256 = s._createHmacHelper(u)
                    }(Math), t.SHA256
                }(n(8249))
            },
            3327: function(t, e, n) {
                t.exports = function(t) {
                    return function(e) {
                        var n = t,
                            r = n.lib,
                            i = r.WordArray,
                            s = r.Hasher,
                            o = n.x64.Word,
                            a = n.algo,
                            c = [],
                            l = [],
                            u = [];
                        ! function() {
                            for (var t = 1, e = 0, n = 0; n < 24; n++) {
                                c[t + 5 * e] = (n + 1) * (n + 2) / 2 % 64;
                                var r = (2 * t + 3 * e) % 5;
                                t = e % 5, e = r
                            }
                            for (t = 0; t < 5; t++)
                                for (e = 0; e < 5; e++) l[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5;
                            for (var i = 1, s = 0; s < 24; s++) {
                                for (var a = 0, h = 0, d = 0; d < 7; d++) {
                                    if (1 & i) {
                                        var p = (1 << d) - 1;
                                        p < 32 ? h ^= 1 << p : a ^= 1 << p - 32
                                    }
                                    128 & i ? i = i << 1 ^ 113 : i <<= 1
                                }
                                u[s] = o.create(a, h)
                            }
                        }();
                        var h = [];
                        ! function() {
                            for (var t = 0; t < 25; t++) h[t] = o.create()
                        }();
                        var d = a.SHA3 = s.extend({
                            cfg: s.cfg.extend({
                                outputLength: 512
                            }),
                            _doReset: function() {
                                for (var t = this._state = [], e = 0; e < 25; e++) t[e] = new o.init;
                                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                            },
                            _doProcessBlock: function(t, e) {
                                for (var n = this._state, r = this.blockSize / 2, i = 0; i < r; i++) {
                                    var s = t[e + 2 * i],
                                        o = t[e + 2 * i + 1];
                                    s = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8), o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);
                                    var a = n[i];
                                    a.high ^= o, a.low ^= s
                                }
                                for (var d = 0; d < 24; d++) {
                                    for (var p = 0; p < 5; p++) {
                                        for (var f = 0, m = 0, g = 0; g < 5; g++) f ^= (a = n[p + 5 * g]).high, m ^= a.low;
                                        var v = h[p];
                                        v.high = f, v.low = m
                                    }
                                    for (p = 0; p < 5; p++) {
                                        var y = h[(p + 4) % 5],
                                            x = h[(p + 1) % 5],
                                            _ = x.high,
                                            b = x.low;
                                        for (f = y.high ^ (_ << 1 | b >>> 31), m = y.low ^ (b << 1 | _ >>> 31), g = 0; g < 5; g++)(a = n[p + 5 * g]).high ^= f, a.low ^= m
                                    }
                                    for (var w = 1; w < 25; w++) {
                                        var M = (a = n[w]).high,
                                            S = a.low,
                                            T = c[w];
                                        T < 32 ? (f = M << T | S >>> 32 - T, m = S << T | M >>> 32 - T) : (f = S << T - 32 | M >>> 64 - T, m = M << T - 32 | S >>> 64 - T);
                                        var E = h[l[w]];
                                        E.high = f, E.low = m
                                    }
                                    var A = h[0],
                                        L = n[0];
                                    for (A.high = L.high, A.low = L.low, p = 0; p < 5; p++)
                                        for (g = 0; g < 5; g++) {
                                            a = n[w = p + 5 * g];
                                            var R = h[w],
                                                P = h[(p + 1) % 5 + 5 * g],
                                                C = h[(p + 2) % 5 + 5 * g];
                                            a.high = R.high ^ ~P.high & C.high, a.low = R.low ^ ~P.low & C.low
                                        }
                                    a = n[0];
                                    var I = u[d];
                                    a.high ^= I.high, a.low ^= I.low
                                }
                            },
                            _doFinalize: function() {
                                var t = this._data,
                                    n = t.words,
                                    r = (this._nDataBytes, 8 * t.sigBytes),
                                    s = 32 * this.blockSize;
                                n[r >>> 5] |= 1 << 24 - r % 32, n[(e.ceil((r + 1) / s) * s >>> 5) - 1] |= 128, t.sigBytes = 4 * n.length, this._process();
                                for (var o = this._state, a = this.cfg.outputLength / 8, c = a / 8, l = [], u = 0; u < c; u++) {
                                    var h = o[u],
                                        d = h.high,
                                        p = h.low;
                                    d = 16711935 & (d << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8), p = 16711935 & (p << 8 | p >>> 24) | 4278255360 & (p << 24 | p >>> 8), l.push(p), l.push(d)
                                }
                                return new i.init(l, a)
                            },
                            clone: function() {
                                for (var t = s.clone.call(this), e = t._state = this._state.slice(0), n = 0; n < 25; n++) e[n] = e[n].clone();
                                return t
                            }
                        });
                        n.SHA3 = s._createHelper(d), n.HmacSHA3 = s._createHmacHelper(d)
                    }(Math), t.SHA3
                }(n(8249), n(4938))
            },
            7460: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.x64,
                            r = n.Word,
                            i = n.WordArray,
                            s = e.algo,
                            o = s.SHA512,
                            a = s.SHA384 = o.extend({
                                _doReset: function() {
                                    this._hash = new i.init([new r.init(3418070365, 3238371032), new r.init(1654270250, 914150663), new r.init(2438529370, 812702999), new r.init(355462360, 4144912697), new r.init(1731405415, 4290775857), new r.init(2394180231, 1750603025), new r.init(3675008525, 1694076839), new r.init(1203062813, 3204075428)])
                                },
                                _doFinalize: function() {
                                    var t = o._doFinalize.call(this);
                                    return t.sigBytes -= 16, t
                                }
                            });
                        e.SHA384 = o._createHelper(a), e.HmacSHA384 = o._createHmacHelper(a)
                    }(), t.SHA384
                }(n(8249), n(4938), n(34))
            },
            34: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib.Hasher,
                            r = e.x64,
                            i = r.Word,
                            s = r.WordArray,
                            o = e.algo;

                        function a() {
                            return i.create.apply(i, arguments)
                        }
                        var c = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317), a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291, 2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899), a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470, 3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)],
                            l = [];
                        ! function() {
                            for (var t = 0; t < 80; t++) l[t] = a()
                        }();
                        var u = o.SHA512 = n.extend({
                            _doReset: function() {
                                this._hash = new s.init([new i.init(1779033703, 4089235720), new i.init(3144134277, 2227873595), new i.init(1013904242, 4271175723), new i.init(2773480762, 1595750129), new i.init(1359893119, 2917565137), new i.init(2600822924, 725511199), new i.init(528734635, 4215389547), new i.init(1541459225, 327033209)])
                            },
                            _doProcessBlock: function(t, e) {
                                for (var n = this._hash.words, r = n[0], i = n[1], s = n[2], o = n[3], a = n[4], u = n[5], h = n[6], d = n[7], p = r.high, f = r.low, m = i.high, g = i.low, v = s.high, y = s.low, x = o.high, _ = o.low, b = a.high, w = a.low, M = u.high, S = u.low, T = h.high, E = h.low, A = d.high, L = d.low, R = p, P = f, C = m, I = g, D = v, O = y, N = x, B = _, z = b, F = w, k = M, U = S, H = T, G = E, V = A, W = L, j = 0; j < 80; j++) {
                                    var Z, q, X = l[j];
                                    if (j < 16) q = X.high = 0 | t[e + 2 * j], Z = X.low = 0 | t[e + 2 * j + 1];
                                    else {
                                        var Y = l[j - 15],
                                            J = Y.high,
                                            K = Y.low,
                                            Q = (J >>> 1 | K << 31) ^ (J >>> 8 | K << 24) ^ J >>> 7,
                                            $ = (K >>> 1 | J << 31) ^ (K >>> 8 | J << 24) ^ (K >>> 7 | J << 25),
                                            tt = l[j - 2],
                                            et = tt.high,
                                            nt = tt.low,
                                            rt = (et >>> 19 | nt << 13) ^ (et << 3 | nt >>> 29) ^ et >>> 6,
                                            it = (nt >>> 19 | et << 13) ^ (nt << 3 | et >>> 29) ^ (nt >>> 6 | et << 26),
                                            st = l[j - 7],
                                            ot = st.high,
                                            at = st.low,
                                            ct = l[j - 16],
                                            lt = ct.high,
                                            ut = ct.low;
                                        q = (q = (q = Q + ot + ((Z = $ + at) >>> 0 < $ >>> 0 ? 1 : 0)) + rt + ((Z += it) >>> 0 < it >>> 0 ? 1 : 0)) + lt + ((Z += ut) >>> 0 < ut >>> 0 ? 1 : 0), X.high = q, X.low = Z
                                    }
                                    var ht = z & k ^ ~z & H,
                                        dt = F & U ^ ~F & G,
                                        pt = R & C ^ R & D ^ C & D,
                                        ft = P & I ^ P & O ^ I & O,
                                        mt = (R >>> 28 | P << 4) ^ (R << 30 | P >>> 2) ^ (R << 25 | P >>> 7),
                                        gt = (P >>> 28 | R << 4) ^ (P << 30 | R >>> 2) ^ (P << 25 | R >>> 7),
                                        vt = (z >>> 14 | F << 18) ^ (z >>> 18 | F << 14) ^ (z << 23 | F >>> 9),
                                        yt = (F >>> 14 | z << 18) ^ (F >>> 18 | z << 14) ^ (F << 23 | z >>> 9),
                                        xt = c[j],
                                        _t = xt.high,
                                        bt = xt.low,
                                        wt = W + yt,
                                        Mt = V + vt + (wt >>> 0 < W >>> 0 ? 1 : 0),
                                        St = (Mt = (Mt = (Mt = Mt + ht + ((wt += dt) >>> 0 < dt >>> 0 ? 1 : 0)) + _t + ((wt += bt) >>> 0 < bt >>> 0 ? 1 : 0)) + q + ((wt += Z) >>> 0 < Z >>> 0 ? 1 : 0), gt + ft);
                                    V = H, W = G, H = k, G = U, k = z, U = F, z = N + Mt + ((F = B + wt | 0) >>> 0 < B >>> 0 ? 1 : 0) | 0, N = D, B = O, D = C, O = I, C = R, I = P, R = Mt + (mt + pt + (St >>> 0 < gt >>> 0 ? 1 : 0)) + ((P = wt + St | 0) >>> 0 < wt >>> 0 ? 1 : 0) | 0
                                }
                                f = r.low = f + P, r.high = p + R + (f >>> 0 < P >>> 0 ? 1 : 0), g = i.low = g + I, i.high = m + C + (g >>> 0 < I >>> 0 ? 1 : 0), y = s.low = y + O, s.high = v + D + (y >>> 0 < O >>> 0 ? 1 : 0), _ = o.low = _ + B, o.high = x + N + (_ >>> 0 < B >>> 0 ? 1 : 0), w = a.low = w + F, a.high = b + z + (w >>> 0 < F >>> 0 ? 1 : 0), S = u.low = S + U, u.high = M + k + (S >>> 0 < U >>> 0 ? 1 : 0), E = h.low = E + G, h.high = T + H + (E >>> 0 < G >>> 0 ? 1 : 0), L = d.low = L + W, d.high = A + V + (L >>> 0 < W >>> 0 ? 1 : 0)
                            },
                            _doFinalize: function() {
                                var t = this._data,
                                    e = t.words,
                                    n = 8 * this._nDataBytes,
                                    r = 8 * t.sigBytes;
                                return e[r >>> 5] |= 128 << 24 - r % 32, e[30 + (r + 128 >>> 10 << 5)] = Math.floor(n / 4294967296), e[31 + (r + 128 >>> 10 << 5)] = n, t.sigBytes = 4 * e.length, this._process(), this._hash.toX32()
                            },
                            clone: function() {
                                var t = n.clone.call(this);
                                return t._hash = this._hash.clone(), t
                            },
                            blockSize: 32
                        });
                        e.SHA512 = n._createHelper(u), e.HmacSHA512 = n._createHmacHelper(u)
                    }(), t.SHA512
                }(n(8249), n(4938))
            },
            4253: function(t, e, n) {
                t.exports = function(t) {
                    return function() {
                        var e = t,
                            n = e.lib,
                            r = n.WordArray,
                            i = n.BlockCipher,
                            s = e.algo,
                            o = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],
                            a = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],
                            c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],
                            l = [{
                                0: 8421888,
                                268435456: 32768,
                                536870912: 8421378,
                                805306368: 2,
                                1073741824: 512,
                                1342177280: 8421890,
                                1610612736: 8389122,
                                1879048192: 8388608,
                                2147483648: 514,
                                2415919104: 8389120,
                                2684354560: 33280,
                                2952790016: 8421376,
                                3221225472: 32770,
                                3489660928: 8388610,
                                3758096384: 0,
                                4026531840: 33282,
                                134217728: 0,
                                402653184: 8421890,
                                671088640: 33282,
                                939524096: 32768,
                                1207959552: 8421888,
                                1476395008: 512,
                                1744830464: 8421378,
                                2013265920: 2,
                                2281701376: 8389120,
                                2550136832: 33280,
                                2818572288: 8421376,
                                3087007744: 8389122,
                                3355443200: 8388610,
                                3623878656: 32770,
                                3892314112: 514,
                                4160749568: 8388608,
                                1: 32768,
                                268435457: 2,
                                536870913: 8421888,
                                805306369: 8388608,
                                1073741825: 8421378,
                                1342177281: 33280,
                                1610612737: 512,
                                1879048193: 8389122,
                                2147483649: 8421890,
                                2415919105: 8421376,
                                2684354561: 8388610,
                                2952790017: 33282,
                                3221225473: 514,
                                3489660929: 8389120,
                                3758096385: 32770,
                                4026531841: 0,
                                134217729: 8421890,
                                402653185: 8421376,
                                671088641: 8388608,
                                939524097: 512,
                                1207959553: 32768,
                                1476395009: 8388610,
                                1744830465: 2,
                                2013265921: 33282,
                                2281701377: 32770,
                                2550136833: 8389122,
                                2818572289: 514,
                                3087007745: 8421888,
                                3355443201: 8389120,
                                3623878657: 0,
                                3892314113: 33280,
                                4160749569: 8421378
                            }, {
                                0: 1074282512,
                                16777216: 16384,
                                33554432: 524288,
                                50331648: 1074266128,
                                67108864: 1073741840,
                                83886080: 1074282496,
                                100663296: 1073758208,
                                117440512: 16,
                                134217728: 540672,
                                150994944: 1073758224,
                                167772160: 1073741824,
                                184549376: 540688,
                                201326592: 524304,
                                218103808: 0,
                                234881024: 16400,
                                251658240: 1074266112,
                                8388608: 1073758208,
                                25165824: 540688,
                                41943040: 16,
                                58720256: 1073758224,
                                75497472: 1074282512,
                                92274688: 1073741824,
                                109051904: 524288,
                                125829120: 1074266128,
                                142606336: 524304,
                                159383552: 0,
                                176160768: 16384,
                                192937984: 1074266112,
                                209715200: 1073741840,
                                226492416: 540672,
                                243269632: 1074282496,
                                260046848: 16400,
                                268435456: 0,
                                285212672: 1074266128,
                                301989888: 1073758224,
                                318767104: 1074282496,
                                335544320: 1074266112,
                                352321536: 16,
                                369098752: 540688,
                                385875968: 16384,
                                402653184: 16400,
                                419430400: 524288,
                                436207616: 524304,
                                452984832: 1073741840,
                                469762048: 540672,
                                486539264: 1073758208,
                                503316480: 1073741824,
                                520093696: 1074282512,
                                276824064: 540688,
                                293601280: 524288,
                                310378496: 1074266112,
                                327155712: 16384,
                                343932928: 1073758208,
                                360710144: 1074282512,
                                377487360: 16,
                                394264576: 1073741824,
                                411041792: 1074282496,
                                427819008: 1073741840,
                                444596224: 1073758224,
                                461373440: 524304,
                                478150656: 0,
                                494927872: 16400,
                                511705088: 1074266128,
                                528482304: 540672
                            }, {
                                0: 260,
                                1048576: 0,
                                2097152: 67109120,
                                3145728: 65796,
                                4194304: 65540,
                                5242880: 67108868,
                                6291456: 67174660,
                                7340032: 67174400,
                                8388608: 67108864,
                                9437184: 67174656,
                                10485760: 65792,
                                11534336: 67174404,
                                12582912: 67109124,
                                13631488: 65536,
                                14680064: 4,
                                15728640: 256,
                                524288: 67174656,
                                1572864: 67174404,
                                2621440: 0,
                                3670016: 67109120,
                                4718592: 67108868,
                                5767168: 65536,
                                6815744: 65540,
                                7864320: 260,
                                8912896: 4,
                                9961472: 256,
                                11010048: 67174400,
                                12058624: 65796,
                                13107200: 65792,
                                14155776: 67109124,
                                15204352: 67174660,
                                16252928: 67108864,
                                16777216: 67174656,
                                17825792: 65540,
                                18874368: 65536,
                                19922944: 67109120,
                                20971520: 256,
                                22020096: 67174660,
                                23068672: 67108868,
                                24117248: 0,
                                25165824: 67109124,
                                26214400: 67108864,
                                27262976: 4,
                                28311552: 65792,
                                29360128: 67174400,
                                30408704: 260,
                                31457280: 65796,
                                32505856: 67174404,
                                17301504: 67108864,
                                18350080: 260,
                                19398656: 67174656,
                                20447232: 0,
                                21495808: 65540,
                                22544384: 67109120,
                                23592960: 256,
                                24641536: 67174404,
                                25690112: 65536,
                                26738688: 67174660,
                                27787264: 65796,
                                28835840: 67108868,
                                29884416: 67109124,
                                30932992: 67174400,
                                31981568: 4,
                                33030144: 65792
                            }, {
                                0: 2151682048,
                                65536: 2147487808,
                                131072: 4198464,
                                196608: 2151677952,
                                262144: 0,
                                327680: 4198400,
                                393216: 2147483712,
                                458752: 4194368,
                                524288: 2147483648,
                                589824: 4194304,
                                655360: 64,
                                720896: 2147487744,
                                786432: 2151678016,
                                851968: 4160,
                                917504: 4096,
                                983040: 2151682112,
                                32768: 2147487808,
                                98304: 64,
                                163840: 2151678016,
                                229376: 2147487744,
                                294912: 4198400,
                                360448: 2151682112,
                                425984: 0,
                                491520: 2151677952,
                                557056: 4096,
                                622592: 2151682048,
                                688128: 4194304,
                                753664: 4160,
                                819200: 2147483648,
                                884736: 4194368,
                                950272: 4198464,
                                1015808: 2147483712,
                                1048576: 4194368,
                                1114112: 4198400,
                                1179648: 2147483712,
                                1245184: 0,
                                1310720: 4160,
                                1376256: 2151678016,
                                1441792: 2151682048,
                                1507328: 2147487808,
                                1572864: 2151682112,
                                1638400: 2147483648,
                                1703936: 2151677952,
                                1769472: 4198464,
                                1835008: 2147487744,
                                1900544: 4194304,
                                1966080: 64,
                                2031616: 4096,
                                1081344: 2151677952,
                                1146880: 2151682112,
                                1212416: 0,
                                1277952: 4198400,
                                1343488: 4194368,
                                1409024: 2147483648,
                                1474560: 2147487808,
                                1540096: 64,
                                1605632: 2147483712,
                                1671168: 4096,
                                1736704: 2147487744,
                                1802240: 2151678016,
                                1867776: 4160,
                                1933312: 2151682048,
                                1998848: 4194304,
                                2064384: 4198464
                            }, {
                                0: 128,
                                4096: 17039360,
                                8192: 262144,
                                12288: 536870912,
                                16384: 537133184,
                                20480: 16777344,
                                24576: 553648256,
                                28672: 262272,
                                32768: 16777216,
                                36864: 537133056,
                                40960: 536871040,
                                45056: 553910400,
                                49152: 553910272,
                                53248: 0,
                                57344: 17039488,
                                61440: 553648128,
                                2048: 17039488,
                                6144: 553648256,
                                10240: 128,
                                14336: 17039360,
                                18432: 262144,
                                22528: 537133184,
                                26624: 553910272,
                                30720: 536870912,
                                34816: 537133056,
                                38912: 0,
                                43008: 553910400,
                                47104: 16777344,
                                51200: 536871040,
                                55296: 553648128,
                                59392: 16777216,
                                63488: 262272,
                                65536: 262144,
                                69632: 128,
                                73728: 536870912,
                                77824: 553648256,
                                81920: 16777344,
                                86016: 553910272,
                                90112: 537133184,
                                94208: 16777216,
                                98304: 553910400,
                                102400: 553648128,
                                106496: 17039360,
                                110592: 537133056,
                                114688: 262272,
                                118784: 536871040,
                                122880: 0,
                                126976: 17039488,
                                67584: 553648256,
                                71680: 16777216,
                                75776: 17039360,
                                79872: 537133184,
                                83968: 536870912,
                                88064: 17039488,
                                92160: 128,
                                96256: 553910272,
                                100352: 262272,
                                104448: 553910400,
                                108544: 0,
                                112640: 553648128,
                                116736: 16777344,
                                120832: 262144,
                                124928: 537133056,
                                129024: 536871040
                            }, {
                                0: 268435464,
                                256: 8192,
                                512: 270532608,
                                768: 270540808,
                                1024: 268443648,
                                1280: 2097152,
                                1536: 2097160,
                                1792: 268435456,
                                2048: 0,
                                2304: 268443656,
                                2560: 2105344,
                                2816: 8,
                                3072: 270532616,
                                3328: 2105352,
                                3584: 8200,
                                3840: 270540800,
                                128: 270532608,
                                384: 270540808,
                                640: 8,
                                896: 2097152,
                                1152: 2105352,
                                1408: 268435464,
                                1664: 268443648,
                                1920: 8200,
                                2176: 2097160,
                                2432: 8192,
                                2688: 268443656,
                                2944: 270532616,
                                3200: 0,
                                3456: 270540800,
                                3712: 2105344,
                                3968: 268435456,
                                4096: 268443648,
                                4352: 270532616,
                                4608: 270540808,
                                4864: 8200,
                                5120: 2097152,
                                5376: 268435456,
                                5632: 268435464,
                                5888: 2105344,
                                6144: 2105352,
                                6400: 0,
                                6656: 8,
                                6912: 270532608,
                                7168: 8192,
                                7424: 268443656,
                                7680: 270540800,
                                7936: 2097160,
                                4224: 8,
                                4480: 2105344,
                                4736: 2097152,
                                4992: 268435464,
                                5248: 268443648,
                                5504: 8200,
                                5760: 270540808,
                                6016: 270532608,
                                6272: 270540800,
                                6528: 270532616,
                                6784: 8192,
                                7040: 2105352,
                                7296: 2097160,
                                7552: 0,
                                7808: 268435456,
                                8064: 268443656
                            }, {
                                0: 1048576,
                                16: 33555457,
                                32: 1024,
                                48: 1049601,
                                64: 34604033,
                                80: 0,
                                96: 1,
                                112: 34603009,
                                128: 33555456,
                                144: 1048577,
                                160: 33554433,
                                176: 34604032,
                                192: 34603008,
                                208: 1025,
                                224: 1049600,
                                240: 33554432,
                                8: 34603009,
                                24: 0,
                                40: 33555457,
                                56: 34604032,
                                72: 1048576,
                                88: 33554433,
                                104: 33554432,
                                120: 1025,
                                136: 1049601,
                                152: 33555456,
                                168: 34603008,
                                184: 1048577,
                                200: 1024,
                                216: 34604033,
                                232: 1,
                                248: 1049600,
                                256: 33554432,
                                272: 1048576,
                                288: 33555457,
                                304: 34603009,
                                320: 1048577,
                                336: 33555456,
                                352: 34604032,
                                368: 1049601,
                                384: 1025,
                                400: 34604033,
                                416: 1049600,
                                432: 1,
                                448: 0,
                                464: 34603008,
                                480: 33554433,
                                496: 1024,
                                264: 1049600,
                                280: 33555457,
                                296: 34603009,
                                312: 1,
                                328: 33554432,
                                344: 1048576,
                                360: 1025,
                                376: 34604032,
                                392: 33554433,
                                408: 34603008,
                                424: 0,
                                440: 34604033,
                                456: 1049601,
                                472: 1024,
                                488: 33555456,
                                504: 1048577
                            }, {
                                0: 134219808,
                                1: 131072,
                                2: 134217728,
                                3: 32,
                                4: 131104,
                                5: 134350880,
                                6: 134350848,
                                7: 2048,
                                8: 134348800,
                                9: 134219776,
                                10: 133120,
                                11: 134348832,
                                12: 2080,
                                13: 0,
                                14: 134217760,
                                15: 133152,
                                2147483648: 2048,
                                2147483649: 134350880,
                                2147483650: 134219808,
                                2147483651: 134217728,
                                2147483652: 134348800,
                                2147483653: 133120,
                                2147483654: 133152,
                                2147483655: 32,
                                2147483656: 134217760,
                                2147483657: 2080,
                                2147483658: 131104,
                                2147483659: 134350848,
                                2147483660: 0,
                                2147483661: 134348832,
                                2147483662: 134219776,
                                2147483663: 131072,
                                16: 133152,
                                17: 134350848,
                                18: 32,
                                19: 2048,
                                20: 134219776,
                                21: 134217760,
                                22: 134348832,
                                23: 131072,
                                24: 0,
                                25: 131104,
                                26: 134348800,
                                27: 134219808,
                                28: 134350880,
                                29: 133120,
                                30: 2080,
                                31: 134217728,
                                2147483664: 131072,
                                2147483665: 2048,
                                2147483666: 134348832,
                                2147483667: 133152,
                                2147483668: 32,
                                2147483669: 134348800,
                                2147483670: 134217728,
                                2147483671: 134219808,
                                2147483672: 134350880,
                                2147483673: 134217760,
                                2147483674: 134219776,
                                2147483675: 0,
                                2147483676: 133120,
                                2147483677: 2080,
                                2147483678: 131104,
                                2147483679: 134350848
                            }],
                            u = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],
                            h = s.DES = i.extend({
                                _doReset: function() {
                                    for (var t = this._key.words, e = [], n = 0; n < 56; n++) {
                                        var r = o[n] - 1;
                                        e[n] = t[r >>> 5] >>> 31 - r % 32 & 1
                                    }
                                    for (var i = this._subKeys = [], s = 0; s < 16; s++) {
                                        var l = i[s] = [],
                                            u = c[s];
                                        for (n = 0; n < 24; n++) l[n / 6 | 0] |= e[(a[n] - 1 + u) % 28] << 31 - n % 6, l[4 + (n / 6 | 0)] |= e[28 + (a[n + 24] - 1 + u) % 28] << 31 - n % 6;
                                        for (l[0] = l[0] << 1 | l[0] >>> 31, n = 1; n < 7; n++) l[n] = l[n] >>> 4 * (n - 1) + 3;
                                        l[7] = l[7] << 5 | l[7] >>> 27
                                    }
                                    var h = this._invSubKeys = [];
                                    for (n = 0; n < 16; n++) h[n] = i[15 - n]
                                },
                                encryptBlock: function(t, e) {
                                    this._doCryptBlock(t, e, this._subKeys)
                                },
                                decryptBlock: function(t, e) {
                                    this._doCryptBlock(t, e, this._invSubKeys)
                                },
                                _doCryptBlock: function(t, e, n) {
                                    this._lBlock = t[e], this._rBlock = t[e + 1], d.call(this, 4, 252645135), d.call(this, 16, 65535), p.call(this, 2, 858993459), p.call(this, 8, 16711935), d.call(this, 1, 1431655765);
                                    for (var r = 0; r < 16; r++) {
                                        for (var i = n[r], s = this._lBlock, o = this._rBlock, a = 0, c = 0; c < 8; c++) a |= l[c][((o ^ i[c]) & u[c]) >>> 0];
                                        this._lBlock = o, this._rBlock = s ^ a
                                    }
                                    var h = this._lBlock;
                                    this._lBlock = this._rBlock, this._rBlock = h, d.call(this, 1, 1431655765), p.call(this, 8, 16711935), p.call(this, 2, 858993459), d.call(this, 16, 65535), d.call(this, 4, 252645135), t[e] = this._lBlock, t[e + 1] = this._rBlock
                                },
                                keySize: 2,
                                ivSize: 2,
                                blockSize: 2
                            });

                        function d(t, e) {
                            var n = (this._lBlock >>> t ^ this._rBlock) & e;
                            this._rBlock ^= n, this._lBlock ^= n << t
                        }

                        function p(t, e) {
                            var n = (this._rBlock >>> t ^ this._lBlock) & e;
                            this._lBlock ^= n, this._rBlock ^= n << t
                        }
                        e.DES = i._createHelper(h);
                        var f = s.TripleDES = i.extend({
                            _doReset: function() {
                                var t = this._key.words;
                                if (2 !== t.length && 4 !== t.length && t.length < 6) throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                                var e = t.slice(0, 2),
                                    n = t.length < 4 ? t.slice(0, 2) : t.slice(2, 4),
                                    i = t.length < 6 ? t.slice(0, 2) : t.slice(4, 6);
                                this._des1 = h.createEncryptor(r.create(e)), this._des2 = h.createEncryptor(r.create(n)), this._des3 = h.createEncryptor(r.create(i))
                            },
                            encryptBlock: function(t, e) {
                                this._des1.encryptBlock(t, e), this._des2.decryptBlock(t, e), this._des3.encryptBlock(t, e)
                            },
                            decryptBlock: function(t, e) {
                                this._des3.decryptBlock(t, e), this._des2.encryptBlock(t, e), this._des1.decryptBlock(t, e)
                            },
                            keySize: 6,
                            ivSize: 2,
                            blockSize: 2
                        });
                        e.TripleDES = i._createHelper(f)
                    }(), t.TripleDES
                }(n(8249), n(8269), n(8214), n(888), n(5109))
            },
            4938: function(t, e, n) {
                t.exports = function(t) {
                    return function(e) {
                        var n = t,
                            r = n.lib,
                            i = r.Base,
                            s = r.WordArray,
                            o = n.x64 = {};
                        o.Word = i.extend({
                            init: function(t, e) {
                                this.high = t, this.low = e
                            }
                        }), o.WordArray = i.extend({
                            init: function(t, e) {
                                t = this.words = t || [], this.sigBytes = null != e ? e : 8 * t.length
                            },
                            toX32: function() {
                                for (var t = this.words, e = t.length, n = [], r = 0; r < e; r++) {
                                    var i = t[r];
                                    n.push(i.high), n.push(i.low)
                                }
                                return s.create(n, this.sigBytes)
                            },
                            clone: function() {
                                for (var t = i.clone.call(this), e = t.words = this.words.slice(0), n = e.length, r = 0; r < n; r++) e[r] = e[r].clone();
                                return t
                            }
                        })
                    }(), t
                }(n(8249))
            },
            6387: function(t, e, n) {
                var r;
                ! function(i) {
                    var s = Object.hasOwnProperty,
                        o = Array.isArray ? Array.isArray : function(t) {
                            return "[object Array]" === Object.prototype.toString.call(t)
                        },
                        a = "object" == typeof process && "function" == typeof process.nextTick,
                        c = "function" == typeof Symbol,
                        l = "object" == typeof Reflect,
                        u = "function" == typeof setImmediate ? setImmediate : setTimeout,
                        h = c ? l && "function" == typeof Reflect.ownKeys ? Reflect.ownKeys : function(t) {
                            var e = Object.getOwnPropertyNames(t);
                            return e.push.apply(e, Object.getOwnPropertySymbols(t)), e
                        } : Object.keys;

                    function d() {
                        this._events = {}, this._conf && p.call(this, this._conf)
                    }

                    function p(t) {
                        t && (this._conf = t, t.delimiter && (this.delimiter = t.delimiter), t.maxListeners !== i && (this._maxListeners = t.maxListeners), t.wildcard && (this.wildcard = t.wildcard), t.newListener && (this._newListener = t.newListener), t.removeListener && (this._removeListener = t.removeListener), t.verboseMemoryLeak && (this.verboseMemoryLeak = t.verboseMemoryLeak), t.ignoreErrors && (this.ignoreErrors = t.ignoreErrors), this.wildcard && (this.listenerTree = {}))
                    }

                    function f(t, e) {
                        var n = "(node) warning: possible EventEmitter memory leak detected. " + t + " listeners added. Use emitter.setMaxListeners() to increase limit.";
                        if (this.verboseMemoryLeak && (n += " Event name: " + e + "."), "undefined" != typeof process && process.emitWarning) {
                            var r = new Error(n);
                            r.name = "MaxListenersExceededWarning", r.emitter = this, r.count = t, process.emitWarning(r)
                        } else console.error(n), console.trace && console.trace()
                    }
                    var m = function(t, e, n) {
                        var r = arguments.length;
                        switch (r) {
                            case 0:
                                return [];
                            case 1:
                                return [t];
                            case 2:
                                return [t, e];
                            case 3:
                                return [t, e, n];
                            default:
                                for (var i = new Array(r); r--;) i[r] = arguments[r];
                                return i
                        }
                    };

                    function g(t, e) {
                        for (var n = {}, r = t.length, s = e ? e.length : 0, o = 0; o < r; o++) n[t[o]] = o < s ? e[o] : i;
                        return n
                    }

                    function v(t, e, n) {
                        var r, i;
                        if (this._emitter = t, this._target = e, this._listeners = {}, this._listenersCount = 0, (n.on || n.off) && (r = n.on, i = n.off), e.addEventListener ? (r = e.addEventListener, i = e.removeEventListener) : e.addListener ? (r = e.addListener, i = e.removeListener) : e.on && (r = e.on, i = e.off), !r && !i) throw Error("target does not implement any known event API");
                        if ("function" != typeof r) throw TypeError("on method must be a function");
                        if ("function" != typeof i) throw TypeError("off method must be a function");
                        this._on = r, this._off = i;
                        var s = t._observers;
                        s ? s.push(this) : t._observers = [this]
                    }

                    function y(t, e, n, r) {
                        var o = Object.assign({}, e);
                        if (!t) return o;
                        if ("object" != typeof t) throw TypeError("options must be an object");
                        var a, c, l, u = Object.keys(t),
                            h = u.length;

                        function d(t) {
                            throw Error('Invalid "' + a + '" option value' + (t ? ". Reason: " + t : ""))
                        }
                        for (var p = 0; p < h; p++) {
                            if (a = u[p], !r && !s.call(e, a)) throw Error('Unknown "' + a + '" option');
                            (c = t[a]) !== i && (l = n[a], o[a] = l ? l(c, d) : c)
                        }
                        return o
                    }

                    function x(t, e) {
                        return "function" == typeof t && t.hasOwnProperty("prototype") || e("value must be a constructor"), t
                    }

                    function _(t) {
                        var e = "value must be type of " + t.join("|"),
                            n = t.length,
                            r = t[0],
                            i = t[1];
                        return 1 === n ? function(t, n) {
                            if (typeof t === r) return t;
                            n(e)
                        } : 2 === n ? function(t, n) {
                            var s = typeof t;
                            if (s === r || s === i) return t;
                            n(e)
                        } : function(r, i) {
                            for (var s = typeof r, o = n; o-- > 0;)
                                if (s === t[o]) return r;
                            i(e)
                        }
                    }
                    Object.assign(v.prototype, {
                        subscribe: function(t, e, n) {
                            var r = this,
                                i = this._target,
                                s = this._emitter,
                                o = this._listeners,
                                a = function() {
                                    var r = m.apply(null, arguments),
                                        o = {
                                            data: r,
                                            name: e,
                                            original: t
                                        };
                                    if (n) {
                                        var a = n.call(i, o);
                                        !1 !== a && s.emit.apply(s, [o.name].concat(r))
                                    } else s.emit.apply(s, [e].concat(r))
                                };
                            if (o[t]) throw Error("Event '" + t + "' is already listening");
                            this._listenersCount++, s._newListener && s._removeListener && !r._onNewListener ? (this._onNewListener = function(n) {
                                n === e && null === o[t] && (o[t] = a, r._on.call(i, t, a))
                            }, s.on("newListener", this._onNewListener), this._onRemoveListener = function(n) {
                                n === e && !s.hasListeners(n) && o[t] && (o[t] = null, r._off.call(i, t, a))
                            }, o[t] = null, s.on("removeListener", this._onRemoveListener)) : (o[t] = a, r._on.call(i, t, a))
                        },
                        unsubscribe: function(t) {
                            var e, n, r, i = this,
                                s = this._listeners,
                                o = this._emitter,
                                a = this._off,
                                c = this._target;
                            if (t && "string" != typeof t) throw TypeError("event must be a string");

                            function l() {
                                i._onNewListener && (o.off("newListener", i._onNewListener), o.off("removeListener", i._onRemoveListener), i._onNewListener = null, i._onRemoveListener = null);
                                var t = S.call(o, i);
                                o._observers.splice(t, 1)
                            }
                            if (t) {
                                if (!(e = s[t])) return;
                                a.call(c, t, e), delete s[t], --this._listenersCount || l()
                            } else {
                                for (r = (n = h(s)).length; r-- > 0;) t = n[r], a.call(c, t, s[t]);
                                this._listeners = {}, this._listenersCount = 0, l()
                            }
                        }
                    });
                    var b = _(["function"]),
                        w = _(["object", "function"]);

                    function M(t, e, n) {
                        var r, i, s, o = 0,
                            a = new t((function(c, l, u) {
                                function h() {
                                    i && (i = null), o && (clearTimeout(o), o = 0)
                                }
                                n = y(n, {
                                    timeout: 0,
                                    overload: !1
                                }, {
                                    timeout: function(t, e) {
                                        return ("number" != typeof(t *= 1) || t < 0 || !Number.isFinite(t)) && e("timeout must be a positive number"), t
                                    }
                                }), r = !n.overload && "function" == typeof t.prototype.cancel && "function" == typeof u;
                                var d = function(t) {
                                        h(), c(t)
                                    },
                                    p = function(t) {
                                        h(), l(t)
                                    };
                                r ? e(d, p, u) : (i = [function(t) {
                                    p(t || Error("canceled"))
                                }], e(d, p, (function(t) {
                                    if (s) throw Error("Unable to subscribe on cancel event asynchronously");
                                    if ("function" != typeof t) throw TypeError("onCancel callback must be a function");
                                    i.push(t)
                                })), s = !0), n.timeout > 0 && (o = setTimeout((function() {
                                    var t = Error("timeout");
                                    t.code = "ETIMEDOUT", o = 0, a.cancel(t), l(t)
                                }), n.timeout))
                            }));
                        return r || (a.cancel = function(t) {
                            if (i) {
                                for (var e = i.length, n = 1; n < e; n++) i[n](t);
                                i[0](t), i = null
                            }
                        }), a
                    }

                    function S(t) {
                        var e = this._observers;
                        if (!e) return -1;
                        for (var n = e.length, r = 0; r < n; r++)
                            if (e[r]._target === t) return r;
                        return -1
                    }

                    function T(t, e, n, r, i) {
                        if (!n) return null;
                        if (0 === r) {
                            var s = typeof e;
                            if ("string" === s) {
                                var o, a, c = 0,
                                    l = 0,
                                    u = this.delimiter,
                                    d = u.length;
                                if (-1 !== (a = e.indexOf(u))) {
                                    o = new Array(5);
                                    do {
                                        o[c++] = e.slice(l, a), l = a + d
                                    } while (-1 !== (a = e.indexOf(u, l)));
                                    o[c++] = e.slice(l), e = o, i = c
                                } else e = [e], i = 1
                            } else "object" === s ? i = e.length : (e = [e], i = 1)
                        }
                        var p, f, m, g, v, y, x, _ = null,
                            b = e[r],
                            w = e[r + 1];
                        if (r === i) n._listeners && ("function" == typeof n._listeners ? (t && t.push(n._listeners), _ = [n]) : (t && t.push.apply(t, n._listeners), _ = [n]));
                        else {
                            if ("*" === b) {
                                for (a = (y = h(n)).length; a-- > 0;) "_listeners" !== (p = y[a]) && ((x = T(t, e, n[p], r + 1, i)) && (_ ? _.push.apply(_, x) : _ = x));
                                return _
                            }
                            if ("**" === b) {
                                for ((v = r + 1 === i || r + 2 === i && "*" === w) && n._listeners && (_ = T(t, e, n, i, i)), a = (y = h(n)).length; a-- > 0;) "_listeners" !== (p = y[a]) && ("*" === p || "**" === p ? (n[p]._listeners && !v && ((x = T(t, e, n[p], i, i)) && (_ ? _.push.apply(_, x) : _ = x)), x = T(t, e, n[p], r, i)) : x = T(t, e, n[p], p === w ? r + 2 : r, i), x && (_ ? _.push.apply(_, x) : _ = x));
                                return _
                            }
                            n[b] && (_ = T(t, e, n[b], r + 1, i))
                        }
                        if ((f = n["*"]) && T(t, e, f, r + 1, i), m = n["**"])
                            if (r < i)
                                for (m._listeners && T(t, e, m, i, i), a = (y = h(m)).length; a-- > 0;) "_listeners" !== (p = y[a]) && (p === w ? T(t, e, m[p], r + 2, i) : p === b ? T(t, e, m[p], r + 1, i) : ((g = {})[p] = m[p], T(t, e, {
                                    "**": g
                                }, r + 1, i)));
                            else m._listeners ? T(t, e, m, i, i) : m["*"] && m["*"]._listeners && T(t, e, m["*"], i, i);
                        return _
                    }

                    function E(t, e, n) {
                        var r, i, s = 0,
                            o = 0,
                            a = this.delimiter,
                            c = a.length;
                        if ("string" == typeof t)
                            if (-1 !== (r = t.indexOf(a))) {
                                i = new Array(5);
                                do {
                                    i[s++] = t.slice(o, r), o = r + c
                                } while (-1 !== (r = t.indexOf(a, o)));
                                i[s++] = t.slice(o)
                            } else i = [t], s = 1;
                        else i = t, s = t.length;
                        if (s > 1)
                            for (r = 0; r + 1 < s; r++)
                                if ("**" === i[r] && "**" === i[r + 1]) return;
                        var l, u = this.listenerTree;
                        for (r = 0; r < s; r++)
                            if (u = u[l = i[r]] || (u[l] = {}), r === s - 1) return u._listeners ? ("function" == typeof u._listeners && (u._listeners = [u._listeners]), n ? u._listeners.unshift(e) : u._listeners.push(e), !u._listeners.warned && this._maxListeners > 0 && u._listeners.length > this._maxListeners && (u._listeners.warned = !0, f.call(this, u._listeners.length, l))) : u._listeners = e, !0;
                        return !0
                    }

                    function A(t, e, n, r) {
                        for (var i, s, o, a, c = h(t), l = c.length, u = t._listeners; l-- > 0;) i = t[s = c[l]], o = "_listeners" === s ? n : n ? n.concat(s) : [s], a = r || "symbol" == typeof s, u && e.push(a ? o : o.join(this.delimiter)), "object" == typeof i && A.call(this, i, e, o, a);
                        return e
                    }

                    function L(t) {
                        for (var e, n, r, i = h(t), s = i.length; s-- > 0;)(e = t[n = i[s]]) && (r = !0, "_listeners" === n || L(e) || delete t[n]);
                        return r
                    }

                    function R(t, e, n) {
                        this.emitter = t, this.event = e, this.listener = n
                    }

                    function P(t, e, n) {
                        if (!0 === n) s = !0;
                        else if (!1 === n) r = !0;
                        else {
                            if (!n || "object" != typeof n) throw TypeError("options should be an object or true");
                            var r = n.async,
                                s = n.promisify,
                                o = n.nextTick,
                                c = n.objectify
                        }
                        if (r || o || s) {
                            var l = e,
                                h = e._origin || e;
                            if (o && !a) throw Error("process.nextTick is not supported");
                            s === i && (s = "AsyncFunction" === e.constructor.name), (e = function() {
                                var t = arguments,
                                    e = this,
                                    n = this.event;
                                return s ? o ? Promise.resolve() : new Promise((function(t) {
                                    u(t)
                                })).then((function() {
                                    return e.event = n, l.apply(e, t)
                                })) : (o ? process.nextTick : u)((function() {
                                    e.event = n, l.apply(e, t)
                                }))
                            })._async = !0, e._origin = h
                        }
                        return [e, c ? new R(this, t, e) : this]
                    }

                    function C(t) {
                        this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, p.call(this, t)
                    }
                    R.prototype.off = function() {
                        return this.emitter.off(this.event, this.listener), this
                    }, C.EventEmitter2 = C, C.prototype.listenTo = function(t, e, n) {
                        if ("object" != typeof t) throw TypeError("target musts be an object");
                        var r = this;

                        function s(e) {
                            if ("object" != typeof e) throw TypeError("events must be an object");
                            var i, s = n.reducers,
                                o = S.call(r, t);
                            i = -1 === o ? new v(r, t, n) : r._observers[o];
                            for (var a, c = h(e), l = c.length, u = "function" == typeof s, d = 0; d < l; d++) a = c[d], i.subscribe(a, e[a] || a, u ? s : s && s[a])
                        }
                        return n = y(n, {
                            on: i,
                            off: i,
                            reducers: i
                        }, {
                            on: b,
                            off: b,
                            reducers: w
                        }), o(e) ? s(g(e)) : s("string" == typeof e ? g(e.split(/\s+/)) : e), this
                    }, C.prototype.stopListeningTo = function(t, e) {
                        var n = this._observers;
                        if (!n) return !1;
                        var r, i = n.length,
                            s = !1;
                        if (t && "object" != typeof t) throw TypeError("target should be an object");
                        for (; i-- > 0;) r = n[i], t && r._target !== t || (r.unsubscribe(e), s = !0);
                        return s
                    }, C.prototype.delimiter = ".", C.prototype.setMaxListeners = function(t) {
                        t !== i && (this._maxListeners = t, this._conf || (this._conf = {}), this._conf.maxListeners = t)
                    }, C.prototype.getMaxListeners = function() {
                        return this._maxListeners
                    }, C.prototype.event = "", C.prototype.once = function(t, e, n) {
                        return this._once(t, e, !1, n)
                    }, C.prototype.prependOnceListener = function(t, e, n) {
                        return this._once(t, e, !0, n)
                    }, C.prototype._once = function(t, e, n, r) {
                        return this._many(t, 1, e, n, r)
                    }, C.prototype.many = function(t, e, n, r) {
                        return this._many(t, e, n, !1, r)
                    }, C.prototype.prependMany = function(t, e, n, r) {
                        return this._many(t, e, n, !0, r)
                    }, C.prototype._many = function(t, e, n, r, i) {
                        var s = this;
                        if ("function" != typeof n) throw new Error("many only accepts instances of Function");

                        function o() {
                            return 0 == --e && s.off(t, o), n.apply(this, arguments)
                        }
                        return o._origin = n, this._on(t, o, r, i)
                    }, C.prototype.emit = function() {
                        if (!this._events && !this._all) return !1;
                        this._events || d.call(this);
                        var t, e, n, r, i, s, o = arguments[0],
                            a = this.wildcard;
                        if ("newListener" === o && !this._newListener && !this._events.newListener) return !1;
                        if (a && (t = o, "newListener" !== o && "removeListener" !== o && "object" == typeof o)) {
                            if (n = o.length, c)
                                for (r = 0; r < n; r++)
                                    if ("symbol" == typeof o[r]) {
                                        s = !0;
                                        break
                                    }
                            s || (o = o.join(this.delimiter))
                        }
                        var l, u = arguments.length;
                        if (this._all && this._all.length)
                            for (r = 0, n = (l = this._all.slice()).length; r < n; r++) switch (this.event = o, u) {
                                case 1:
                                    l[r].call(this, o);
                                    break;
                                case 2:
                                    l[r].call(this, o, arguments[1]);
                                    break;
                                case 3:
                                    l[r].call(this, o, arguments[1], arguments[2]);
                                    break;
                                default:
                                    l[r].apply(this, arguments)
                            }
                        if (a) l = [], T.call(this, l, t, this.listenerTree, 0, n);
                        else {
                            if ("function" == typeof(l = this._events[o])) {
                                switch (this.event = o, u) {
                                    case 1:
                                        l.call(this);
                                        break;
                                    case 2:
                                        l.call(this, arguments[1]);
                                        break;
                                    case 3:
                                        l.call(this, arguments[1], arguments[2]);
                                        break;
                                    default:
                                        for (e = new Array(u - 1), i = 1; i < u; i++) e[i - 1] = arguments[i];
                                        l.apply(this, e)
                                }
                                return !0
                            }
                            l && (l = l.slice())
                        }
                        if (l && l.length) {
                            if (u > 3)
                                for (e = new Array(u - 1), i = 1; i < u; i++) e[i - 1] = arguments[i];
                            for (r = 0, n = l.length; r < n; r++) switch (this.event = o, u) {
                                case 1:
                                    l[r].call(this);
                                    break;
                                case 2:
                                    l[r].call(this, arguments[1]);
                                    break;
                                case 3:
                                    l[r].call(this, arguments[1], arguments[2]);
                                    break;
                                default:
                                    l[r].apply(this, e)
                            }
                            return !0
                        }
                        if (!this.ignoreErrors && !this._all && "error" === o) throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
                        return !!this._all
                    }, C.prototype.emitAsync = function() {
                        if (!this._events && !this._all) return !1;
                        this._events || d.call(this);
                        var t, e, n, r, i, s, o = arguments[0],
                            a = this.wildcard;
                        if ("newListener" === o && !this._newListener && !this._events.newListener) return Promise.resolve([!1]);
                        if (a && (t = o, "newListener" !== o && "removeListener" !== o && "object" == typeof o)) {
                            if (r = o.length, c)
                                for (i = 0; i < r; i++)
                                    if ("symbol" == typeof o[i]) {
                                        e = !0;
                                        break
                                    }
                            e || (o = o.join(this.delimiter))
                        }
                        var l, u = [],
                            h = arguments.length;
                        if (this._all)
                            for (i = 0, r = this._all.length; i < r; i++) switch (this.event = o, h) {
                                case 1:
                                    u.push(this._all[i].call(this, o));
                                    break;
                                case 2:
                                    u.push(this._all[i].call(this, o, arguments[1]));
                                    break;
                                case 3:
                                    u.push(this._all[i].call(this, o, arguments[1], arguments[2]));
                                    break;
                                default:
                                    u.push(this._all[i].apply(this, arguments))
                            }
                        if (a ? (l = [], T.call(this, l, t, this.listenerTree, 0)) : l = this._events[o], "function" == typeof l) switch (this.event = o, h) {
                            case 1:
                                u.push(l.call(this));
                                break;
                            case 2:
                                u.push(l.call(this, arguments[1]));
                                break;
                            case 3:
                                u.push(l.call(this, arguments[1], arguments[2]));
                                break;
                            default:
                                for (n = new Array(h - 1), s = 1; s < h; s++) n[s - 1] = arguments[s];
                                u.push(l.apply(this, n))
                        } else if (l && l.length) {
                            if (l = l.slice(), h > 3)
                                for (n = new Array(h - 1), s = 1; s < h; s++) n[s - 1] = arguments[s];
                            for (i = 0, r = l.length; i < r; i++) switch (this.event = o, h) {
                                case 1:
                                    u.push(l[i].call(this));
                                    break;
                                case 2:
                                    u.push(l[i].call(this, arguments[1]));
                                    break;
                                case 3:
                                    u.push(l[i].call(this, arguments[1], arguments[2]));
                                    break;
                                default:
                                    u.push(l[i].apply(this, n))
                            }
                        } else if (!this.ignoreErrors && !this._all && "error" === o) return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
                        return Promise.all(u)
                    }, C.prototype.on = function(t, e, n) {
                        return this._on(t, e, !1, n)
                    }, C.prototype.prependListener = function(t, e, n) {
                        return this._on(t, e, !0, n)
                    }, C.prototype.onAny = function(t) {
                        return this._onAny(t, !1)
                    }, C.prototype.prependAny = function(t) {
                        return this._onAny(t, !0)
                    }, C.prototype.addListener = C.prototype.on, C.prototype._onAny = function(t, e) {
                        if ("function" != typeof t) throw new Error("onAny only accepts instances of Function");
                        return this._all || (this._all = []), e ? this._all.unshift(t) : this._all.push(t), this
                    }, C.prototype._on = function(t, e, n, r) {
                        if ("function" == typeof t) return this._onAny(t, e), this;
                        if ("function" != typeof e) throw new Error("on only accepts instances of Function");
                        this._events || d.call(this);
                        var s, o = this;
                        return r !== i && (e = (s = P.call(this, t, e, r))[0], o = s[1]), this._newListener && this.emit("newListener", t, e), this.wildcard ? (E.call(this, t, e, n), o) : (this._events[t] ? ("function" == typeof this._events[t] && (this._events[t] = [this._events[t]]), n ? this._events[t].unshift(e) : this._events[t].push(e), !this._events[t].warned && this._maxListeners > 0 && this._events[t].length > this._maxListeners && (this._events[t].warned = !0, f.call(this, this._events[t].length, t))) : this._events[t] = e, o)
                    }, C.prototype.off = function(t, e) {
                        if ("function" != typeof e) throw new Error("removeListener only takes instances of Function");
                        var n, r = [];
                        if (this.wildcard) {
                            var i = "string" == typeof t ? t.split(this.delimiter) : t.slice();
                            if (!(r = T.call(this, null, i, this.listenerTree, 0))) return this
                        } else {
                            if (!this._events[t]) return this;
                            n = this._events[t], r.push({
                                _listeners: n
                            })
                        }
                        for (var s = 0; s < r.length; s++) {
                            var a = r[s];
                            if (n = a._listeners, o(n)) {
                                for (var c = -1, l = 0, u = n.length; l < u; l++)
                                    if (n[l] === e || n[l].listener && n[l].listener === e || n[l]._origin && n[l]._origin === e) {
                                        c = l;
                                        break
                                    }
                                if (c < 0) continue;
                                return this.wildcard ? a._listeners.splice(c, 1) : this._events[t].splice(c, 1), 0 === n.length && (this.wildcard ? delete a._listeners : delete this._events[t]), this._removeListener && this.emit("removeListener", t, e), this
                            }(n === e || n.listener && n.listener === e || n._origin && n._origin === e) && (this.wildcard ? delete a._listeners : delete this._events[t], this._removeListener && this.emit("removeListener", t, e))
                        }
                        return this.listenerTree && L(this.listenerTree), this
                    }, C.prototype.offAny = function(t) {
                        var e, n = 0,
                            r = 0;
                        if (t && this._all && this._all.length > 0) {
                            for (n = 0, r = (e = this._all).length; n < r; n++)
                                if (t === e[n]) return e.splice(n, 1), this._removeListener && this.emit("removeListenerAny", t), this
                        } else {
                            if (e = this._all, this._removeListener)
                                for (n = 0, r = e.length; n < r; n++) this.emit("removeListenerAny", e[n]);
                            this._all = []
                        }
                        return this
                    }, C.prototype.removeListener = C.prototype.off, C.prototype.removeAllListeners = function(t) {
                        if (t === i) return !this._events || d.call(this), this;
                        if (this.wildcard) {
                            var e, n = T.call(this, null, t, this.listenerTree, 0);
                            if (!n) return this;
                            for (e = 0; e < n.length; e++) n[e]._listeners = null;
                            this.listenerTree && L(this.listenerTree)
                        } else this._events && (this._events[t] = null);
                        return this
                    }, C.prototype.listeners = function(t) {
                        var e, n, r, s, o, a = this._events;
                        if (t === i) {
                            if (this.wildcard) throw Error("event name required for wildcard emitter");
                            if (!a) return [];
                            for (s = (e = h(a)).length, r = []; s-- > 0;) "function" == typeof(n = a[e[s]]) ? r.push(n) : r.push.apply(r, n);
                            return r
                        }
                        if (this.wildcard) {
                            if (!(o = this.listenerTree)) return [];
                            var c = [],
                                l = "string" == typeof t ? t.split(this.delimiter) : t.slice();
                            return T.call(this, c, l, o, 0), c
                        }
                        return a ? (n = a[t]) ? "function" == typeof n ? [n] : n : [] : []
                    }, C.prototype.eventNames = function(t) {
                        var e = this._events;
                        return this.wildcard ? A.call(this, this.listenerTree, [], null, t) : e ? h(e) : []
                    }, C.prototype.listenerCount = function(t) {
                        return this.listeners(t).length
                    }, C.prototype.hasListeners = function(t) {
                        if (this.wildcard) {
                            var e = [],
                                n = "string" == typeof t ? t.split(this.delimiter) : t.slice();
                            return T.call(this, e, n, this.listenerTree, 0), e.length > 0
                        }
                        var r = this._events,
                            s = this._all;
                        return !!(s && s.length || r && (t === i ? h(r).length : r[t]))
                    }, C.prototype.listenersAny = function() {
                        return this._all ? this._all : []
                    }, C.prototype.waitFor = function(t, e) {
                        var n = this,
                            r = typeof e;
                        return "number" === r ? e = {
                            timeout: e
                        } : "function" === r && (e = {
                            filter: e
                        }), M((e = y(e, {
                            timeout: 0,
                            filter: i,
                            handleError: !1,
                            Promise: Promise,
                            overload: !1
                        }, {
                            filter: b,
                            Promise: x
                        })).Promise, (function(r, i, s) {
                            function o() {
                                var s = e.filter;
                                if (!s || s.apply(n, arguments))
                                    if (n.off(t, o), e.handleError) {
                                        var a = arguments[0];
                                        a ? i(a) : r(m.apply(null, arguments).slice(1))
                                    } else r(m.apply(null, arguments))
                            }
                            s((function() {
                                n.off(t, o)
                            })), n._on(t, o, !1)
                        }), {
                            timeout: e.timeout,
                            overload: e.overload
                        })
                    };
                    var I = C.prototype;
                    Object.defineProperties(C, {
                        defaultMaxListeners: {get: function() {
                                return I._maxListeners
                            },
                            set: function(t) {
                                if ("number" != typeof t || t < 0 || Number.isNaN(t)) throw TypeError("n must be a non-negative number");
                                I._maxListeners = t
                            },
                            enumerable: !0
                        },
                        once: {
                            value: function(t, e, n) {
                                return M((n = y(n, {
                                    Promise: Promise,
                                    timeout: 0,
                                    overload: !1
                                }, {
                                    Promise: x
                                })).Promise, (function(n, r, i) {
                                    var s;
                                    if ("function" == typeof t.addEventListener) return s = function() {
                                        n(m.apply(null, arguments))
                                    }, i((function() {
                                        t.removeEventListener(e, s)
                                    })), void t.addEventListener(e, s, {
                                        once: !0
                                    });
                                    var o, a = function() {
                                        o && t.removeListener("error", o), n(m.apply(null, arguments))
                                    };
                                    "error" !== e && (o = function(n) {
                                        t.removeListener(e, a), r(n)
                                    }, t.once("error", o)), i((function() {
                                        o && t.removeListener("error", o), t.removeListener(e, a)
                                    })), t.once(e, a)
                                }), {
                                    timeout: n.timeout,
                                    overload: n.overload
                                })
                            },
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperties(I, {
                        _maxListeners: {
                            value: 10,
                            writable: !0,
                            configurable: !0
                        },
                        _observers: {
                            value: null,
                            writable: !0,
                            configurable: !0
                        }
                    }), (r = function() {
                        return C
                    }.call(e, n, e, t)) === i || (t.exports = r)
                }()
            },
            5251: function(t, e, n) {
                "use strict";
                var r = n(7294),
                    i = Symbol.for("react.element"),
                    s = Symbol.for("react.fragment"),
                    o = Object.prototype.hasOwnProperty,
                    a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
                    c = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function l(t, e, n) {
                    var r, s = {},
                        l = null,
                        u = null;
                    for (r in void 0 !== n && (l = "" + n), void 0 !== e.key && (l = "" + e.key), void 0 !== e.ref && (u = e.ref), e) o.call(e, r) && !c.hasOwnProperty(r) && (s[r] = e[r]);
                    if (t && t.defaultProps)
                        for (r in e = t.defaultProps) void 0 === s[r] && (s[r] = e[r]);
                    return {
                        $$typeof: i,
                        type: t,
                        key: l,
                        ref: u,
                        props: s,
                        _owner: a.current
                    }
                }
                e.Fragment = s, e.jsx = l, e.jsxs = l
            },
            2408: function(t, e) {
                "use strict";
                var n = Symbol.for("react.element"),
                    r = Symbol.for("react.portal"),
                    i = Symbol.for("react.fragment"),
                    s = Symbol.for("react.strict_mode"),
                    o = Symbol.for("react.profiler"),
                    a = Symbol.for("react.provider"),
                    c = Symbol.for("react.context"),
                    l = Symbol.for("react.forward_ref"),
                    u = Symbol.for("react.suspense"),
                    h = Symbol.for("react.memo"),
                    d = Symbol.for("react.lazy"),
                    p = Symbol.iterator;
                var f = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    m = Object.assign,
                    g = {};

                function v(t, e, n) {
                    this.props = t, this.context = e, this.refs = g, this.updater = n || f
                }

                function y() {}

                function x(t, e, n) {
                    this.props = t, this.context = e, this.refs = g, this.updater = n || f
                }
                v.prototype.isReactComponent = {}, v.prototype.setState = function(t, e) {
                    if ("object" != typeof t && "function" != typeof t && null != t) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    this.updater.enqueueSetState(this, t, e, "setState")
                }, v.prototype.forceUpdate = function(t) {
                    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
                }, y.prototype = v.prototype;
                var _ = x.prototype = new y;
                _.constructor = x, m(_, v.prototype), _.isPureReactComponent = !0;
                var b = Array.isArray,
                    w = Object.prototype.hasOwnProperty,
                    M = {
                        current: null
                    },
                    S = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function T(t, e, r) {
                    var i, s = {},
                        o = null,
                        a = null;
                    if (null != e)
                        for (i in void 0 !== e.ref && (a = e.ref), void 0 !== e.key && (o = "" + e.key), e) w.call(e, i) && !S.hasOwnProperty(i) && (s[i] = e[i]);
                    var c = arguments.length - 2;
                    if (1 === c) s.children = r;
                    else if (1 < c) {
                        for (var l = Array(c), u = 0; u < c; u++) l[u] = arguments[u + 2];
                        s.children = l
                    }
                    if (t && t.defaultProps)
                        for (i in c = t.defaultProps) void 0 === s[i] && (s[i] = c[i]);
                    return {
                        $$typeof: n,
                        type: t,
                        key: o,
                        ref: a,
                        props: s,
                        _owner: M.current
                    }
                }

                function E(t) {
                    return "object" == typeof t && null !== t && t.$$typeof === n
                }
                var A = /\/+/g;

                function L(t, e) {
                    return "object" == typeof t && null !== t && null != t.key ? function(t) {
                        var e = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + t.replace(/[=:]/g, (function(t) {
                            return e[t]
                        }))
                    }("" + t.key) : e.toString(36)
                }

                function R(t, e, i, s, o) {
                    var a = typeof t;
                    "undefined" !== a && "boolean" !== a || (t = null);
                    var c = !1;
                    if (null === t) c = !0;
                    else switch (a) {
                        case "string":
                        case "number":
                            c = !0;
                            break;
                        case "object":
                            switch (t.$$typeof) {
                                case n:
                                case r:
                                    c = !0
                            }
                    }
                    if (c) return o = o(c = t), t = "" === s ? "." + L(c, 0) : s, b(o) ? (i = "", null != t && (i = t.replace(A, "$&/") + "/"), R(o, e, i, "", (function(t) {
                        return t
                    }))) : null != o && (E(o) && (o = function(t, e) {
                        return {
                            $$typeof: n,
                            type: t.type,
                            key: e,
                            ref: t.ref,
                            props: t.props,
                            _owner: t._owner
                        }
                    }(o, i + (!o.key || c && c.key === o.key ? "" : ("" + o.key).replace(A, "$&/") + "/") + t)), e.push(o)), 1;
                    if (c = 0, s = "" === s ? "." : s + ":", b(t))
                        for (var l = 0; l < t.length; l++) {
                            var u = s + L(a = t[l], l);
                            c += R(a, e, i, u, o)
                        } else if ("function" == typeof(u = function(t) {
                                return null === t || "object" != typeof t ? null : "function" == typeof(t = p && t[p] || t["@@iterator"]) ? t : null
                            }(t)))
                            for (t = u.call(t), l = 0; !(a = t.next()).done;) c += R(a = a.value, e, i, u = s + L(a, l++), o);
                        else if ("object" === a) throw e = String(t), Error("Objects are not valid as a React child (found: " + ("[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
                    return c
                }

                function P(t, e, n) {
                    if (null == t) return t;
                    var r = [],
                        i = 0;
                    return R(t, r, "", "", (function(t) {
                        return e.call(n, t, i++)
                    })), r
                }

                function C(t) {
                    if (-1 === t._status) {
                        var e = t._result;
                        (e = e()).then((function(e) {
                            0 !== t._status && -1 !== t._status || (t._status = 1, t._result = e)
                        }), (function(e) {
                            0 !== t._status && -1 !== t._status || (t._status = 2, t._result = e)
                        })), -1 === t._status && (t._status = 0, t._result = e)
                    }
                    if (1 === t._status) return t._result.default;
                    throw t._result
                }
                var I = {
                        current: null
                    },
                    D = {
                        transition: null
                    },
                    O = {
                        ReactCurrentDispatcher: I,
                        ReactCurrentBatchConfig: D,
                        ReactCurrentOwner: M
                    };
                e.Children = {
                    map: P,
                    forEach: function(t, e, n) {
                        P(t, (function() {
                            e.apply(this, arguments)
                        }), n)
                    },
                    count: function(t) {
                        var e = 0;
                        return P(t, (function() {
                            e++
                        })), e
                    },
                    toArray: function(t) {
                        return P(t, (function(t) {
                            return t
                        })) || []
                    },
                    only: function(t) {
                        if (!E(t)) throw Error("React.Children.only expected to receive a single React element child.");
                        return t
                    }
                }, e.Component = v, e.Fragment = i, e.Profiler = o, e.PureComponent = x, e.StrictMode = s, e.Suspense = u, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = O, e.cloneElement = function(t, e, r) {
                    if (null == t) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
                    var i = m({}, t.props),
                        s = t.key,
                        o = t.ref,
                        a = t._owner;
                    if (null != e) {
                        if (void 0 !== e.ref && (o = e.ref, a = M.current), void 0 !== e.key && (s = "" + e.key), t.type && t.type.defaultProps) var c = t.type.defaultProps;
                        for (l in e) w.call(e, l) && !S.hasOwnProperty(l) && (i[l] = void 0 === e[l] && void 0 !== c ? c[l] : e[l])
                    }
                    var l = arguments.length - 2;
                    if (1 === l) i.children = r;
                    else if (1 < l) {
                        c = Array(l);
                        for (var u = 0; u < l; u++) c[u] = arguments[u + 2];
                        i.children = c
                    }
                    return {
                        $$typeof: n,
                        type: t.type,
                        key: s,
                        ref: o,
                        props: i,
                        _owner: a
                    }
                }, e.createContext = function(t) {
                    return (t = {
                        $$typeof: c,
                        _currentValue: t,
                        _currentValue2: t,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null,
                        _defaultValue: null,
                        _globalName: null
                    }).Provider = {
                        $$typeof: a,
                        _context: t
                    }, t.Consumer = t
                }, e.createElement = T, e.createFactory = function(t) {
                    var e = T.bind(null, t);
                    return e.type = t, e
                }, e.createRef = function() {
                    return {
                        current: null
                    }
                }, e.forwardRef = function(t) {
                    return {
                        $$typeof: l,
                        render: t
                    }
                }, e.isValidElement = E, e.lazy = function(t) {
                    return {
                        $$typeof: d,
                        _payload: {
                            _status: -1,
                            _result: t
                        },
                        _init: C
                    }
                }, e.memo = function(t, e) {
                    return {
                        $$typeof: h,
                        type: t,
                        compare: void 0 === e ? null : e
                    }
                }, e.startTransition = function(t) {
                    var e = D.transition;
                    D.transition = {};
                    try {
                        t()
                    } finally {
                        D.transition = e
                    }
                }, e.unstable_act = function() {
                    throw Error("act(...) is not supported in production builds of React.")
                }, e.useCallback = function(t, e) {
                    return I.current.useCallback(t, e)
                }, e.useContext = function(t) {
                    return I.current.useContext(t)
                }, e.useDebugValue = function() {}, e.useDeferredValue = function(t) {
                    return I.current.useDeferredValue(t)
                }, e.useEffect = function(t, e) {
                    return I.current.useEffect(t, e)
                }, e.useId = function() {
                    return I.current.useId()
                }, e.useImperativeHandle = function(t, e, n) {
                    return I.current.useImperativeHandle(t, e, n)
                }, e.useInsertionEffect = function(t, e) {
                    return I.current.useInsertionEffect(t, e)
                }, e.useLayoutEffect = function(t, e) {
                    return I.current.useLayoutEffect(t, e)
                }, e.useMemo = function(t, e) {
                    return I.current.useMemo(t, e)
                }, e.useReducer = function(t, e, n) {
                    return I.current.useReducer(t, e, n)
                }, e.useRef = function(t) {
                    return I.current.useRef(t)
                }, e.useState = function(t) {
                    return I.current.useState(t)
                }, e.useSyncExternalStore = function(t, e, n) {
                    return I.current.useSyncExternalStore(t, e, n)
                }, e.useTransition = function() {
                    return I.current.useTransition()
                }, e.version = "18.2.0"
            },
            7294: function(t, e, n) {
                "use strict";
                t.exports = n(2408)
            },
            5893: function(t, e, n) {
                "use strict";
                t.exports = n(5251)
            },
            1646: function(t, e, n) {
                "use strict";
                let r, i, s, o, a, c, l, u, h, d, p, f, m;
                n.d(e, {
                    $V: function() {
                        return Zc
                    },
                    CtF: function() {
                        return Ja
                    },
                    D1R: function() {
                        return C
                    },
                    EJi: function() {
                        return Oa
                    },
                    F5T: function() {
                        return He
                    },
                    FM8: function() {
                        return pt
                    },
                    GQ: function() {
                        return el
                    },
                    HxU: function() {
                        return a
                    },
                    IOt: function() {
                        return J
                    },
                    Ilk: function() {
                        return Xe
                    },
                    Kj0: function() {
                        return Ln
                    },
                    M15: function() {
                        return p
                    },
                    M8C: function() {
                        return dt
                    },
                    N$j: function() {
                        return so
                    },
                    NMF: function() {
                        return V
                    },
                    OdW: function() {
                        return lo
                    },
                    OoA: function() {
                        return T
                    },
                    Ox3: function() {
                        return yc
                    },
                    PMe: function() {
                        return hc
                    },
                    Pa4: function() {
                        return Et
                    },
                    QRU: function() {
                        return wc
                    },
                    QmN: function() {
                        return x
                    },
                    RsA: function() {
                        return y
                    },
                    SUY: function() {
                        return Ec
                    },
                    Syv: function() {
                        return G
                    },
                    TUv: function() {
                        return io
                    },
                    TlE: function() {
                        return Qe
                    },
                    Tme: function() {
                        return Le
                    },
                    TyD: function() {
                        return E
                    },
                    UCm: function() {
                        return B
                    },
                    UY4: function() {
                        return Ao
                    },
                    UlW: function() {
                        return Z
                    },
                    VLJ: function() {
                        return tl
                    },
                    Wid: function() {
                        return Da
                    },
                    Wl3: function() {
                        return _
                    },
                    Xcj: function() {
                        return Hc
                    },
                    YKA: function() {
                        return H
                    },
                    YLQ: function() {
                        return A
                    },
                    ZAu: function() {
                        return Ts
                    },
                    Zp0: function() {
                        return bc
                    },
                    ZzF: function() {
                        return Rt
                    },
                    _C8: function() {
                        return Ba
                    },
                    _fP: function() {
                        return Tt
                    },
                    aH4: function() {
                        return L
                    },
                    aLr: function() {
                        return Xt
                    },
                    aNw: function() {
                        return Qa
                    },
                    b5g: function() {
                        return Cs
                    },
                    blk: function() {
                        return Eo
                    },
                    cPb: function() {
                        return Bn
                    },
                    cek: function() {
                        return gc
                    },
                    dUE: function() {
                        return Va
                    },
                    dpR: function() {
                        return rc
                    },
                    ehD: function() {
                        return b
                    },
                    ejS: function() {
                        return To
                    },
                    hH6: function() {
                        return tc
                    },
                    iI$: function() {
                        return m
                    },
                    iKG: function() {
                        return sr
                    },
                    iLg: function() {
                        return ja
                    },
                    iMs: function() {
                        return Vc
                    },
                    iUV: function() {
                        return kc
                    },
                    iw8: function() {
                        return v
                    },
                    jAl: function() {
                        return U
                    },
                    kB5: function() {
                        return zs
                    },
                    knz: function() {
                        return Y
                    },
                    lfu: function() {
                        return Fa
                    },
                    lh0: function() {
                        return r
                    },
                    m7l: function() {
                        return Xa
                    },
                    nls: function() {
                        return go
                    },
                    pBf: function() {
                        return $
                    },
                    qyh: function() {
                        return P
                    },
                    rpg: function() {
                        return M
                    },
                    u9r: function() {
                        return un
                    },
                    uWy: function() {
                        return S
                    },
                    v1Y: function() {
                        return f
                    },
                    vBJ: function() {
                        return Ye
                    },
                    vmT: function() {
                        return sc
                    },
                    vpT: function() {
                        return Ns
                    },
                    wem: function() {
                        return R
                    },
                    woe: function() {
                        return Io
                    },
                    x12: function() {
                        return wo
                    },
                    xEZ: function() {
                        return _t
                    },
                    xsS: function() {
                        return Os
                    },
                    yC1: function() {
                        return qa
                    },
                    yFI: function() {
                        return s
                    },
                    yGw: function() {
                        return re
                    },
                    yo9: function() {
                        return Is
                    },
                    z$h: function() {
                        return q
                    }
                });
                let g = {};
                const v = new class {
                        set(t) {
                            this.platform = t;
                            const e = t.getGlobals();
                            i = e.atob, s = e.Blob, o = e.window, a = e.document, u = e.XMLHttpRequest, h = e.OffscreenCanvas, d = e.HTMLCanvasElement, p = e.createImageBitmap, r = o.URL, c = o.DOMParser, l = o.TextDecoder, f = o.requestAnimationFrame, m = o.cancelAnimationFrame, t.setWebGLExtensions && (g = t.setWebGLExtensions())
                        }
                        dispose() {
                            this.platform && this.platform.dispose(), this.platform = null, r = null, s = null, i = null, o = null, a = null, c = null, l = null, u = null, h = null, d = null, p = null, f = null, g = null
                        }
                    },
                    y = {
                        LEFT: 0,
                        MIDDLE: 1,
                        RIGHT: 2,
                        ROTATE: 0,
                        DOLLY: 1,
                        PAN: 2
                    },
                    x = {
                        ROTATE: 0,
                        PAN: 1,
                        DOLLY_PAN: 2,
                        DOLLY_ROTATE: 3
                    },
                    _ = 0,
                    b = 2,
                    w = 100,
                    M = 1e3,
                    S = 1001,
                    T = 1002,
                    E = 1003,
                    A = 1004,
                    L = 1005,
                    R = 1006,
                    P = 1007,
                    C = 1008,
                    I = 1009,
                    D = 1015,
                    O = 1016,
                    N = 1020,
                    B = 1022,
                    z = 1023,
                    F = 1026,
                    k = 1027,
                    U = 2200,
                    H = 2201,
                    G = 2300,
                    V = 2301,
                    W = 2400,
                    j = 2401,
                    Z = 1,
                    q = 2,
                    X = 3e3,
                    Y = 3001,
                    J = 0,
                    K = 35044,
                    Q = 35048;
                class $ {
                    addEventListener(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        const n = this._listeners;
                        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                    }
                    hasEventListener(t, e) {
                        if (void 0 === this._listeners) return !1;
                        const n = this._listeners;
                        return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                    }
                    removeEventListener(t, e) {
                        if (void 0 === this._listeners) return;
                        const n = this._listeners[t];
                        if (void 0 !== n) {
                            const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                        }
                    }
                    dispatchEvent(t) {
                        if (void 0 === this._listeners) return;
                        const e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            const n = e.slice(0);
                            for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
                            t.target = null
                        }
                    }
                }
                let tt = 1234567;
                const et = Math.PI / 180,
                    nt = 180 / Math.PI,
                    rt = [];
                for (let t = 0; t < 256; t++) rt[t] = (t < 16 ? "0" : "") + t.toString(16);
                const it = "undefined" != typeof crypto && "randomUUID" in crypto;

                function st() {
                    if (it) return crypto.randomUUID().toUpperCase();
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        r = 4294967295 * Math.random() | 0;
                    return (rt[255 & t] + rt[t >> 8 & 255] + rt[t >> 16 & 255] + rt[t >> 24 & 255] + "-" + rt[255 & e] + rt[e >> 8 & 255] + "-" + rt[e >> 16 & 15 | 64] + rt[e >> 24 & 255] + "-" + rt[63 & n | 128] + rt[n >> 8 & 255] + "-" + rt[n >> 16 & 255] + rt[n >> 24 & 255] + rt[255 & r] + rt[r >> 8 & 255] + rt[r >> 16 & 255] + rt[r >> 24 & 255]).toUpperCase()
                }

                function ot(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                }

                function at(t, e) {
                    return (t % e + e) % e
                }

                function ct(t, e, n) {
                    return (1 - n) * t + n * e
                }

                function lt(t) {
                    return 0 == (t & t - 1) && 0 !== t
                }

                function ut(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                }

                function ht(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
                var dt = Object.freeze({
                    __proto__: null,
                    DEG2RAD: et,
                    RAD2DEG: nt,
                    generateUUID: st,
                    clamp: ot,
                    euclideanModulo: at,
                    mapLinear: function(t, e, n, r, i) {
                        return r + (t - e) * (i - r) / (n - e)
                    },
                    inverseLerp: function(t, e, n) {
                        return t !== e ? (n - t) / (e - t) : 0
                    },
                    lerp: ct,
                    damp: function(t, e, n, r) {
                        return ct(t, e, 1 - Math.exp(-n * r))
                    },
                    pingpong: function(t, e = 1) {
                        return e - Math.abs(at(t, 2 * e) - e)
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    seededRandom: function(t) {
                        return void 0 !== t && (tt = t % 2147483647), tt = 16807 * tt % 2147483647, (tt - 1) / 2147483646
                    },
                    degToRad: function(t) {
                        return t * et
                    },
                    radToDeg: function(t) {
                        return t * nt
                    },
                    isPowerOfTwo: lt,
                    ceilPowerOfTwo: ut,
                    floorPowerOfTwo: ht,
                    setQuaternionFromProperEuler: function(t, e, n, r, i) {
                        const s = Math.cos,
                            o = Math.sin,
                            a = s(n / 2),
                            c = o(n / 2),
                            l = s((e + r) / 2),
                            u = o((e + r) / 2),
                            h = s((e - r) / 2),
                            d = o((e - r) / 2),
                            p = s((r - e) / 2),
                            f = o((r - e) / 2);
                        switch (i) {
                            case "XYX":
                                t.set(a * u, c * h, c * d, a * l);
                                break;
                            case "YZY":
                                t.set(c * d, a * u, c * h, a * l);
                                break;
                            case "ZXZ":
                                t.set(c * h, c * d, a * u, a * l);
                                break;
                            case "XZX":
                                t.set(a * u, c * f, c * p, a * l);
                                break;
                            case "YXY":
                                t.set(c * p, a * u, c * f, a * l);
                                break;
                            case "ZYZ":
                                t.set(c * f, c * p, a * u, a * l);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                        }
                    }
                });
                class pt {
                    constructor(t = 0, e = 0) {
                        this.x = t, this.y = e
                    }
                    get width() {
                        return this.x
                    }
                    set width(t) {
                        this.x = t
                    }
                    get height() {
                        return this.y
                    }
                    set height(t) {
                        this.y = t
                    }
                    set(t, e) {
                        return this.x = t, this.y = e, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this
                    }
                    add(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this
                    }
                    sub(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this
                    }
                    divide(t) {
                        return this.x /= t.x, this.y /= t.y, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            r = t.elements;
                        return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y
                    }
                    cross(t) {
                        return this.x * t.y - this.y * t.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        return Math.atan2(-this.y, -this.x) + Math.PI
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y;
                        return e * e + n * n
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y
                    }
                    fromArray(t, e = 0) {
                        return this.x = t[e], this.y = t[e + 1], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.x, t[e + 1] = this.y, t
                    }
                    fromBufferAttribute(t, e, n) {
                        return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                    }
                    rotateAround(t, e) {
                        const n = Math.cos(e),
                            r = Math.sin(e),
                            i = this.x - t.x,
                            s = this.y - t.y;
                        return this.x = i * n - s * r + t.x, this.y = i * r + s * n + t.y, this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this
                    } * [Symbol.iterator]() {
                        yield this.x,
                            yield this.y
                    }
                }
                pt.prototype.isVector2 = !0;
                class ft {
                    constructor() {
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                    }
                    set(t, e, n, r, i, s, o, a, c) {
                        const l = this.elements;
                        return l[0] = t, l[1] = r, l[2] = o, l[3] = e, l[4] = i, l[5] = a, l[6] = n, l[7] = s, l[8] = c, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                    }
                    extractBasis(t, e, n) {
                        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                    }
                    setFromMatrix4(t) {
                        const e = t.elements;
                        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                    }
                    multiply(t) {
                        return this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            r = e.elements,
                            i = this.elements,
                            s = n[0],
                            o = n[3],
                            a = n[6],
                            c = n[1],
                            l = n[4],
                            u = n[7],
                            h = n[2],
                            d = n[5],
                            p = n[8],
                            f = r[0],
                            m = r[3],
                            g = r[6],
                            v = r[1],
                            y = r[4],
                            x = r[7],
                            _ = r[2],
                            b = r[5],
                            w = r[8];
                        return i[0] = s * f + o * v + a * _, i[3] = s * m + o * y + a * b, i[6] = s * g + o * x + a * w, i[1] = c * f + l * v + u * _, i[4] = c * m + l * y + u * b, i[7] = c * g + l * x + u * w, i[2] = h * f + d * v + p * _, i[5] = h * m + d * y + p * b, i[8] = h * g + d * x + p * w, this
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            r = t[2],
                            i = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            c = t[7],
                            l = t[8];
                        return e * s * l - e * o * c - n * i * l + n * o * a + r * i * c - r * s * a
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            r = t[2],
                            i = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            c = t[7],
                            l = t[8],
                            u = l * s - o * c,
                            h = o * a - l * i,
                            d = c * i - s * a,
                            p = e * u + n * h + r * d;
                        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const f = 1 / p;
                        return t[0] = u * f, t[1] = (r * c - l * n) * f, t[2] = (o * n - r * s) * f, t[3] = h * f, t[4] = (l * e - r * a) * f, t[5] = (r * i - o * e) * f, t[6] = d * f, t[7] = (n * a - c * e) * f, t[8] = (s * e - n * i) * f, this
                    }
                    transpose() {
                        let t;
                        const e = this.elements;
                        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                    }
                    getNormalMatrix(t) {
                        return this.setFromMatrix4(t).invert().transpose()
                    }
                    transposeIntoArray(t) {
                        const e = this.elements;
                        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                    }
                    setUvTransform(t, e, n, r, i, s, o) {
                        const a = Math.cos(i),
                            c = Math.sin(i);
                        return this.set(n * a, n * c, -n * (a * s + c * o) + s + t, -r * c, r * a, -r * (-c * s + a * o) + o + e, 0, 0, 1), this
                    }
                    scale(t, e) {
                        const n = this.elements;
                        return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                    }
                    rotate(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t),
                            r = this.elements,
                            i = r[0],
                            s = r[3],
                            o = r[6],
                            a = r[1],
                            c = r[4],
                            l = r[7];
                        return r[0] = e * i + n * a, r[3] = e * s + n * c, r[6] = e * o + n * l, r[1] = -n * i + e * a, r[4] = -n * s + e * c, r[7] = -n * o + e * l, this
                    }
                    translate(t, e) {
                        const n = this.elements;
                        return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 9; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                        return this
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                    }
                    clone() {
                        return (new this.constructor).fromArray(this.elements)
                    }
                }

                function mt(t) {
                    if (0 === t.length) return -1 / 0;
                    let e = t[0];
                    for (let n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
                    return e
                }

                function gt(t) {
                    return a.createElementNS("http://www.w3.org/1999/xhtml", t)
                }
                let vt;
                ft.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
                class yt {
                    static getDataURL(t) {
                        if (/^data:/i.test(t.src)) return t.src;
                        if (void 0 === d) return t.src;
                        let e;
                        if (t instanceof d) e = t;
                        else {
                            void 0 === vt && (vt = gt("canvas")), vt.width = t.width, vt.height = t.height;
                            const n = vt.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = vt
                        }
                        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
                    }
                }
                let xt = 0;
                class _t extends $ {
                    constructor(t = _t.DEFAULT_IMAGE, e = _t.DEFAULT_MAPPING, n = S, r = S, i = R, s = C, o = z, a = I, c = 1, l = X) {
                        super(), Object.defineProperty(this, "id", {
                            value: xt++
                        }), this.uuid = st(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = a, this.offset = new pt(0, 0), this.repeat = new pt(1, 1), this.center = new pt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ft, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = l, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        if (void 0 !== this.image) {
                            const r = this.image;
                            if (void 0 === r.uuid && (r.uuid = st()), !e && void 0 === t.images[r.uuid]) {
                                let e;
                                if (Array.isArray(r)) {
                                    e = [];
                                    for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(bt(r[t].image)) : e.push(bt(r[t]))
                                } else e = bt(r);
                                t.images[r.uuid] = {
                                    uuid: r.uuid,
                                    url: e
                                }
                            }
                            n.image = r.uuid
                        }
                        return e || (t.textures[this.uuid] = n), n
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    transformUv(t) {
                        if (300 !== this.mapping) return t;
                        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                            case M:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case S:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case T:
                                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                        }
                        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                            case M:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case S:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case T:
                                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                        }
                        return this.flipY && (t.y = 1 - t.y), t
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                }

                function bt(t) {
                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || void 0 !== d && t instanceof d || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? yt.getDataURL(t) : t.data ? {
                        data: Array.prototype.slice.call(t.data),
                        width: t.width,
                        height: t.height,
                        type: t.data.constructor.name
                    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
                }
                _t.DEFAULT_IMAGE = void 0, _t.DEFAULT_MAPPING = 300, _t.prototype.isTexture = !0;
                class wt {
                    constructor(t = 0, e = 0, n = 0, r = 1) {
                        this.x = t, this.y = e, this.z = n, this.w = r
                    }
                    get width() {
                        return this.z
                    }
                    set width(t) {
                        this.z = t
                    }
                    get height() {
                        return this.w
                    }
                    set height(t) {
                        this.w = t
                    }
                    set(t, e, n, r) {
                        return this.x = t, this.y = e, this.z = n, this.w = r, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this.z = t, this.w = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setZ(t) {
                        return this.z = t, this
                    }
                    setW(t) {
                        return this.w = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            case 3:
                                this.w = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                    }
                    add(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this.z += t, this.w += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                    }
                    sub(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                    }
                    multiply(t) {
                        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = this.w,
                            s = t.elements;
                        return this.x = s[0] * e + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * e + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * e + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * e + s[7] * n + s[11] * r + s[15] * i, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    setAxisAngleFromQuaternion(t) {
                        this.w = 2 * Math.acos(t.w);
                        const e = Math.sqrt(1 - t.w * t.w);
                        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                    }
                    setAxisAngleFromRotationMatrix(t) {
                        let e, n, r, i;
                        const s = .01,
                            o = .1,
                            a = t.elements,
                            c = a[0],
                            l = a[4],
                            u = a[8],
                            h = a[1],
                            d = a[5],
                            p = a[9],
                            f = a[2],
                            m = a[6],
                            g = a[10];
                        if (Math.abs(l - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
                            if (Math.abs(l + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(c + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                            e = Math.PI;
                            const t = (c + 1) / 2,
                                a = (d + 1) / 2,
                                v = (g + 1) / 2,
                                y = (l + h) / 4,
                                x = (u + f) / 4,
                                _ = (p + m) / 4;
                            return t > a && t > v ? t < s ? (n = 0, r = .707106781, i = .707106781) : (n = Math.sqrt(t), r = y / n, i = x / n) : a > v ? a < s ? (n = .707106781, r = 0, i = .707106781) : (r = Math.sqrt(a), n = y / r, i = _ / r) : v < s ? (n = .707106781, r = .707106781, i = 0) : (i = Math.sqrt(v), n = x / i, r = _ / i), this.set(n, r, i, e), this
                        }
                        let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));
                        return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - l) / v, this.w = Math.acos((c + d + g - 1) / 2), this
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    }
                    fromArray(t, e = 0) {
                        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                    }
                    fromBufferAttribute(t, e, n) {
                        return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                    } * [Symbol.iterator]() {
                        yield this.x,
                            yield this.y,
                            yield this.z,
                            yield this.w
                    }
                }
                wt.prototype.isVector4 = !0;
                class Mt extends $ {
                    constructor(t, e, n = {}) {
                        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new wt(0, 0, t, e), this.scissorTest = !1, this.viewport = new wt(0, 0, t, e), this.texture = new _t(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
                            width: t,
                            height: e,
                            depth: 1
                        }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : R, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                    }
                    setTexture(t) {
                        t.image = {
                            width: this.width,
                            height: this.height,
                            depth: this.depth
                        }, this.texture = t
                    }
                    setSize(t, e, n = 1) {
                        this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = {...this.texture.image
                        }, this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                Mt.prototype.isWebGLRenderTarget = !0;
                (class extends Mt {
                    constructor(t, e, n) {
                        super(t, e);
                        const r = this.texture;
                        this.texture = [];
                        for (let t = 0; t < n; t++) this.texture[t] = r.clone()
                    }
                    setSize(t, e, n = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== n) {
                            this.width = t, this.height = e, this.depth = n;
                            for (let r = 0, i = this.texture.length; r < i; r++) this.texture[r].image.width = t, this.texture[r].image.height = e, this.texture[r].image.depth = n;
                            this.dispose()
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                    }
                    copy(t) {
                        this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
                        for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
                        return this
                    }
                }).prototype.isWebGLMultipleRenderTargets = !0;
                class St extends Mt {
                    constructor(t, e, n) {
                        super(t, e, n), this.samples = 4
                    }
                    copy(t) {
                        return super.copy.call(this, t), this.samples = t.samples, this
                    }
                }
                St.prototype.isWebGLMultisampleRenderTarget = !0;
                class Tt {
                    constructor(t = 0, e = 0, n = 0, r = 1) {
                        this._x = t, this._y = e, this._z = n, this._w = r
                    }
                    static slerp(t, e, n, r) {
                        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r)
                    }
                    static slerpFlat(t, e, n, r, i, s, o) {
                        let a = n[r + 0],
                            c = n[r + 1],
                            l = n[r + 2],
                            u = n[r + 3];
                        const h = i[s + 0],
                            d = i[s + 1],
                            p = i[s + 2],
                            f = i[s + 3];
                        if (0 === o) return t[e + 0] = a, t[e + 1] = c, t[e + 2] = l, void(t[e + 3] = u);
                        if (1 === o) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
                        if (u !== f || a !== h || c !== d || l !== p) {
                            let t = 1 - o;
                            const e = a * h + c * d + l * p + u * f,
                                n = e >= 0 ? 1 : -1,
                                r = 1 - e * e;
                            if (r > Number.EPSILON) {
                                const i = Math.sqrt(r),
                                    s = Math.atan2(i, e * n);
                                t = Math.sin(t * s) / i, o = Math.sin(o * s) / i
                            }
                            const i = o * n;
                            if (a = a * t + h * i, c = c * t + d * i, l = l * t + p * i, u = u * t + f * i, t === 1 - o) {
                                const t = 1 / Math.sqrt(a * a + c * c + l * l + u * u);
                                a *= t, c *= t, l *= t, u *= t
                            }
                        }
                        t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
                    }
                    static multiplyQuaternionsFlat(t, e, n, r, i, s) {
                        const o = n[r],
                            a = n[r + 1],
                            c = n[r + 2],
                            l = n[r + 3],
                            u = i[s],
                            h = i[s + 1],
                            d = i[s + 2],
                            p = i[s + 3];
                        return t[e] = o * p + l * u + a * d - c * h, t[e + 1] = a * p + l * h + c * u - o * d, t[e + 2] = c * p + l * d + o * h - a * u, t[e + 3] = l * p - o * u - a * h - c * d, t
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t, this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(t) {
                        this._w = t, this._onChangeCallback()
                    }
                    set(t, e, n, r) {
                        return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    }
                    copy(t) {
                        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                    }
                    setFromEuler(t, e) {
                        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                        const n = t._x,
                            r = t._y,
                            i = t._z,
                            s = t._order,
                            o = Math.cos,
                            a = Math.sin,
                            c = o(n / 2),
                            l = o(r / 2),
                            u = o(i / 2),
                            h = a(n / 2),
                            d = a(r / 2),
                            p = a(i / 2);
                        switch (s) {
                            case "XYZ":
                                this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;
                                break;
                            case "YXZ":
                                this._x = h * l * u + c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;
                                break;
                            case "ZXY":
                                this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u - h * d * p;
                                break;
                            case "ZYX":
                                this._x = h * l * u - c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u + h * d * p;
                                break;
                            case "YZX":
                                this._x = h * l * u + c * d * p, this._y = c * d * u + h * l * p, this._z = c * l * p - h * d * u, this._w = c * l * u - h * d * p;
                                break;
                            case "XZY":
                                this._x = h * l * u - c * d * p, this._y = c * d * u - h * l * p, this._z = c * l * p + h * d * u, this._w = c * l * u + h * d * p;
                                break;
                            default:
                                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                        }
                        return !1 !== e && this._onChangeCallback(), this
                    }
                    setFromAxisAngle(t, e) {
                        const n = e / 2,
                            r = Math.sin(n);
                        return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t) {
                        const e = t.elements,
                            n = e[0],
                            r = e[4],
                            i = e[8],
                            s = e[1],
                            o = e[5],
                            a = e[9],
                            c = e[2],
                            l = e[6],
                            u = e[10],
                            h = n + o + u;
                        if (h > 0) {
                            const t = .5 / Math.sqrt(h + 1);
                            this._w = .25 / t, this._x = (l - a) * t, this._y = (i - c) * t, this._z = (s - r) * t
                        } else if (n > o && n > u) {
                            const t = 2 * Math.sqrt(1 + n - o - u);
                            this._w = (l - a) / t, this._x = .25 * t, this._y = (r + s) / t, this._z = (i + c) / t
                        } else if (o > u) {
                            const t = 2 * Math.sqrt(1 + o - n - u);
                            this._w = (i - c) / t, this._x = (r + s) / t, this._y = .25 * t, this._z = (a + l) / t
                        } else {
                            const t = 2 * Math.sqrt(1 + u - n - o);
                            this._w = (s - r) / t, this._x = (i + c) / t, this._y = (a + l) / t, this._z = .25 * t
                        }
                        return this._onChangeCallback(), this
                    }
                    setFromUnitVectors(t, e) {
                        let n = t.dot(e) + 1;
                        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                    }
                    angleTo(t) {
                        return 2 * Math.acos(Math.abs(ot(this.dot(t), -1, 1)))
                    }
                    rotateTowards(t, e) {
                        const n = this.angleTo(t);
                        if (0 === n) return this;
                        const r = Math.min(1, e / n);
                        return this.slerp(t, r), this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                    }
                    dot(t) {
                        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let t = this.length();
                        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                    }
                    multiply(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyQuaternions(t, this)
                    }
                    multiplyQuaternions(t, e) {
                        const n = t._x,
                            r = t._y,
                            i = t._z,
                            s = t._w,
                            o = e._x,
                            a = e._y,
                            c = e._z,
                            l = e._w;
                        return this._x = n * l + s * o + r * c - i * a, this._y = r * l + s * a + i * o - n * c, this._z = i * l + s * c + n * a - r * o, this._w = s * l - n * o - r * a - i * c, this._onChangeCallback(), this
                    }
                    slerp(t, e) {
                        if (0 === e) return this;
                        if (1 === e) return this.copy(t);
                        const n = this._x,
                            r = this._y,
                            i = this._z,
                            s = this._w;
                        let o = s * t._w + n * t._x + r * t._y + i * t._z;
                        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this;
                        const a = 1 - o * o;
                        if (a <= Number.EPSILON) {
                            const t = 1 - e;
                            return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this
                        }
                        const c = Math.sqrt(a),
                            l = Math.atan2(c, o),
                            u = Math.sin((1 - e) * l) / c,
                            h = Math.sin(e * l) / c;
                        return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = i * u + this._z * h, this._onChangeCallback(), this
                    }
                    slerpQuaternions(t, e, n) {
                        this.copy(t).slerp(e, n)
                    }
                    random() {
                        const t = Math.random(),
                            e = Math.sqrt(1 - t),
                            n = Math.sqrt(t),
                            r = 2 * Math.PI * Math.random(),
                            i = 2 * Math.PI * Math.random();
                        return this.set(e * Math.cos(r), n * Math.sin(i), n * Math.cos(i), e * Math.sin(r))
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                    }
                    fromArray(t, e = 0) {
                        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                    }
                    fromBufferAttribute(t, e) {
                        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t, this
                    }
                    _onChangeCallback() {}
                }
                Tt.prototype.isQuaternion = !0;
                class Et {
                    constructor(t = 0, e = 0, n = 0) {
                        this.x = t, this.y = e, this.z = n
                    }
                    set(t, e, n) {
                        return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                    }
                    setScalar(t) {
                        return this.x = t, this.y = t, this.z = t, this
                    }
                    setX(t) {
                        return this.x = t, this
                    }
                    setY(t) {
                        return this.y = t, this
                    }
                    setZ(t) {
                        return this.z = t, this
                    }
                    setComponent(t, e) {
                        switch (t) {
                            case 0:
                                this.x = e;
                                break;
                            case 1:
                                this.y = e;
                                break;
                            case 2:
                                this.z = e;
                                break;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                        return this
                    }
                    getComponent(t) {
                        switch (t) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error("index is out of range: " + t)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                    copy(t) {
                        return this.x = t.x, this.y = t.y, this.z = t.z, this
                    }
                    add(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                    }
                    addScalar(t) {
                        return this.x += t, this.y += t, this.z += t, this
                    }
                    addVectors(t, e) {
                        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                    }
                    addScaledVector(t, e) {
                        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                    }
                    sub(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                    }
                    subScalar(t) {
                        return this.x -= t, this.y -= t, this.z -= t, this
                    }
                    subVectors(t, e) {
                        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                    }
                    multiply(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                    }
                    multiplyScalar(t) {
                        return this.x *= t, this.y *= t, this.z *= t, this
                    }
                    multiplyVectors(t, e) {
                        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                    }
                    applyEuler(t) {
                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Lt.setFromEuler(t))
                    }
                    applyAxisAngle(t, e) {
                        return this.applyQuaternion(Lt.setFromAxisAngle(t, e))
                    }
                    applyMatrix3(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.elements;
                        return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
                    }
                    applyNormalMatrix(t) {
                        return this.applyMatrix3(t).normalize()
                    }
                    applyMatrix4(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.elements,
                            s = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                        return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * s, this
                    }
                    applyQuaternion(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.x,
                            s = t.y,
                            o = t.z,
                            a = t.w,
                            c = a * e + s * r - o * n,
                            l = a * n + o * e - i * r,
                            u = a * r + i * n - s * e,
                            h = -i * e - s * n - o * r;
                        return this.x = c * a + h * -i + l * -o - u * -s, this.y = l * a + h * -s + u * -i - c * -o, this.z = u * a + h * -o + c * -s - l * -i, this
                    }
                    project(t) {
                        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                    }
                    unproject(t) {
                        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                    }
                    transformDirection(t) {
                        const e = this.x,
                            n = this.y,
                            r = this.z,
                            i = t.elements;
                        return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
                    }
                    divide(t) {
                        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                    }
                    divideScalar(t) {
                        return this.multiplyScalar(1 / t)
                    }
                    min(t) {
                        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                    }
                    max(t) {
                        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                    }
                    clamp(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                    }
                    clampScalar(t, e) {
                        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                    }
                    clampLength(t, e) {
                        const n = this.length();
                        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                    }
                    floor() {
                        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                    }
                    ceil() {
                        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                    }
                    round() {
                        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                    }
                    roundToZero() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                    }
                    negate() {
                        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                    }
                    dot(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(t) {
                        return this.normalize().multiplyScalar(t)
                    }
                    lerp(t, e) {
                        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                    }
                    lerpVectors(t, e, n) {
                        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
                    }
                    cross(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                    }
                    crossVectors(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z,
                            s = e.x,
                            o = e.y,
                            a = e.z;
                        return this.x = r * a - i * o, this.y = i * s - n * a, this.z = n * o - r * s, this
                    }
                    projectOnVector(t) {
                        const e = t.lengthSq();
                        if (0 === e) return this.set(0, 0, 0);
                        const n = t.dot(this) / e;
                        return this.copy(t).multiplyScalar(n)
                    }
                    projectOnPlane(t) {
                        return At.copy(this).projectOnVector(t), this.sub(At)
                    }
                    reflect(t) {
                        return this.sub(At.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                    angleTo(t) {
                        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                        if (0 === e) return Math.PI / 2;
                        const n = this.dot(t) / e;
                        return Math.acos(ot(n, -1, 1))
                    }
                    distanceTo(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    }
                    distanceToSquared(t) {
                        const e = this.x - t.x,
                            n = this.y - t.y,
                            r = this.z - t.z;
                        return e * e + n * n + r * r
                    }
                    manhattanDistanceTo(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    }
                    setFromSpherical(t) {
                        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                    }
                    setFromSphericalCoords(t, e, n) {
                        const r = Math.sin(e) * t;
                        return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
                    }
                    setFromCylindrical(t) {
                        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                    }
                    setFromCylindricalCoords(t, e, n) {
                        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                    }
                    setFromMatrixPosition(t) {
                        const e = t.elements;
                        return this.x = e[12], this.y = e[13], this.z = e[14], this
                    }
                    setFromMatrixScale(t) {
                        const e = this.setFromMatrixColumn(t, 0).length(),
                            n = this.setFromMatrixColumn(t, 1).length(),
                            r = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e, this.y = n, this.z = r, this
                    }
                    setFromMatrixColumn(t, e) {
                        return this.fromArray(t.elements, 4 * e)
                    }
                    setFromMatrix3Column(t, e) {
                        return this.fromArray(t.elements, 3 * e)
                    }
                    equals(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    }
                    fromArray(t, e = 0) {
                        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                    }
                    fromBufferAttribute(t, e, n) {
                        return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                    }
                    random() {
                        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                    }
                    randomDirection() {
                        const t = 2 * (Math.random() - .5),
                            e = Math.random() * Math.PI * 2,
                            n = Math.sqrt(1 - t * * 2);
                        return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
                    } * [Symbol.iterator]() {
                        yield this.x,
                            yield this.y,
                            yield this.z
                    }
                }
                Et.prototype.isVector3 = !0;
                const At = new Et,
                    Lt = new Tt;
                class Rt {
                    constructor(t = new Et(1 / 0, 1 / 0, 1 / 0), e = new Et(-1 / 0, -1 / 0, -1 / 0)) {
                        this.min = t, this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                    setFromArray(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            r = 1 / 0,
                            i = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, c = t.length; a < c; a += 3) {
                            const c = t[a],
                                l = t[a + 1],
                                u = t[a + 2];
                            c < e && (e = c), l < n && (n = l), u < r && (r = u), c > i && (i = c), l > s && (s = l), u > o && (o = u)
                        }
                        return this.min.set(e, n, r), this.max.set(i, s, o), this
                    }
                    setFromBufferAttribute(t) {
                        let e = 1 / 0,
                            n = 1 / 0,
                            r = 1 / 0,
                            i = -1 / 0,
                            s = -1 / 0,
                            o = -1 / 0;
                        for (let a = 0, c = t.count; a < c; a++) {
                            const c = t.getX(a),
                                l = t.getY(a),
                                u = t.getZ(a);
                            c < e && (e = c), l < n && (n = l), u < r && (r = u), c > i && (i = c), l > s && (s = l), u > o && (o = u)
                        }
                        return this.min.set(e, n, r), this.max.set(i, s, o), this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = Ct.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    }
                    setFromObject(t) {
                        return this.makeEmpty(), this.expandByObject(t)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    }
                    getCenter(t) {
                        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                    expandByObject(t) {
                        t.updateWorldMatrix(!1, !1);
                        const e = t.geometry;
                        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), It.copy(e.boundingBox), It.applyMatrix4(t.matrixWorld), this.union(It));
                        const n = t.children;
                        for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                        return this
                    }
                    containsPoint(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                    }
                    getParameter(t, e) {
                        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                    }
                    intersectsSphere(t) {
                        return this.clampPoint(t.center, Ct), Ct.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                    intersectsPlane(t) {
                        let e, n;
                        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                    }
                    intersectsTriangle(t) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(kt), Ut.subVectors(this.max, kt), Dt.subVectors(t.a, kt), Ot.subVectors(t.b, kt), Nt.subVectors(t.c, kt), Bt.subVectors(Ot, Dt), zt.subVectors(Nt, Ot), Ft.subVectors(Dt, Nt);
                        let e = [0, -Bt.z, Bt.y, 0, -zt.z, zt.y, 0, -Ft.z, Ft.y, Bt.z, 0, -Bt.x, zt.z, 0, -zt.x, Ft.z, 0, -Ft.x, -Bt.y, Bt.x, 0, -zt.y, zt.x, 0, -Ft.y, Ft.x, 0];
                        return !!Vt(e, Dt, Ot, Nt, Ut) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Vt(e, Dt, Ot, Nt, Ut) && (Ht.crossVectors(Bt, zt), e = [Ht.x, Ht.y, Ht.z], Vt(e, Dt, Ot, Nt, Ut)))
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return Ct.copy(t).clamp(this.min, this.max).sub(t).length()
                    }
                    getBoundingSphere(t) {
                        return this.getCenter(t.center), t.radius = .5 * this.getSize(Ct).length(), t
                    }
                    intersect(t) {
                        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                    applyMatrix4(t) {
                        return this.isEmpty() || (Pt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Pt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Pt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Pt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Pt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Pt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Pt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Pt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Pt)), this
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                Rt.prototype.isBox3 = !0;
                const Pt = [new Et, new Et, new Et, new Et, new Et, new Et, new Et, new Et],
                    Ct = new Et,
                    It = new Rt,
                    Dt = new Et,
                    Ot = new Et,
                    Nt = new Et,
                    Bt = new Et,
                    zt = new Et,
                    Ft = new Et,
                    kt = new Et,
                    Ut = new Et,
                    Ht = new Et,
                    Gt = new Et;

                function Vt(t, e, n, r, i) {
                    for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                        Gt.fromArray(t, s);
                        const o = i.x * Math.abs(Gt.x) + i.y * Math.abs(Gt.y) + i.z * Math.abs(Gt.z),
                            a = e.dot(Gt),
                            c = n.dot(Gt),
                            l = r.dot(Gt);
                        if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > o) return !1
                    }
                    return !0
                }
                const Wt = new Rt,
                    jt = new Et,
                    Zt = new Et,
                    qt = new Et;
                class Xt {
                    constructor(t = new Et, e = -1) {
                        this.center = t, this.radius = e
                    }
                    set(t, e) {
                        return this.center.copy(t), this.radius = e, this
                    }
                    setFromPoints(t, e) {
                        const n = this.center;
                        void 0 !== e ? n.copy(e) : Wt.setFromPoints(t).getCenter(n);
                        let r = 0;
                        for (let e = 0, i = t.length; e < i; e++) r = Math.max(r, n.distanceToSquared(t[e]));
                        return this.radius = Math.sqrt(r), this
                    }
                    copy(t) {
                        return this.center.copy(t.center), this.radius = t.radius, this
                    }
                    isEmpty() {
                        return this.radius < 0
                    }
                    makeEmpty() {
                        return this.center.set(0, 0, 0), this.radius = -1, this
                    }
                    containsPoint(t) {
                        return t.distanceToSquared(this.center) <= this.radius * this.radius
                    }
                    distanceToPoint(t) {
                        return t.distanceTo(this.center) - this.radius
                    }
                    intersectsSphere(t) {
                        const e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e
                    }
                    intersectsBox(t) {
                        return t.intersectsSphere(this)
                    }
                    intersectsPlane(t) {
                        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(t, e) {
                        const n = this.center.distanceToSquared(t);
                        return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                    }
                    getBoundingBox(t) {
                        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                    }
                    applyMatrix4(t) {
                        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                    }
                    translate(t) {
                        return this.center.add(t), this
                    }
                    expandByPoint(t) {
                        qt.subVectors(t, this.center);
                        const e = qt.lengthSq();
                        if (e > this.radius * this.radius) {
                            const t = Math.sqrt(e),
                                n = .5 * (t - this.radius);
                            this.center.add(qt.multiplyScalar(n / t)), this.radius += n
                        }
                        return this
                    }
                    union(t) {
                        return Zt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(jt.copy(t.center).add(Zt)), this.expandByPoint(jt.copy(t.center).sub(Zt)), this
                    }
                    equals(t) {
                        return t.center.equals(this.center) && t.radius === this.radius
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const Yt = new Et,
                    Jt = new Et,
                    Kt = new Et,
                    Qt = new Et,
                    $t = new Et,
                    te = new Et,
                    ee = new Et;
                class ne {
                    constructor(t = new Et, e = new Et(0, 0, -1)) {
                        this.origin = t, this.direction = e
                    }
                    set(t, e) {
                        return this.origin.copy(t), this.direction.copy(e), this
                    }
                    copy(t) {
                        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                    }
                    at(t, e) {
                        return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                    }
                    lookAt(t) {
                        return this.direction.copy(t).sub(this.origin).normalize(), this
                    }
                    recast(t) {
                        return this.origin.copy(this.at(t, Yt)), this
                    }
                    closestPointToPoint(t, e) {
                        e.subVectors(t, this.origin);
                        const n = e.dot(this.direction);
                        return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                    }
                    distanceToPoint(t) {
                        return Math.sqrt(this.distanceSqToPoint(t))
                    }
                    distanceSqToPoint(t) {
                        const e = Yt.subVectors(t, this.origin).dot(this.direction);
                        return e < 0 ? this.origin.distanceToSquared(t) : (Yt.copy(this.direction).multiplyScalar(e).add(this.origin), Yt.distanceToSquared(t))
                    }
                    distanceSqToSegment(t, e, n, r) {
                        Jt.copy(t).add(e).multiplyScalar(.5), Kt.copy(e).sub(t).normalize(), Qt.copy(this.origin).sub(Jt);
                        const i = .5 * t.distanceTo(e),
                            s = -this.direction.dot(Kt),
                            o = Qt.dot(this.direction),
                            a = -Qt.dot(Kt),
                            c = Qt.lengthSq(),
                            l = Math.abs(1 - s * s);
                        let u, h, d, p;
                        if (l > 0)
                            if (u = s * a - o, h = s * o - a, p = i * l, u >= 0)
                                if (h >= -p)
                                    if (h <= p) {
                                        const t = 1 / l;
                                        u *= t, h *= t, d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + c
                                    } else h = i, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + c;
                        else h = -i, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + c;
                        else h <= -p ? (u = Math.max(0, -(-s * i + o)), h = u > 0 ? -i : Math.min(Math.max(-i, -a), i), d = -u * u + h * (h + 2 * a) + c) : h <= p ? (u = 0, h = Math.min(Math.max(-i, -a), i), d = h * (h + 2 * a) + c) : (u = Math.max(0, -(s * i + o)), h = u > 0 ? i : Math.min(Math.max(-i, -a), i), d = -u * u + h * (h + 2 * a) + c);
                        else h = s > 0 ? -i : i, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + c;
                        return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(Kt).multiplyScalar(h).add(Jt), d
                    }
                    intersectSphere(t, e) {
                        Yt.subVectors(t.center, this.origin);
                        const n = Yt.dot(this.direction),
                            r = Yt.dot(Yt) - n * n,
                            i = t.radius * t.radius;
                        if (r > i) return null;
                        const s = Math.sqrt(i - r),
                            o = n - s,
                            a = n + s;
                        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
                    }
                    intersectsSphere(t) {
                        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                    }
                    distanceToPlane(t) {
                        const e = t.normal.dot(this.direction);
                        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                        const n = -(this.origin.dot(t.normal) + t.constant) / e;
                        return n >= 0 ? n : null
                    }
                    intersectPlane(t, e) {
                        const n = this.distanceToPlane(t);
                        return null === n ? null : this.at(n, e)
                    }
                    intersectsPlane(t) {
                        const e = t.distanceToPoint(this.origin);
                        if (0 === e) return !0;
                        return t.normal.dot(this.direction) * e < 0
                    }
                    intersectBox(t, e) {
                        let n, r, i, s, o, a;
                        const c = 1 / this.direction.x,
                            l = 1 / this.direction.y,
                            u = 1 / this.direction.z,
                            h = this.origin;
                        return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), l >= 0 ? (i = (t.min.y - h.y) * l, s = (t.max.y - h.y) * l) : (i = (t.max.y - h.y) * l, s = (t.min.y - h.y) * l), n > s || i > r ? null : ((i > n || n != n) && (n = i), (s < r || r != r) && (r = s), u >= 0 ? (o = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || o > r ? null : ((o > n || n != n) && (n = o), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
                    }
                    intersectsBox(t) {
                        return null !== this.intersectBox(t, Yt)
                    }
                    intersectTriangle(t, e, n, r, i) {
                        $t.subVectors(e, t), te.subVectors(n, t), ee.crossVectors($t, te);
                        let s, o = this.direction.dot(ee);
                        if (o > 0) {
                            if (r) return null;
                            s = 1
                        } else {
                            if (!(o < 0)) return null;
                            s = -1, o = -o
                        }
                        Qt.subVectors(this.origin, t);
                        const a = s * this.direction.dot(te.crossVectors(Qt, te));
                        if (a < 0) return null;
                        const c = s * this.direction.dot($t.cross(Qt));
                        if (c < 0) return null;
                        if (a + c > o) return null;
                        const l = -s * Qt.dot(ee);
                        return l < 0 ? null : this.at(l / o, i)
                    }
                    applyMatrix4(t) {
                        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                    }
                    equals(t) {
                        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                class re {
                    constructor() {
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                    }
                    set(t, e, n, r, i, s, o, a, c, l, u, h, d, p, f, m) {
                        const g = this.elements;
                        return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = s, g[9] = o, g[13] = a, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                    }
                    identity() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    clone() {
                        return (new re).fromArray(this.elements)
                    }
                    copy(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                    }
                    copyPosition(t) {
                        const e = this.elements,
                            n = t.elements;
                        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                    }
                    setFromMatrix3(t) {
                        const e = t.elements;
                        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                    }
                    extractBasis(t, e, n) {
                        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                    }
                    makeBasis(t, e, n) {
                        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                    }
                    extractRotation(t) {
                        const e = this.elements,
                            n = t.elements,
                            r = 1 / ie.setFromMatrixColumn(t, 0).length(),
                            i = 1 / ie.setFromMatrixColumn(t, 1).length(),
                            s = 1 / ie.setFromMatrixColumn(t, 2).length();
                        return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromEuler(t) {
                        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        const e = this.elements,
                            n = t.x,
                            r = t.y,
                            i = t.z,
                            s = Math.cos(n),
                            o = Math.sin(n),
                            a = Math.cos(r),
                            c = Math.sin(r),
                            l = Math.cos(i),
                            u = Math.sin(i);
                        if ("XYZ" === t.order) {
                            const t = s * l,
                                n = s * u,
                                r = o * l,
                                i = o * u;
                            e[0] = a * l, e[4] = -a * u, e[8] = c, e[1] = n + r * c, e[5] = t - i * c, e[9] = -o * a, e[2] = i - t * c, e[6] = r + n * c, e[10] = s * a
                        } else if ("YXZ" === t.order) {
                            const t = a * l,
                                n = a * u,
                                r = c * l,
                                i = c * u;
                            e[0] = t + i * o, e[4] = r * o - n, e[8] = s * c, e[1] = s * u, e[5] = s * l, e[9] = -o, e[2] = n * o - r, e[6] = i + t * o, e[10] = s * a
                        } else if ("ZXY" === t.order) {
                            const t = a * l,
                                n = a * u,
                                r = c * l,
                                i = c * u;
                            e[0] = t - i * o, e[4] = -s * u, e[8] = r + n * o, e[1] = n + r * o, e[5] = s * l, e[9] = i - t * o, e[2] = -s * c, e[6] = o, e[10] = s * a
                        } else if ("ZYX" === t.order) {
                            const t = s * l,
                                n = s * u,
                                r = o * l,
                                i = o * u;
                            e[0] = a * l, e[4] = r * c - n, e[8] = t * c + i, e[1] = a * u, e[5] = i * c + t, e[9] = n * c - r, e[2] = -c, e[6] = o * a, e[10] = s * a
                        } else if ("YZX" === t.order) {
                            const t = s * a,
                                n = s * c,
                                r = o * a,
                                i = o * c;
                            e[0] = a * l, e[4] = i - t * u, e[8] = r * u + n, e[1] = u, e[5] = s * l, e[9] = -o * l, e[2] = -c * l, e[6] = n * u + r, e[10] = t - i * u
                        } else if ("XZY" === t.order) {
                            const t = s * a,
                                n = s * c,
                                r = o * a,
                                i = o * c;
                            e[0] = a * l, e[4] = -u, e[8] = c * l, e[1] = t * u + i, e[5] = s * l, e[9] = n * u - r, e[2] = r * u - n, e[6] = o * l, e[10] = i * u + t
                        }
                        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                    }
                    makeRotationFromQuaternion(t) {
                        return this.compose(oe, t, ae)
                    }
                    lookAt(t, e, n) {
                        const r = this.elements;
                        return ue.subVectors(t, e), 0 === ue.lengthSq() && (ue.z = 1), ue.normalize(), ce.crossVectors(n, ue), 0 === ce.lengthSq() && (1 === Math.abs(n.z) ? ue.x += 1e-4 : ue.z += 1e-4, ue.normalize(), ce.crossVectors(n, ue)), ce.normalize(), le.crossVectors(ue, ce), r[0] = ce.x, r[4] = le.x, r[8] = ue.x, r[1] = ce.y, r[5] = le.y, r[9] = ue.y, r[2] = ce.z, r[6] = le.z, r[10] = ue.z, this
                    }
                    multiply(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                    }
                    premultiply(t) {
                        return this.multiplyMatrices(t, this)
                    }
                    multiplyMatrices(t, e) {
                        const n = t.elements,
                            r = e.elements,
                            i = this.elements,
                            s = n[0],
                            o = n[4],
                            a = n[8],
                            c = n[12],
                            l = n[1],
                            u = n[5],
                            h = n[9],
                            d = n[13],
                            p = n[2],
                            f = n[6],
                            m = n[10],
                            g = n[14],
                            v = n[3],
                            y = n[7],
                            x = n[11],
                            _ = n[15],
                            b = r[0],
                            w = r[4],
                            M = r[8],
                            S = r[12],
                            T = r[1],
                            E = r[5],
                            A = r[9],
                            L = r[13],
                            R = r[2],
                            P = r[6],
                            C = r[10],
                            I = r[14],
                            D = r[3],
                            O = r[7],
                            N = r[11],
                            B = r[15];
                        return i[0] = s * b + o * T + a * R + c * D, i[4] = s * w + o * E + a * P + c * O, i[8] = s * M + o * A + a * C + c * N, i[12] = s * S + o * L + a * I + c * B, i[1] = l * b + u * T + h * R + d * D, i[5] = l * w + u * E + h * P + d * O, i[9] = l * M + u * A + h * C + d * N, i[13] = l * S + u * L + h * I + d * B, i[2] = p * b + f * T + m * R + g * D, i[6] = p * w + f * E + m * P + g * O, i[10] = p * M + f * A + m * C + g * N, i[14] = p * S + f * L + m * I + g * B, i[3] = v * b + y * T + x * R + _ * D, i[7] = v * w + y * E + x * P + _ * O, i[11] = v * M + y * A + x * C + _ * N, i[15] = v * S + y * L + x * I + _ * B, this
                    }
                    multiplyScalar(t) {
                        const e = this.elements;
                        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                    }
                    determinant() {
                        const t = this.elements,
                            e = t[0],
                            n = t[4],
                            r = t[8],
                            i = t[12],
                            s = t[1],
                            o = t[5],
                            a = t[9],
                            c = t[13],
                            l = t[2],
                            u = t[6],
                            h = t[10],
                            d = t[14];
                        return t[3] * (+i * a * u - r * c * u - i * o * h + n * c * h + r * o * d - n * a * d) + t[7] * (+e * a * d - e * c * h + i * s * h - r * s * d + r * c * l - i * a * l) + t[11] * (+e * c * u - e * o * d - i * s * u + n * s * d + i * o * l - n * c * l) + t[15] * (-r * o * l - e * a * u + e * o * h + r * s * u - n * s * h + n * a * l)
                    }
                    transpose() {
                        const t = this.elements;
                        let e;
                        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                    }
                    setPosition(t, e, n) {
                        const r = this.elements;
                        return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
                    }
                    invert() {
                        const t = this.elements,
                            e = t[0],
                            n = t[1],
                            r = t[2],
                            i = t[3],
                            s = t[4],
                            o = t[5],
                            a = t[6],
                            c = t[7],
                            l = t[8],
                            u = t[9],
                            h = t[10],
                            d = t[11],
                            p = t[12],
                            f = t[13],
                            m = t[14],
                            g = t[15],
                            v = u * m * c - f * h * c + f * a * d - o * m * d - u * a * g + o * h * g,
                            y = p * h * c - l * m * c - p * a * d + s * m * d + l * a * g - s * h * g,
                            x = l * f * c - p * u * c + p * o * d - s * f * d - l * o * g + s * u * g,
                            _ = p * u * a - l * f * a - p * o * h + s * f * h + l * o * m - s * u * m,
                            b = e * v + n * y + r * x + i * _;
                        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const w = 1 / b;
                        return t[0] = v * w, t[1] = (f * h * i - u * m * i - f * r * d + n * m * d + u * r * g - n * h * g) * w, t[2] = (o * m * i - f * a * i + f * r * c - n * m * c - o * r * g + n * a * g) * w, t[3] = (u * a * i - o * h * i - u * r * c + n * h * c + o * r * d - n * a * d) * w, t[4] = y * w, t[5] = (l * m * i - p * h * i + p * r * d - e * m * d - l * r * g + e * h * g) * w, t[6] = (p * a * i - s * m * i - p * r * c + e * m * c + s * r * g - e * a * g) * w, t[7] = (s * h * i - l * a * i + l * r * c - e * h * c - s * r * d + e * a * d) * w, t[8] = x * w, t[9] = (p * u * i - l * f * i - p * n * d + e * f * d + l * n * g - e * u * g) * w, t[10] = (s * f * i - p * o * i + p * n * c - e * f * c - s * n * g + e * o * g) * w, t[11] = (l * o * i - s * u * i - l * n * c + e * u * c + s * n * d - e * o * d) * w, t[12] = _ * w, t[13] = (l * f * r - p * u * r + p * n * h - e * f * h - l * n * m + e * u * m) * w, t[14] = (p * o * r - s * f * r - p * n * a + e * f * a + s * n * m - e * o * m) * w, t[15] = (s * u * r - l * o * r + l * n * a - e * u * a - s * n * h + e * o * h) * w, this
                    }
                    scale(t) {
                        const e = this.elements,
                            n = t.x,
                            r = t.y,
                            i = t.z;
                        return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
                    }
                    getMaxScaleOnAxis() {
                        const t = this.elements,
                            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                            r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, n, r))
                    }
                    makeTranslation(t, e, n) {
                        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                    }
                    makeRotationX(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationY(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                    }
                    makeRotationZ(t) {
                        const e = Math.cos(t),
                            n = Math.sin(t);
                        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                    }
                    makeRotationAxis(t, e) {
                        const n = Math.cos(e),
                            r = Math.sin(e),
                            i = 1 - n,
                            s = t.x,
                            o = t.y,
                            a = t.z,
                            c = i * s,
                            l = i * o;
                        return this.set(c * s + n, c * o - r * a, c * a + r * o, 0, c * o + r * a, l * o + n, l * a - r * s, 0, c * a - r * o, l * a + r * s, i * a * a + n, 0, 0, 0, 0, 1), this
                    }
                    makeScale(t, e, n) {
                        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                    }
                    makeShear(t, e, n, r, i, s) {
                        return this.set(1, n, i, 0, t, 1, s, 0, e, r, 1, 0, 0, 0, 0, 1), this
                    }
                    compose(t, e, n) {
                        const r = this.elements,
                            i = e._x,
                            s = e._y,
                            o = e._z,
                            a = e._w,
                            c = i + i,
                            l = s + s,
                            u = o + o,
                            h = i * c,
                            d = i * l,
                            p = i * u,
                            f = s * l,
                            m = s * u,
                            g = o * u,
                            v = a * c,
                            y = a * l,
                            x = a * u,
                            _ = n.x,
                            b = n.y,
                            w = n.z;
                        return r[0] = (1 - (f + g)) * _, r[1] = (d + x) * _, r[2] = (p - y) * _, r[3] = 0, r[4] = (d - x) * b, r[5] = (1 - (h + g)) * b, r[6] = (m + v) * b, r[7] = 0, r[8] = (p + y) * w, r[9] = (m - v) * w, r[10] = (1 - (h + f)) * w, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
                    }
                    decompose(t, e, n) {
                        const r = this.elements;
                        let i = ie.set(r[0], r[1], r[2]).length();
                        const s = ie.set(r[4], r[5], r[6]).length(),
                            o = ie.set(r[8], r[9], r[10]).length();
                        this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], se.copy(this);
                        const a = 1 / i,
                            c = 1 / s,
                            l = 1 / o;
                        return se.elements[0] *= a, se.elements[1] *= a, se.elements[2] *= a, se.elements[4] *= c, se.elements[5] *= c, se.elements[6] *= c, se.elements[8] *= l, se.elements[9] *= l, se.elements[10] *= l, e.setFromRotationMatrix(se), n.x = i, n.y = s, n.z = o, this
                    }
                    makePerspective(t, e, n, r, i, s) {
                        void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                        const o = this.elements,
                            a = 2 * i / (e - t),
                            c = 2 * i / (n - r),
                            l = (e + t) / (e - t),
                            u = (n + r) / (n - r),
                            h = -(s + i) / (s - i),
                            d = -2 * s * i / (s - i);
                        return o[0] = a, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                    }
                    makeOrthographic(t, e, n, r, i, s) {
                        const o = this.elements,
                            a = 1 / (e - t),
                            c = 1 / (n - r),
                            l = 1 / (s - i),
                            u = (e + t) * a,
                            h = (n + r) * c,
                            d = (s + i) * l;
                        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                    }
                    equals(t) {
                        const e = this.elements,
                            n = t.elements;
                        for (let t = 0; t < 16; t++)
                            if (e[t] !== n[t]) return !1;
                        return !0
                    }
                    fromArray(t, e = 0) {
                        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                        return this
                    }
                    toArray(t = [], e = 0) {
                        const n = this.elements;
                        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                    }
                }
                re.prototype.isMatrix4 = !0;
                const ie = new Et,
                    se = new re,
                    oe = new Et(0, 0, 0),
                    ae = new Et(1, 1, 1),
                    ce = new Et,
                    le = new Et,
                    ue = new Et,
                    he = new re,
                    de = new Tt;
                class pe {
                    constructor(t = 0, e = 0, n = 0, r = pe.DefaultOrder) {
                        this._x = t, this._y = e, this._z = n, this._order = r
                    }
                    get x() {
                        return this._x
                    }
                    set x(t) {
                        this._x = t, this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(t) {
                        this._y = t, this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(t) {
                        this._z = t, this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(t) {
                        this._order = t, this._onChangeCallback()
                    }
                    set(t, e, n, r = this._order) {
                        return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    }
                    copy(t) {
                        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                    }
                    setFromRotationMatrix(t, e = this._order, n = !0) {
                        const r = t.elements,
                            i = r[0],
                            s = r[4],
                            o = r[8],
                            a = r[1],
                            c = r[5],
                            l = r[9],
                            u = r[2],
                            h = r[6],
                            d = r[10];
                        switch (e) {
                            case "XYZ":
                                this._y = Math.asin(ot(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(h, c), this._z = 0);
                                break;
                            case "YXZ":
                                this._x = Math.asin(-ot(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(a, c)) : (this._y = Math.atan2(-u, i), this._z = 0);
                                break;
                            case "ZXY":
                                this._x = Math.asin(ot(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(a, i));
                                break;
                            case "ZYX":
                                this._y = Math.asin(-ot(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-s, c));
                                break;
                            case "YZX":
                                this._z = Math.asin(ot(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, c), this._y = Math.atan2(-u, i)) : (this._x = 0, this._y = Math.atan2(o, d));
                                break;
                            case "XZY":
                                this._z = Math.asin(-ot(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-l, d), this._y = 0);
                                break;
                            default:
                                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                        }
                        return this._order = e, !0 === n && this._onChangeCallback(), this
                    }
                    setFromQuaternion(t, e, n) {
                        return he.makeRotationFromQuaternion(t), this.setFromRotationMatrix(he, e, n)
                    }
                    setFromVector3(t, e = this._order) {
                        return this.set(t.x, t.y, t.z, e)
                    }
                    reorder(t) {
                        return de.setFromEuler(this), this.setFromQuaternion(de, t)
                    }
                    equals(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    }
                    fromArray(t) {
                        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                    }
                    toVector3(t) {
                        return t ? t.set(this._x, this._y, this._z) : new Et(this._x, this._y, this._z)
                    }
                    _onChange(t) {
                        return this._onChangeCallback = t, this
                    }
                    _onChangeCallback() {}
                }
                pe.prototype.isEuler = !0, pe.DefaultOrder = "XYZ", pe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
                class fe {
                    constructor() {
                        this.mask = 1
                    }
                    set(t) {
                        this.mask = 1 << t | 0
                    }
                    enable(t) {
                        this.mask |= 1 << t | 0
                    }
                    enableAll() {
                        this.mask = -1
                    }
                    toggle(t) {
                        this.mask ^= 1 << t | 0
                    }
                    disable(t) {
                        this.mask &= ~(1 << t | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(t) {
                        return 0 != (this.mask & t.mask)
                    }
                }
                let me = 0;
                const ge = new Et,
                    ve = new Tt,
                    ye = new re,
                    xe = new Et,
                    _e = new Et,
                    be = new Et,
                    we = new Tt,
                    Me = new Et(1, 0, 0),
                    Se = new Et(0, 1, 0),
                    Te = new Et(0, 0, 1),
                    Ee = {
                        type: "added"
                    },
                    Ae = {
                        type: "removed"
                    };
                class Le extends $ {
                    constructor() {
                        super(), Object.defineProperty(this, "id", {
                            value: me++
                        }), this.uuid = st(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Le.DefaultUp.clone();
                        const t = new Et,
                            e = new pe,
                            n = new Tt,
                            r = new Et(1, 1, 1);
                        e._onChange((function() {
                            n.setFromEuler(e, !1)
                        })), n._onChange((function() {
                            e.setFromQuaternion(n, void 0, !1)
                        })), Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: t
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: e
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: n
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: r
                            },
                            modelViewMatrix: {
                                value: new re
                            },
                            normalMatrix: {
                                value: new ft
                            }
                        }), this.matrix = new re, this.matrixWorld = new re, this.matrixAutoUpdate = Le.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new fe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                    }
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(t) {
                        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(t) {
                        return this.quaternion.premultiply(t), this
                    }
                    setRotationFromAxisAngle(t, e) {
                        this.quaternion.setFromAxisAngle(t, e)
                    }
                    setRotationFromEuler(t) {
                        this.quaternion.setFromEuler(t, !0)
                    }
                    setRotationFromMatrix(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    }
                    setRotationFromQuaternion(t) {
                        this.quaternion.copy(t)
                    }
                    rotateOnAxis(t, e) {
                        return ve.setFromAxisAngle(t, e), this.quaternion.multiply(ve), this
                    }
                    rotateOnWorldAxis(t, e) {
                        return ve.setFromAxisAngle(t, e), this.quaternion.premultiply(ve), this
                    }
                    rotateX(t) {
                        return this.rotateOnAxis(Me, t)
                    }
                    rotateY(t) {
                        return this.rotateOnAxis(Se, t)
                    }
                    rotateZ(t) {
                        return this.rotateOnAxis(Te, t)
                    }
                    translateOnAxis(t, e) {
                        return ge.copy(t).applyQuaternion(this.quaternion), this.position.add(ge.multiplyScalar(e)), this
                    }
                    translateX(t) {
                        return this.translateOnAxis(Me, t)
                    }
                    translateY(t) {
                        return this.translateOnAxis(Se, t)
                    }
                    translateZ(t) {
                        return this.translateOnAxis(Te, t)
                    }
                    localToWorld(t) {
                        return t.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(t) {
                        return t.applyMatrix4(ye.copy(this.matrixWorld).invert())
                    }
                    lookAt(t, e, n) {
                        t.isVector3 ? xe.copy(t) : xe.set(t, e, n);
                        const r = this.parent;
                        this.updateWorldMatrix(!0, !1), _e.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ye.lookAt(_e, xe, this.up) : ye.lookAt(xe, _e, this.up), this.quaternion.setFromRotationMatrix(ye), r && (ye.extractRotation(r.matrixWorld), ve.setFromRotationMatrix(ye), this.quaternion.premultiply(ve.invert()))
                    }
                    add(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                            return this
                        }
                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ee)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                    }
                    remove(t) {
                        if (arguments.length > 1) {
                            for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                            return this
                        }
                        const e = this.children.indexOf(t);
                        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ae)), this
                    }
                    removeFromParent() {
                        const t = this.parent;
                        return null !== t && t.remove(this), this
                    }
                    clear() {
                        for (let t = 0; t < this.children.length; t++) {
                            const e = this.children[t];
                            e.parent = null, e.dispatchEvent(Ae)
                        }
                        return this.children.length = 0, this
                    }
                    attach(t) {
                        return this.updateWorldMatrix(!0, !1), ye.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ye.multiply(t.parent.matrixWorld)), t.applyMatrix4(ye), this.add(t), t.updateWorldMatrix(!1, !0), this
                    }
                    getObjectById(t) {
                        return this.getObjectByProperty("id", t)
                    }
                    getObjectByName(t) {
                        return this.getObjectByProperty("name", t)
                    }
                    getObjectByProperty(t, e) {
                        if (this[t] === e) return this;
                        for (let n = 0, r = this.children.length; n < r; n++) {
                            const r = this.children[n].getObjectByProperty(t, e);
                            if (void 0 !== r) return r
                        }
                    }
                    getWorldPosition(t) {
                        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(t) {
                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_e, t, be), t
                    }
                    getWorldScale(t) {
                        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_e, we, t), t
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(e[8], e[9], e[10]).normalize()
                    }
                    raycast() {}
                    traverse(t) {
                        t(this);
                        const e = this.children;
                        for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
                    }
                    traverseVisible(t) {
                        if (!1 === this.visible) return;
                        t(this);
                        const e = this.children;
                        for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
                    }
                    traverseAncestors(t) {
                        const e = this.parent;
                        null !== e && (t(e), e.traverseAncestors(t))
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(t) {
                        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                        const e = this.children;
                        for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
                    }
                    updateWorldMatrix(t, e) {
                        const n = this.parent;
                        if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                            const t = this.children;
                            for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                        }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t,
                            n = {};
                        e && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {},
                            shapes: {},
                            skeletons: {},
                            animations: {}
                        }, n.metadata = {
                            version: 4.5,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        const r = {};

                        function i(e, n) {
                            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                        }
                        if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(t).uuid);
                        else if (this.isMesh || this.isLine || this.isPoints) {
                            r.geometry = i(t.geometries, this.geometry);
                            const e = this.geometry.parameters;
                            if (void 0 !== e && void 0 !== e.shapes) {
                                const n = e.shapes;
                                if (Array.isArray(n))
                                    for (let e = 0, r = n.length; e < r; e++) {
                                        const r = n[e];
                                        i(t.shapes, r)
                                    } else i(t.shapes, n)
                            }
                        }
                        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                            if (Array.isArray(this.material)) {
                                const e = [];
                                for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
                                r.material = e
                            } else r.material = i(t.materials, this.material);
                        if (this.children.length > 0) {
                            r.children = [];
                            for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
                        }
                        if (this.animations.length > 0) {
                            r.animations = [];
                            for (let e = 0; e < this.animations.length; e++) {
                                const n = this.animations[e];
                                r.animations.push(i(t.animations, n))
                            }
                        }
                        if (e) {
                            const e = s(t.geometries),
                                r = s(t.materials),
                                i = s(t.textures),
                                o = s(t.images),
                                a = s(t.shapes),
                                c = s(t.skeletons),
                                l = s(t.animations);
                            e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), c.length > 0 && (n.skeletons = c), l.length > 0 && (n.animations = l)
                        }
                        return n.object = r, n;

                        function s(t) {
                            const e = [];
                            for (const n in t) {
                                const r = t[n];
                                delete r.metadata, e.push(r)
                            }
                            return e
                        }
                    }
                    clone(t) {
                        return (new this.constructor).copy(this, t)
                    }
                    copy(t, e = !0) {
                        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                            for (let e = 0; e < t.children.length; e++) {
                                const n = t.children[e];
                                this.add(n.clone())
                            }
                        return this
                    }
                }
                Le.DefaultUp = new Et(0, 1, 0), Le.DefaultMatrixAutoUpdate = !0, Le.prototype.isObject3D = !0;
                const Re = new Et,
                    Pe = new Et,
                    Ce = new Et,
                    Ie = new Et,
                    De = new Et,
                    Oe = new Et,
                    Ne = new Et,
                    Be = new Et,
                    ze = new Et,
                    Fe = new Et;
                class ke {
                    constructor(t = new Et, e = new Et, n = new Et) {
                        this.a = t, this.b = e, this.c = n
                    }
                    static getNormal(t, e, n, r) {
                        r.subVectors(n, e), Re.subVectors(t, e), r.cross(Re);
                        const i = r.lengthSq();
                        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                    }
                    static getBarycoord(t, e, n, r, i) {
                        Re.subVectors(r, e), Pe.subVectors(n, e), Ce.subVectors(t, e);
                        const s = Re.dot(Re),
                            o = Re.dot(Pe),
                            a = Re.dot(Ce),
                            c = Pe.dot(Pe),
                            l = Pe.dot(Ce),
                            u = s * c - o * o;
                        if (0 === u) return i.set(-2, -1, -1);
                        const h = 1 / u,
                            d = (c * a - o * l) * h,
                            p = (s * l - o * a) * h;
                        return i.set(1 - d - p, p, d)
                    }
                    static containsPoint(t, e, n, r) {
                        return this.getBarycoord(t, e, n, r, Ie), Ie.x >= 0 && Ie.y >= 0 && Ie.x + Ie.y <= 1
                    }
                    static getUV(t, e, n, r, i, s, o, a) {
                        return this.getBarycoord(t, e, n, r, Ie), a.set(0, 0), a.addScaledVector(i, Ie.x), a.addScaledVector(s, Ie.y), a.addScaledVector(o, Ie.z), a
                    }
                    static isFrontFacing(t, e, n, r) {
                        return Re.subVectors(n, e), Pe.subVectors(t, e), Re.cross(Pe).dot(r) < 0
                    }
                    set(t, e, n) {
                        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                    }
                    setFromPointsAndIndices(t, e, n, r) {
                        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
                    }
                    setFromAttributeAndIndices(t, e, n, r) {
                        return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                    }
                    getArea() {
                        return Re.subVectors(this.c, this.b), Pe.subVectors(this.a, this.b), .5 * Re.cross(Pe).length()
                    }
                    getMidpoint(t) {
                        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(t) {
                        return ke.getNormal(this.a, this.b, this.c, t)
                    }
                    getPlane(t) {
                        return t.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(t, e) {
                        return ke.getBarycoord(t, this.a, this.b, this.c, e)
                    }
                    getUV(t, e, n, r, i) {
                        return ke.getUV(t, this.a, this.b, this.c, e, n, r, i)
                    }
                    containsPoint(t) {
                        return ke.containsPoint(t, this.a, this.b, this.c)
                    }
                    isFrontFacing(t) {
                        return ke.isFrontFacing(this.a, this.b, this.c, t)
                    }
                    intersectsBox(t) {
                        return t.intersectsTriangle(this)
                    }
                    closestPointToPoint(t, e) {
                        const n = this.a,
                            r = this.b,
                            i = this.c;
                        let s, o;
                        De.subVectors(r, n), Oe.subVectors(i, n), Be.subVectors(t, n);
                        const a = De.dot(Be),
                            c = Oe.dot(Be);
                        if (a <= 0 && c <= 0) return e.copy(n);
                        ze.subVectors(t, r);
                        const l = De.dot(ze),
                            u = Oe.dot(ze);
                        if (l >= 0 && u <= l) return e.copy(r);
                        const h = a * u - l * c;
                        if (h <= 0 && a >= 0 && l <= 0) return s = a / (a - l), e.copy(n).addScaledVector(De, s);
                        Fe.subVectors(t, i);
                        const d = De.dot(Fe),
                            p = Oe.dot(Fe);
                        if (p >= 0 && d <= p) return e.copy(i);
                        const f = d * c - a * p;
                        if (f <= 0 && c >= 0 && p <= 0) return o = c / (c - p), e.copy(n).addScaledVector(Oe, o);
                        const m = l * p - d * u;
                        if (m <= 0 && u - l >= 0 && d - p >= 0) return Ne.subVectors(i, r), o = (u - l) / (u - l + (d - p)), e.copy(r).addScaledVector(Ne, o);
                        const g = 1 / (m + f + h);
                        return s = f * g, o = h * g, e.copy(n).addScaledVector(De, s).addScaledVector(Oe, o)
                    }
                    equals(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                }
                let Ue = 0;
                class He extends $ {
                    constructor() {
                        super(), Object.defineProperty(this, "id", {
                            value: Ue++
                        }), this.uuid = st(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = _, this.vertexColors = !1, this.opacity = 1, this.format = z, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(t) {
                        this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
                    }
                    onBuild() {}
                    onBeforeRender() {}
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(t) {
                        if (void 0 !== t)
                            for (const e in t) {
                                const n = t[e];
                                if (void 0 === n) {
                                    console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                    continue
                                }
                                if ("shading" === e) {
                                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                                    continue
                                }
                                const r = this[e];
                                void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                            }
                    }
                    toJSON(t) {
                        const e = void 0 === t || "string" == typeof t;
                        e && (t = {
                            textures: {},
                            images: {}
                        });
                        const n = {
                            metadata: {
                                version: 4.5,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };

                        function r(t) {
                            const e = [];
                            for (const n in t) {
                                const r = t[n];
                                delete r.metadata, e.push(r)
                            }
                            return e
                        }
                        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenTint && this.sheenTint.isColor && (n.sheenTint = this.sheenTint.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (n.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularTintMap && this.specularTintMap.isTexture && (n.specularTintMap = this.specularTintMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (n.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== _ && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.format !== z && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                            const e = r(t.textures),
                                i = r(t.images);
                            e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
                        }
                        return n
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.format = t.format, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                        const e = t.clippingPlanes;
                        let n = null;
                        if (null !== e) {
                            const t = e.length;
                            n = new Array(t);
                            for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
                        }
                        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                }
                He.prototype.isMaterial = !0;
                const Ge = {
                        aliceblue: 15792383,
                        antiquewhite: 16444375,
                        aqua: 65535,
                        aquamarine: 8388564,
                        azure: 15794175,
                        beige: 16119260,
                        bisque: 16770244,
                        black: 0,
                        blanchedalmond: 16772045,
                        blue: 255,
                        blueviolet: 9055202,
                        brown: 10824234,
                        burlywood: 14596231,
                        cadetblue: 6266528,
                        chartreuse: 8388352,
                        chocolate: 13789470,
                        coral: 16744272,
                        cornflowerblue: 6591981,
                        cornsilk: 16775388,
                        crimson: 14423100,
                        cyan: 65535,
                        darkblue: 139,
                        darkcyan: 35723,
                        darkgoldenrod: 12092939,
                        darkgray: 11119017,
                        darkgreen: 25600,
                        darkgrey: 11119017,
                        darkkhaki: 12433259,
                        darkmagenta: 9109643,
                        darkolivegreen: 5597999,
                        darkorange: 16747520,
                        darkorchid: 10040012,
                        darkred: 9109504,
                        darksalmon: 15308410,
                        darkseagreen: 9419919,
                        darkslateblue: 4734347,
                        darkslategray: 3100495,
                        darkslategrey: 3100495,
                        darkturquoise: 52945,
                        darkviolet: 9699539,
                        deeppink: 16716947,
                        deepskyblue: 49151,
                        dimgray: 6908265,
                        dimgrey: 6908265,
                        dodgerblue: 2003199,
                        firebrick: 11674146,
                        floralwhite: 16775920,
                        forestgreen: 2263842,
                        fuchsia: 16711935,
                        gainsboro: 14474460,
                        ghostwhite: 16316671,
                        gold: 16766720,
                        goldenrod: 14329120,
                        gray: 8421504,
                        green: 32768,
                        greenyellow: 11403055,
                        grey: 8421504,
                        honeydew: 15794160,
                        hotpink: 16738740,
                        indianred: 13458524,
                        indigo: 4915330,
                        ivory: 16777200,
                        khaki: 15787660,
                        lavender: 15132410,
                        lavenderblush: 16773365,
                        lawngreen: 8190976,
                        lemonchiffon: 16775885,
                        lightblue: 11393254,
                        lightcoral: 15761536,
                        lightcyan: 14745599,
                        lightgoldenrodyellow: 16448210,
                        lightgray: 13882323,
                        lightgreen: 9498256,
                        lightgrey: 13882323,
                        lightpink: 16758465,
                        lightsalmon: 16752762,
                        lightseagreen: 2142890,
                        lightskyblue: 8900346,
                        lightslategray: 7833753,
                        lightslategrey: 7833753,
                        lightsteelblue: 11584734,
                        lightyellow: 16777184,
                        lime: 65280,
                        limegreen: 3329330,
                        linen: 16445670,
                        magenta: 16711935,
                        maroon: 8388608,
                        mediumaquamarine: 6737322,
                        mediumblue: 205,
                        mediumorchid: 12211667,
                        mediumpurple: 9662683,
                        mediumseagreen: 3978097,
                        mediumslateblue: 8087790,
                        mediumspringgreen: 64154,
                        mediumturquoise: 4772300,
                        mediumvioletred: 13047173,
                        midnightblue: 1644912,
                        mintcream: 16121850,
                        mistyrose: 16770273,
                        moccasin: 16770229,
                        navajowhite: 16768685,
                        navy: 128,
                        oldlace: 16643558,
                        olive: 8421376,
                        olivedrab: 7048739,
                        orange: 16753920,
                        orangered: 16729344,
                        orchid: 14315734,
                        palegoldenrod: 15657130,
                        palegreen: 10025880,
                        paleturquoise: 11529966,
                        palevioletred: 14381203,
                        papayawhip: 16773077,
                        peachpuff: 16767673,
                        peru: 13468991,
                        pink: 16761035,
                        plum: 14524637,
                        powderblue: 11591910,
                        purple: 8388736,
                        rebeccapurple: 6697881,
                        red: 16711680,
                        rosybrown: 12357519,
                        royalblue: 4286945,
                        saddlebrown: 9127187,
                        salmon: 16416882,
                        sandybrown: 16032864,
                        seagreen: 3050327,
                        seashell: 16774638,
                        sienna: 10506797,
                        silver: 12632256,
                        skyblue: 8900331,
                        slateblue: 6970061,
                        slategray: 7372944,
                        slategrey: 7372944,
                        snow: 16775930,
                        springgreen: 65407,
                        steelblue: 4620980,
                        tan: 13808780,
                        teal: 32896,
                        thistle: 14204888,
                        tomato: 16737095,
                        turquoise: 4251856,
                        violet: 15631086,
                        wheat: 16113331,
                        white: 16777215,
                        whitesmoke: 16119285,
                        yellow: 16776960,
                        yellowgreen: 10145074
                    },
                    Ve = {
                        h: 0,
                        s: 0,
                        l: 0
                    },
                    We = {
                        h: 0,
                        s: 0,
                        l: 0
                    };

                function je(t, e, n) {
                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                }

                function Ze(t) {
                    return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                }

                function qe(t) {
                    return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                }
                class Xe {
                    constructor(t, e, n) {
                        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                    }
                    set(t) {
                        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                    }
                    setScalar(t) {
                        return this.r = t, this.g = t, this.b = t, this
                    }
                    setHex(t) {
                        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                    }
                    setRGB(t, e, n) {
                        return this.r = t, this.g = e, this.b = n, this
                    }
                    setHSL(t, e, n) {
                        if (t = at(t, 1), e = ot(e, 0, 1), n = ot(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                        else {
                            const r = n <= .5 ? n * (1 + e) : n + e - n * e,
                                i = 2 * n - r;
                            this.r = je(i, r, t + 1 / 3), this.g = je(i, r, t), this.b = je(i, r, t - 1 / 3)
                        }
                        return this
                    }
                    setStyle(t) {
                        function e(e) {
                            void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                        }
                        let n;
                        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                            let t;
                            const r = n[1],
                                i = n[2];
                            switch (r) {
                                case "rgb":
                                case "rgba":
                                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                                    break;
                                case "hsl":
                                case "hsla":
                                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                                        const n = parseFloat(t[1]) / 360,
                                            r = parseInt(t[2], 10) / 100,
                                            i = parseInt(t[3], 10) / 100;
                                        return e(t[4]), this.setHSL(n, r, i)
                                    }
                            }
                        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                            const t = n[1],
                                e = t.length;
                            if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                            if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                        }
                        return t && t.length > 0 ? this.setColorName(t) : this
                    }
                    setColorName(t) {
                        const e = Ge[t.toLowerCase()];
                        return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b)
                    }
                    copy(t) {
                        return this.r = t.r, this.g = t.g, this.b = t.b, this
                    }
                    copyGammaToLinear(t, e = 2) {
                        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                    }
                    copyLinearToGamma(t, e = 2) {
                        const n = e > 0 ? 1 / e : 1;
                        return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                    }
                    convertGammaToLinear(t) {
                        return this.copyGammaToLinear(this, t), this
                    }
                    convertLinearToGamma(t) {
                        return this.copyLinearToGamma(this, t), this
                    }
                    copySRGBToLinear(t) {
                        return this.r = Ze(t.r), this.g = Ze(t.g), this.b = Ze(t.b), this
                    }
                    copyLinearToSRGB(t) {
                        return this.r = qe(t.r), this.g = qe(t.g), this.b = qe(t.b), this
                    }
                    convertSRGBToLinear() {
                        return this.copySRGBToLinear(this), this
                    }
                    convertLinearToSRGB() {
                        return this.copyLinearToSRGB(this), this
                    }
                    getHex() {
                        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                    }
                    getHexString() {
                        return ("000000" + this.getHex().toString(16)).slice(-6)
                    }
                    getHSL(t) {
                        const e = this.r,
                            n = this.g,
                            r = this.b,
                            i = Math.max(e, n, r),
                            s = Math.min(e, n, r);
                        let o, a;
                        const c = (s + i) / 2;
                        if (s === i) o = 0, a = 0;
                        else {
                            const t = i - s;
                            switch (a = c <= .5 ? t / (i + s) : t / (2 - i - s), i) {
                                case e:
                                    o = (n - r) / t + (n < r ? 6 : 0);
                                    break;
                                case n:
                                    o = (r - e) / t + 2;
                                    break;
                                case r:
                                    o = (e - n) / t + 4
                            }
                            o /= 6
                        }
                        return t.h = o, t.s = a, t.l = c, t
                    }
                    getStyle() {
                        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                    }
                    offsetHSL(t, e, n) {
                        return this.getHSL(Ve), Ve.h += t, Ve.s += e, Ve.l += n, this.setHSL(Ve.h, Ve.s, Ve.l), this
                    }
                    add(t) {
                        return this.r += t.r, this.g += t.g, this.b += t.b, this
                    }
                    addColors(t, e) {
                        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                    }
                    addScalar(t) {
                        return this.r += t, this.g += t, this.b += t, this
                    }
                    sub(t) {
                        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                    }
                    multiply(t) {
                        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                    }
                    multiplyScalar(t) {
                        return this.r *= t, this.g *= t, this.b *= t, this
                    }
                    lerp(t, e) {
                        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                    }
                    lerpColors(t, e, n) {
                        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                    }
                    lerpHSL(t, e) {
                        this.getHSL(Ve), t.getHSL(We);
                        const n = ct(Ve.h, We.h, e),
                            r = ct(Ve.s, We.s, e),
                            i = ct(Ve.l, We.l, e);
                        return this.setHSL(n, r, i), this
                    }
                    equals(t) {
                        return t.r === this.r && t.g === this.g && t.b === this.b
                    }
                    fromArray(t, e = 0) {
                        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                    }
                    toArray(t = [], e = 0) {
                        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                    }
                    fromBufferAttribute(t, e) {
                        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                    }
                    toJSON() {
                        return this.getHex()
                    }
                }
                Xe.NAMES = Ge, Xe.prototype.isColor = !0, Xe.prototype.r = 1, Xe.prototype.g = 1, Xe.prototype.b = 1;
                class Ye extends He {
                    constructor(t) {
                        super(), this.type = "MeshBasicMaterial", this.color = new Xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                    }
                }
                Ye.prototype.isMeshBasicMaterial = !0;
                const Je = new Et,
                    Ke = new pt;
                class Qe {
                    constructor(t, e, n) {
                        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = K, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    copy(t) {
                        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                    }
                    copyAt(t, e, n) {
                        t *= this.itemSize, n *= e.itemSize;
                        for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
                        return this
                    }
                    copyArray(t) {
                        return this.array.set(t), this
                    }
                    copyColorsArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let r = 0, i = t.length; r < i; r++) {
                            let i = t[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new Xe), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b
                        }
                        return this
                    }
                    copyVector2sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let r = 0, i = t.length; r < i; r++) {
                            let i = t[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new pt), e[n++] = i.x, e[n++] = i.y
                        }
                        return this
                    }
                    copyVector3sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let r = 0, i = t.length; r < i; r++) {
                            let i = t[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new Et), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z
                        }
                        return this
                    }
                    copyVector4sArray(t) {
                        const e = this.array;
                        let n = 0;
                        for (let r = 0, i = t.length; r < i; r++) {
                            let i = t[r];
                            void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new wt), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w
                        }
                        return this
                    }
                    applyMatrix3(t) {
                        if (2 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Ke.fromBufferAttribute(this, e), Ke.applyMatrix3(t), this.setXY(e, Ke.x, Ke.y);
                        else if (3 === this.itemSize)
                            for (let e = 0, n = this.count; e < n; e++) Je.fromBufferAttribute(this, e), Je.applyMatrix3(t), this.setXYZ(e, Je.x, Je.y, Je.z);
                        return this
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.count; e < n; e++) Je.x = this.getX(e), Je.y = this.getY(e), Je.z = this.getZ(e), Je.applyMatrix4(t), this.setXYZ(e, Je.x, Je.y, Je.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++) Je.x = this.getX(e), Je.y = this.getY(e), Je.z = this.getZ(e), Je.applyNormalMatrix(t), this.setXYZ(e, Je.x, Je.y, Je.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++) Je.x = this.getX(e), Je.y = this.getY(e), Je.z = this.getZ(e), Je.transformDirection(t), this.setXYZ(e, Je.x, Je.y, Je.z);
                        return this
                    }
                    set(t, e = 0) {
                        return this.array.set(t, e), this
                    }
                    getX(t) {
                        return this.array[t * this.itemSize]
                    }
                    setX(t, e) {
                        return this.array[t * this.itemSize] = e, this
                    }
                    getY(t) {
                        return this.array[t * this.itemSize + 1]
                    }
                    setY(t, e) {
                        return this.array[t * this.itemSize + 1] = e, this
                    }
                    getZ(t) {
                        return this.array[t * this.itemSize + 2]
                    }
                    setZ(t, e) {
                        return this.array[t * this.itemSize + 2] = e, this
                    }
                    getW(t) {
                        return this.array[t * this.itemSize + 3]
                    }
                    setW(t, e) {
                        return this.array[t * this.itemSize + 3] = e, this
                    }
                    setXY(t, e, n) {
                        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                    }
                    setXYZ(t, e, n, r) {
                        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
                    }
                    setXYZW(t, e, n, r, i) {
                        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t, this
                    }
                    clone() {
                        return new this.constructor(this.array, this.itemSize).copy(this)
                    }
                    toJSON() {
                        const t = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.prototype.slice.call(this.array),
                            normalized: this.normalized
                        };
                        return "" !== this.name && (t.name = this.name), this.usage !== K && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
                    }
                }
                Qe.prototype.isBufferAttribute = !0;
                class $e extends Qe {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n)
                    }
                }
                class tn extends Qe {
                    constructor(t, e, n) {
                        super(new Uint32Array(t), e, n)
                    }
                }(class extends Qe {
                    constructor(t, e, n) {
                        super(new Uint16Array(t), e, n)
                    }
                }).prototype.isFloat16BufferAttribute = !0;
                class en extends Qe {
                    constructor(t, e, n) {
                        super(new Float32Array(t), e, n)
                    }
                }
                let nn = 0;
                const rn = new re,
                    sn = new Le,
                    on = new Et,
                    an = new Rt,
                    cn = new Rt,
                    ln = new Et;
                class un extends $ {
                    constructor() {
                        super(), Object.defineProperty(this, "id", {
                            value: nn++
                        }), this.uuid = st(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                            start: 0,
                            count: 1 / 0
                        }, this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(t) {
                        return Array.isArray(t) ? this.index = new(mt(t) > 65535 ? tn : $e)(t, 1) : this.index = t, this
                    }
                    getAttribute(t) {
                        return this.attributes[t]
                    }
                    setAttribute(t, e) {
                        return this.attributes[t] = e, this
                    }
                    deleteAttribute(t) {
                        return delete this.attributes[t], this
                    }
                    hasAttribute(t) {
                        return void 0 !== this.attributes[t]
                    }
                    addGroup(t, e, n = 0) {
                        this.groups.push({
                            start: t,
                            count: e,
                            materialIndex: n
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(t, e) {
                        this.drawRange.start = t, this.drawRange.count = e
                    }
                    applyMatrix4(t) {
                        const e = this.attributes.position;
                        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                        const n = this.attributes.normal;
                        if (void 0 !== n) {
                            const e = (new ft).getNormalMatrix(t);
                            n.applyNormalMatrix(e), n.needsUpdate = !0
                        }
                        const r = this.attributes.tangent;
                        return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                    }
                    applyQuaternion(t) {
                        return rn.makeRotationFromQuaternion(t), this.applyMatrix4(rn), this
                    }
                    rotateX(t) {
                        return rn.makeRotationX(t), this.applyMatrix4(rn), this
                    }
                    rotateY(t) {
                        return rn.makeRotationY(t), this.applyMatrix4(rn), this
                    }
                    rotateZ(t) {
                        return rn.makeRotationZ(t), this.applyMatrix4(rn), this
                    }
                    translate(t, e, n) {
                        return rn.makeTranslation(t, e, n), this.applyMatrix4(rn), this
                    }
                    scale(t, e, n) {
                        return rn.makeScale(t, e, n), this.applyMatrix4(rn), this
                    }
                    lookAt(t) {
                        return sn.lookAt(t), sn.updateMatrix(), this.applyMatrix4(sn.matrix), this
                    }
                    center() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(on).negate(), this.translate(on.x, on.y, on.z), this
                    }
                    setFromPoints(t) {
                        const e = [];
                        for (let n = 0, r = t.length; n < r; n++) {
                            const r = t[n];
                            e.push(r.x, r.y, r.z || 0)
                        }
                        return this.setAttribute("position", new en(e, 3)), this
                    }
                    computeBoundingBox() {
                        null === this.boundingBox && (this.boundingBox = new Rt);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Et(-1 / 0, -1 / 0, -1 / 0), new Et(1 / 0, 1 / 0, 1 / 0));
                        if (void 0 !== t) {
                            if (this.boundingBox.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    an.setFromBufferAttribute(n), this.morphTargetsRelative ? (ln.addVectors(this.boundingBox.min, an.min), this.boundingBox.expandByPoint(ln), ln.addVectors(this.boundingBox.max, an.max), this.boundingBox.expandByPoint(ln)) : (this.boundingBox.expandByPoint(an.min), this.boundingBox.expandByPoint(an.max))
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                    computeBoundingSphere() {
                        null === this.boundingSphere && (this.boundingSphere = new Xt);
                        const t = this.attributes.position,
                            e = this.morphAttributes.position;
                        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Et, 1 / 0);
                        if (t) {
                            const n = this.boundingSphere.center;
                            if (an.setFromBufferAttribute(t), e)
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    cn.setFromBufferAttribute(n), this.morphTargetsRelative ? (ln.addVectors(an.min, cn.min), an.expandByPoint(ln), ln.addVectors(an.max, cn.max), an.expandByPoint(ln)) : (an.expandByPoint(cn.min), an.expandByPoint(cn.max))
                                }
                            an.getCenter(n);
                            let r = 0;
                            for (let e = 0, i = t.count; e < i; e++) ln.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(ln));
                            if (e)
                                for (let i = 0, s = e.length; i < s; i++) {
                                    const s = e[i],
                                        o = this.morphTargetsRelative;
                                    for (let e = 0, i = s.count; e < i; e++) ln.fromBufferAttribute(s, e), o && (on.fromBufferAttribute(t, e), ln.add(on)), r = Math.max(r, n.distanceToSquared(ln))
                                }
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeTangents() {
                        const t = this.index,
                            e = this.attributes;
                        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                        const n = t.array,
                            r = e.position.array,
                            i = e.normal.array,
                            s = e.uv.array,
                            o = r.length / 3;
                        void 0 === e.tangent && this.setAttribute("tangent", new Qe(new Float32Array(4 * o), 4));
                        const a = e.tangent.array,
                            c = [],
                            l = [];
                        for (let t = 0; t < o; t++) c[t] = new Et, l[t] = new Et;
                        const u = new Et,
                            h = new Et,
                            d = new Et,
                            p = new pt,
                            f = new pt,
                            m = new pt,
                            g = new Et,
                            v = new Et;

                        function y(t, e, n) {
                            u.fromArray(r, 3 * t), h.fromArray(r, 3 * e), d.fromArray(r, 3 * n), p.fromArray(s, 2 * t), f.fromArray(s, 2 * e), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
                            const i = 1 / (f.x * m.y - m.x * f.y);
                            isFinite(i) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(i), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(i), c[t].add(g), c[e].add(g), c[n].add(g), l[t].add(v), l[e].add(v), l[n].add(v))
                        }
                        let x = this.groups;
                        0 === x.length && (x = [{
                            start: 0,
                            count: n.length
                        }]);
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                r = e.start;
                            for (let t = r, e = r + e.count; t < e; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                        }
                        const _ = new Et,
                            b = new Et,
                            w = new Et,
                            M = new Et;

                        function S(t) {
                            w.fromArray(i, 3 * t), M.copy(w);
                            const e = c[t];
                            _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e);
                            const n = b.dot(l[t]) < 0 ? -1 : 1;
                            a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                        }
                        for (let t = 0, e = x.length; t < e; ++t) {
                            const e = x[t],
                                r = e.start;
                            for (let t = r, e = r + e.count; t < e; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                        }
                    }
                    computeVertexNormals() {
                        const t = this.index,
                            e = this.getAttribute("position");
                        if (void 0 !== e) {
                            let n = this.getAttribute("normal");
                            if (void 0 === n) n = new Qe(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                            else
                                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                            const r = new Et,
                                i = new Et,
                                s = new Et,
                                o = new Et,
                                a = new Et,
                                c = new Et,
                                l = new Et,
                                u = new Et;
                            if (t)
                                for (let h = 0, d = t.count; h < d; h += 3) {
                                    const d = t.getX(h + 0),
                                        p = t.getX(h + 1),
                                        f = t.getX(h + 2);
                                    r.fromBufferAttribute(e, d), i.fromBufferAttribute(e, p), s.fromBufferAttribute(e, f), l.subVectors(s, i), u.subVectors(r, i), l.cross(u), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), c.fromBufferAttribute(n, f), o.add(l), a.add(l), c.add(l), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, c.x, c.y, c.z)
                                } else
                                    for (let t = 0, o = e.count; t < o; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), l.subVectors(s, i), u.subVectors(r, i), l.cross(u), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z);
                            this.normalizeNormals(), n.needsUpdate = !0
                        }
                    }
                    merge(t, e) {
                        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        const n = this.attributes;
                        for (const r in n) {
                            if (void 0 === t.attributes[r]) continue;
                            const i = n[r].array,
                                s = t.attributes[r],
                                o = s.array,
                                a = s.itemSize * e,
                                c = Math.min(o.length, i.length - a);
                            for (let t = 0, e = a; t < c; t++, e++) i[e] = o[t]
                        }
                        return this
                    }
                    normalizeNormals() {
                        const t = this.attributes.normal;
                        for (let e = 0, n = t.count; e < n; e++) ln.fromBufferAttribute(t, e), ln.normalize(), t.setXYZ(e, ln.x, ln.y, ln.z)
                    }
                    toNonIndexed() {
                        function t(t, e) {
                            const n = t.array,
                                r = t.itemSize,
                                i = t.normalized,
                                s = new n.constructor(e.length * r);
                            let o = 0,
                                a = 0;
                            for (let i = 0, c = e.length; i < c; i++) {
                                o = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
                                for (let t = 0; t < r; t++) s[a++] = n[o++]
                            }
                            return new Qe(s, r, i)
                        }
                        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                        const e = new un,
                            n = this.index.array,
                            r = this.attributes;
                        for (const i in r) {
                            const s = t(r[i], n);
                            e.setAttribute(i, s)
                        }
                        const i = this.morphAttributes;
                        for (const r in i) {
                            const s = [],
                                o = i[r];
                            for (let e = 0, r = o.length; e < r; e++) {
                                const r = t(o[e], n);
                                s.push(r)
                            }
                            e.morphAttributes[r] = s
                        }
                        e.morphTargetsRelative = this.morphTargetsRelative;
                        const s = this.groups;
                        for (let t = 0, n = s.length; t < n; t++) {
                            const n = s[t];
                            e.addGroup(n.start, n.count, n.materialIndex)
                        }
                        return e
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                            const e = this.parameters;
                            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        const e = this.index;
                        null !== e && (t.data.index = {
                            type: e.array.constructor.name,
                            array: Array.prototype.slice.call(e.array)
                        });
                        const n = this.attributes;
                        for (const e in n) {
                            const r = n[e];
                            t.data.attributes[e] = r.toJSON(t.data)
                        }
                        const r = {};
                        let i = !1;
                        for (const e in this.morphAttributes) {
                            const n = this.morphAttributes[e],
                                s = [];
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                s.push(r.toJSON(t.data))
                            }
                            s.length > 0 && (r[e] = s, i = !0)
                        }
                        i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
                        const s = this.groups;
                        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                        const o = this.boundingSphere;
                        return null !== o && (t.data.boundingSphere = {
                            center: o.center.toArray(),
                            radius: o.radius
                        }), t
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                        const e = {};
                        this.name = t.name;
                        const n = t.index;
                        null !== n && this.setIndex(n.clone(e));
                        const r = t.attributes;
                        for (const t in r) {
                            const n = r[t];
                            this.setAttribute(t, n.clone(e))
                        }
                        const i = t.morphAttributes;
                        for (const t in i) {
                            const n = [],
                                r = i[t];
                            for (let t = 0, i = r.length; t < i; t++) n.push(r[t].clone(e));
                            this.morphAttributes[t] = n
                        }
                        this.morphTargetsRelative = t.morphTargetsRelative;
                        const s = t.groups;
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t];
                            this.addGroup(e.start, e.count, e.materialIndex)
                        }
                        const o = t.boundingBox;
                        null !== o && (this.boundingBox = o.clone());
                        const a = t.boundingSphere;
                        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }
                un.prototype.isBufferGeometry = !0;
                const hn = new re,
                    dn = new ne,
                    pn = new Xt,
                    fn = new Et,
                    mn = new Et,
                    gn = new Et,
                    vn = new Et,
                    yn = new Et,
                    xn = new Et,
                    _n = new Et,
                    bn = new Et,
                    wn = new Et,
                    Mn = new pt,
                    Sn = new pt,
                    Tn = new pt,
                    En = new Et,
                    An = new Et;
                class Ln extends Le {
                    constructor(t = new un, e = new Ye) {
                        super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t) {
                        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            r = this.material,
                            i = this.matrixWorld;
                        if (void 0 === r) return;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), pn.copy(n.boundingSphere), pn.applyMatrix4(i), !1 === t.ray.intersectsSphere(pn)) return;
                        if (hn.copy(i).invert(), dn.copy(t.ray).applyMatrix4(hn), null !== n.boundingBox && !1 === dn.intersectsBox(n.boundingBox)) return;
                        let s;
                        if (n.isBufferGeometry) {
                            const i = n.index,
                                o = n.attributes.position,
                                a = n.morphAttributes.position,
                                c = n.morphTargetsRelative,
                                l = n.attributes.uv,
                                u = n.attributes.uv2,
                                h = n.groups,
                                d = n.drawRange;
                            if (null !== i)
                                if (Array.isArray(r))
                                    for (let n = 0, p = h.length; n < p; n++) {
                                        const p = h[n],
                                            f = r[p.materialIndex];
                                        for (let n = Math.max(p.start, d.start), r = Math.min(i.count, Math.min(p.start + p.count, d.start + d.count)); n < r; n += 3) {
                                            const r = i.getX(n),
                                                h = i.getX(n + 1),
                                                d = i.getX(n + 2);
                                            s = Rn(this, f, t, dn, o, a, c, l, u, r, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                        }
                                    } else {
                                        const n = Math.max(0, d.start),
                                            h = Math.min(i.count, d.start + d.count);
                                        for (let d = n, p = h; d < p; d += 3) {
                                            const n = i.getX(d),
                                                h = i.getX(d + 1),
                                                p = i.getX(d + 2);
                                            s = Rn(this, r, t, dn, o, a, c, l, u, n, h, p), s && (s.faceIndex = Math.floor(d / 3), e.push(s))
                                        }
                                    } else if (void 0 !== o)
                                        if (Array.isArray(r))
                                            for (let n = 0, i = h.length; n < i; n++) {
                                                const i = h[n],
                                                    p = r[i.materialIndex];
                                                for (let n = Math.max(i.start, d.start), r = Math.min(o.count, Math.min(i.start + i.count, d.start + d.count)); n < r; n += 3) {
                                                    s = Rn(this, p, t, dn, o, a, c, l, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, e.push(s))
                                                }
                                            } else {
                                                for (let n = Math.max(0, i.start), i = Math.min(o.count, i.start + i.count); n < i; n += 3) {
                                                    s = Rn(this, r, t, dn, o, a, c, l, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                                }
                                            }
                        } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }

                function Rn(t, e, n, r, i, s, o, a, c, l, u, h) {
                    fn.fromBufferAttribute(i, l), mn.fromBufferAttribute(i, u), gn.fromBufferAttribute(i, h);
                    const d = t.morphTargetInfluences;
                    if (s && d) {
                        _n.set(0, 0, 0), bn.set(0, 0, 0), wn.set(0, 0, 0);
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = d[t],
                                n = s[t];
                            0 !== e && (vn.fromBufferAttribute(n, l), yn.fromBufferAttribute(n, u), xn.fromBufferAttribute(n, h), o ? (_n.addScaledVector(vn, e), bn.addScaledVector(yn, e), wn.addScaledVector(xn, e)) : (_n.addScaledVector(vn.sub(fn), e), bn.addScaledVector(yn.sub(mn), e), wn.addScaledVector(xn.sub(gn), e)))
                        }
                        fn.add(_n), mn.add(bn), gn.add(wn)
                    }
                    t.isSkinnedMesh && (t.boneTransform(l, fn), t.boneTransform(u, mn), t.boneTransform(h, gn));
                    const p = function(t, e, n, r, i, s, o, a) {
                        let c;
                        if (c = 1 === e.side ? r.intersectTriangle(o, s, i, !0, a) : r.intersectTriangle(i, s, o, e.side !== b, a), null === c) return null;
                        An.copy(a), An.applyMatrix4(t.matrixWorld);
                        const l = n.ray.origin.distanceTo(An);
                        return l < n.near || l > n.far ? null : {
                            distance: l,
                            point: An.clone(),
                            object: t
                        }
                    }(t, e, n, r, fn, mn, gn, En);
                    if (p) {
                        a && (Mn.fromBufferAttribute(a, l), Sn.fromBufferAttribute(a, u), Tn.fromBufferAttribute(a, h), p.uv = ke.getUV(En, fn, mn, gn, Mn, Sn, Tn, new pt)), c && (Mn.fromBufferAttribute(c, l), Sn.fromBufferAttribute(c, u), Tn.fromBufferAttribute(c, h), p.uv2 = ke.getUV(En, fn, mn, gn, Mn, Sn, Tn, new pt));
                        const t = {
                            a: l,
                            b: u,
                            c: h,
                            normal: new Et,
                            materialIndex: 0
                        };
                        ke.getNormal(fn, mn, gn, t.normal), p.face = t
                    }
                    return p
                }
                Ln.prototype.isMesh = !0;
                class Pn extends un {
                    constructor(t = 1, e = 1, n = 1, r = 1, i = 1, s = 1) {
                        super(), this.type = "BoxGeometry", this.parameters = {
                            width: t,
                            height: e,
                            depth: n,
                            widthSegments: r,
                            heightSegments: i,
                            depthSegments: s
                        };
                        const o = this;
                        r = Math.floor(r), i = Math.floor(i), s = Math.floor(s);
                        const a = [],
                            c = [],
                            l = [],
                            u = [];
                        let h = 0,
                            d = 0;

                        function p(t, e, n, r, i, s, p, f, m, g, v) {
                            const y = s / m,
                                x = p / g,
                                _ = s / 2,
                                b = p / 2,
                                w = f / 2,
                                M = m + 1,
                                S = g + 1;
                            let T = 0,
                                E = 0;
                            const A = new Et;
                            for (let s = 0; s < S; s++) {
                                const o = s * x - b;
                                for (let a = 0; a < M; a++) {
                                    const h = a * y - _;
                                    A[t] = h * r, A[e] = o * i, A[n] = w, c.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, l.push(A.x, A.y, A.z), u.push(a / m), u.push(1 - s / g), T += 1
                                }
                            }
                            for (let t = 0; t < g; t++)
                                for (let e = 0; e < m; e++) {
                                    const n = h + e + M * t,
                                        r = h + e + M * (t + 1),
                                        i = h + (e + 1) + M * (t + 1),
                                        s = h + (e + 1) + M * t;
                                    a.push(n, r, s), a.push(r, i, s), E += 6
                                }
                            o.addGroup(d, E, v), d += E, h += T
                        }
                        p("z", "y", "x", -1, -1, n, e, t, s, i, 0), p("z", "y", "x", 1, -1, n, e, -t, s, i, 1), p("x", "z", "y", 1, 1, t, n, e, r, s, 2), p("x", "z", "y", 1, -1, t, n, -e, r, s, 3), p("x", "y", "z", 1, -1, t, e, n, r, i, 4), p("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new en(c, 3)), this.setAttribute("normal", new en(l, 3)), this.setAttribute("uv", new en(u, 2))
                    }
                    static fromJSON(t) {
                        return new Pn(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
                    }
                }

                function Cn(t) {
                    const e = {};
                    for (const n in t) {
                        e[n] = {};
                        for (const r in t[n]) {
                            const i = t[n][r];
                            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                        }
                    }
                    return e
                }

                function In(t) {
                    const e = {};
                    for (let n = 0; n < t.length; n++) {
                        const r = Cn(t[n]);
                        for (const t in r) e[t] = r[t]
                    }
                    return e
                }
                const Dn = {
                    clone: Cn,
                    merge: In
                };
                class On extends He {
                    constructor(t) {
                        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1
                        }, this.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv2: [0, 0]
                        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                    }
                    copy(t) {
                        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Cn(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        e.glslVersion = this.glslVersion, e.uniforms = {};
                        for (const n in this.uniforms) {
                            const r = this.uniforms[n].value;
                            r && r.isTexture ? e.uniforms[n] = {
                                type: "t",
                                value: r.toJSON(t).uuid
                            } : r && r.isColor ? e.uniforms[n] = {
                                type: "c",
                                value: r.getHex()
                            } : r && r.isVector2 ? e.uniforms[n] = {
                                type: "v2",
                                value: r.toArray()
                            } : r && r.isVector3 ? e.uniforms[n] = {
                                type: "v3",
                                value: r.toArray()
                            } : r && r.isVector4 ? e.uniforms[n] = {
                                type: "v4",
                                value: r.toArray()
                            } : r && r.isMatrix3 ? e.uniforms[n] = {
                                type: "m3",
                                value: r.toArray()
                            } : r && r.isMatrix4 ? e.uniforms[n] = {
                                type: "m4",
                                value: r.toArray()
                            } : e.uniforms[n] = {
                                value: r
                            }
                        }
                        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                        const n = {};
                        for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                        return Object.keys(n).length > 0 && (e.extensions = n), e
                    }
                }
                On.prototype.isShaderMaterial = !0;
                class Nn extends Le {
                    constructor() {
                        super(), this.type = "Camera", this.matrixWorldInverse = new re, this.projectionMatrix = new re, this.projectionMatrixInverse = new re
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                    }
                    getWorldDirection(t) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return t.set(-e[8], -e[9], -e[10]).normalize()
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(t, e) {
                        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                Nn.prototype.isCamera = !0;
                class Bn extends Nn {
                    constructor(t = 50, e = 1, n = .1, r = 2e3) {
                        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                    }
                    setFocalLength(t) {
                        const e = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * nt * Math.atan(e), this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const t = Math.tan(.5 * et * this.fov);
                        return .5 * this.getFilmHeight() / t
                    }
                    getEffectiveFOV() {
                        return 2 * nt * Math.atan(Math.tan(.5 * et * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    setViewOffset(t, e, n, r, i, s) {
                        this.aspect = t / e, null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = this.near;
                        let e = t * Math.tan(.5 * et * this.fov) / this.zoom,
                            n = 2 * e,
                            r = this.aspect * n,
                            i = -.5 * r;
                        const s = this.view;
                        if (null !== this.view && this.view.enabled) {
                            const t = s.fullWidth,
                                o = s.fullHeight;
                            i += s.offsetX * r / t, e -= s.offsetY * n / o, r *= s.width / t, n *= s.height / o
                        }
                        const o = this.filmOffset;
                        0 !== o && (i += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                    }
                }
                Bn.prototype.isPerspectiveCamera = !0;
                class zn extends Le {
                    constructor(t, e, n) {
                        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                        this.renderTarget = n;
                        const r = new Bn(90, 1, t, e);
                        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Et(1, 0, 0)), this.add(r);
                        const i = new Bn(90, 1, t, e);
                        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Et(-1, 0, 0)), this.add(i);
                        const s = new Bn(90, 1, t, e);
                        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Et(0, 1, 0)), this.add(s);
                        const o = new Bn(90, 1, t, e);
                        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Et(0, -1, 0)), this.add(o);
                        const a = new Bn(90, 1, t, e);
                        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Et(0, 0, 1)), this.add(a);
                        const c = new Bn(90, 1, t, e);
                        c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new Et(0, 0, -1)), this.add(c)
                    }
                    update(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        const n = this.renderTarget,
                            [r, i, s, o, a, c] = this.children,
                            l = t.xr.enabled,
                            u = t.getRenderTarget();
                        t.xr.enabled = !1;
                        const h = n.texture.generateMipmaps;
                        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = l
                    }
                }
                class Fn extends _t {
                    constructor(t, e, n, r, i, s, o, a, c, l) {
                        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, n, r, i, s, o, a, c, l), this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(t) {
                        this.image = t
                    }
                }
                Fn.prototype.isCubeTexture = !0;
                class kn extends Mt {
                    constructor(t, e, n) {
                        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Fn(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : R, this.texture._needsFlipEnvMap = !1
                    }
                    fromEquirectangularTexture(t, e) {
                        this.texture.type = e.type, this.texture.format = z, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                        const n = {
                                tEquirect: {
                                    value: null
                                }
                            },
                            r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                            s = new Pn(5, 5, 5),
                            o = new On({
                                name: "CubemapFromEquirect",
                                uniforms: Cn(n),
                                vertexShader: r,
                                fragmentShader: i,
                                side: 1,
                                blending: 0
                            });
                        o.uniforms.tEquirect.value = e;
                        const a = new Ln(s, o),
                            c = e.minFilter;
                        e.minFilter === C && (e.minFilter = R);
                        return new zn(1, 10, this).update(t, a), e.minFilter = c, a.geometry.dispose(), a.material.dispose(), this
                    }
                    clear(t, e, n, r) {
                        const i = t.getRenderTarget();
                        for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, n, r);
                        t.setRenderTarget(i)
                    }
                }
                kn.prototype.isWebGLCubeRenderTarget = !0;
                const Un = new Et,
                    Hn = new Et,
                    Gn = new ft;
                class Vn {
                    constructor(t = new Et(1, 0, 0), e = 0) {
                        this.normal = t, this.constant = e
                    }
                    set(t, e) {
                        return this.normal.copy(t), this.constant = e, this
                    }
                    setComponents(t, e, n, r) {
                        return this.normal.set(t, e, n), this.constant = r, this
                    }
                    setFromNormalAndCoplanarPoint(t, e) {
                        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                    }
                    setFromCoplanarPoints(t, e, n) {
                        const r = Un.subVectors(n, e).cross(Hn.subVectors(t, e)).normalize();
                        return this.setFromNormalAndCoplanarPoint(r, t), this
                    }
                    copy(t) {
                        return this.normal.copy(t.normal), this.constant = t.constant, this
                    }
                    normalize() {
                        const t = 1 / this.normal.length();
                        return this.normal.multiplyScalar(t), this.constant *= t, this
                    }
                    negate() {
                        return this.constant *= -1, this.normal.negate(), this
                    }
                    distanceToPoint(t) {
                        return this.normal.dot(t) + this.constant
                    }
                    distanceToSphere(t) {
                        return this.distanceToPoint(t.center) - t.radius
                    }
                    projectPoint(t, e) {
                        return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                    }
                    intersectLine(t, e) {
                        const n = t.delta(Un),
                            r = this.normal.dot(n);
                        if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                        const i = -(t.start.dot(this.normal) + this.constant) / r;
                        return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start)
                    }
                    intersectsLine(t) {
                        const e = this.distanceToPoint(t.start),
                            n = this.distanceToPoint(t.end);
                        return e < 0 && n > 0 || n < 0 && e > 0
                    }
                    intersectsBox(t) {
                        return t.intersectsPlane(this)
                    }
                    intersectsSphere(t) {
                        return t.intersectsPlane(this)
                    }
                    coplanarPoint(t) {
                        return t.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(t, e) {
                        const n = e || Gn.getNormalMatrix(t),
                            r = this.coplanarPoint(Un).applyMatrix4(t),
                            i = this.normal.applyMatrix3(n).normalize();
                        return this.constant = -r.dot(i), this
                    }
                    translate(t) {
                        return this.constant -= t.dot(this.normal), this
                    }
                    equals(t) {
                        return t.normal.equals(this.normal) && t.constant === this.constant
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                Vn.prototype.isPlane = !0;
                const Wn = new Xt,
                    jn = new Et;
                class Zn {
                    constructor(t = new Vn, e = new Vn, n = new Vn, r = new Vn, i = new Vn, s = new Vn) {
                        this.planes = [t, e, n, r, i, s]
                    }
                    set(t, e, n, r, i, s) {
                        const o = this.planes;
                        return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this
                    }
                    copy(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                        return this
                    }
                    setFromProjectionMatrix(t) {
                        const e = this.planes,
                            n = t.elements,
                            r = n[0],
                            i = n[1],
                            s = n[2],
                            o = n[3],
                            a = n[4],
                            c = n[5],
                            l = n[6],
                            u = n[7],
                            h = n[8],
                            d = n[9],
                            p = n[10],
                            f = n[11],
                            m = n[12],
                            g = n[13],
                            v = n[14],
                            y = n[15];
                        return e[0].setComponents(o - r, u - a, f - h, y - m).normalize(), e[1].setComponents(o + r, u + a, f + h, y + m).normalize(), e[2].setComponents(o + i, u + c, f + d, y + g).normalize(), e[3].setComponents(o - i, u - c, f - d, y - g).normalize(), e[4].setComponents(o - s, u - l, f - p, y - v).normalize(), e[5].setComponents(o + s, u + l, f + p, y + v).normalize(), this
                    }
                    intersectsObject(t) {
                        const e = t.geometry;
                        return null === e.boundingSphere && e.computeBoundingSphere(), Wn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Wn)
                    }
                    intersectsSprite(t) {
                        return Wn.center.set(0, 0, 0), Wn.radius = .7071067811865476, Wn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Wn)
                    }
                    intersectsSphere(t) {
                        const e = this.planes,
                            n = t.center,
                            r = -t.radius;
                        for (let t = 0; t < 6; t++) {
                            if (e[t].distanceToPoint(n) < r) return !1
                        }
                        return !0
                    }
                    intersectsBox(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++) {
                            const r = e[n];
                            if (jn.x = r.normal.x > 0 ? t.max.x : t.min.x, jn.y = r.normal.y > 0 ? t.max.y : t.min.y, jn.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(jn) < 0) return !1
                        }
                        return !0
                    }
                    containsPoint(t) {
                        const e = this.planes;
                        for (let n = 0; n < 6; n++)
                            if (e[n].distanceToPoint(t) < 0) return !1;
                        return !0
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }

                function qn() {
                    let t = null,
                        e = !1,
                        n = null,
                        r = null;

                    function i(e, s) {
                        n(e, s), r = t.requestAnimationFrame(i)
                    }
                    return {
                        start: function() {
                            !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
                        },
                        stop: function() {
                            t.cancelAnimationFrame(r), e = !1
                        },
                        setAnimationLoop: function(t) {
                            n = t
                        },
                        setContext: function(e) {
                            t = e
                        }
                    }
                }

                function Xn(t, e) {
                    const n = e.isWebGL2,
                        r = new WeakMap;

                    function i(e, r) {
                        const i = e.array,
                            s = e.usage,
                            o = t.createBuffer();
                        t.bindBuffer(r, o), t.bufferData(r, i, s), e.onUploadCallback();
                        let a = 5126;
                        return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : (i instanceof Uint8Array || i instanceof Uint8ClampedArray) && (a = 5121), {
                            buffer: o,
                            type: a,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: e.version
                        }
                    }

                    function s(e, r, i) {
                        const s = r.array,
                            o = r.updateRange;
                        t.bindBuffer(i, e), -1 === o.count ? t.bufferSubData(i, 0, s) : (n ? t.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                    }
                    return {get: function(t) {
                            return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
                        },
                        remove: function(e) {
                            e.isInterleavedBufferAttribute && (e = e.data);
                            const n = r.get(e);
                            n && (t.deleteBuffer(n.buffer), r.delete(e))
                        },
                        update: function(t, e) {
                            if (t.isGLBufferAttribute) {
                                const e = r.get(t);
                                return void((!e || e.version < t.version) && r.set(t, {
                                    buffer: t.buffer,
                                    type: t.type,
                                    bytesPerElement: t.elementSize,
                                    version: t.version
                                }))
                            }
                            t.isInterleavedBufferAttribute && (t = t.data);
                            const n = r.get(t);
                            void 0 === n ? r.set(t, i(t, e)) : n.version < t.version && (s(n.buffer, t, e), n.version = t.version)
                        }
                    }
                }
                class Yn extends un {
                    constructor(t = 1, e = 1, n = 1, r = 1) {
                        super(), this.type = "PlaneGeometry", this.parameters = {
                            width: t,
                            height: e,
                            widthSegments: n,
                            heightSegments: r
                        };
                        const i = t / 2,
                            s = e / 2,
                            o = Math.floor(n),
                            a = Math.floor(r),
                            c = o + 1,
                            l = a + 1,
                            u = t / o,
                            h = e / a,
                            d = [],
                            p = [],
                            f = [],
                            m = [];
                        for (let t = 0; t < l; t++) {
                            const e = t * h - s;
                            for (let n = 0; n < c; n++) {
                                const r = n * u - i;
                                p.push(r, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a)
                            }
                        }
                        for (let t = 0; t < a; t++)
                            for (let e = 0; e < o; e++) {
                                const n = e + c * t,
                                    r = e + c * (t + 1),
                                    i = e + 1 + c * (t + 1),
                                    s = e + 1 + c * t;
                                d.push(n, r, s), d.push(r, i, s)
                            }
                        this.setIndex(d), this.setAttribute("position", new en(p, 3)), this.setAttribute("normal", new en(f, 3)), this.setAttribute("uv", new en(m, 2))
                    }
                    static fromJSON(t) {
                        return new Yn(t.width, t.height, t.widthSegments, t.heightSegments)
                    }
                }
                const Jn = {
                        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                        begin_vertex: "vec3 transformed = vec3( position );",
                        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                        bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenTint * ( D * V );\n}\n#endif",
                        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenTint = sheenTint;\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif",
                        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenTint;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                        output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenTint;\n\tuniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                    },
                    Kn = {
                        common: {
                            diffuse: {
                                value: new Xe(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            uvTransform: {
                                value: new ft
                            },
                            uv2Transform: {
                                value: new ft
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaTest: {
                                value: 0
                            }
                        },
                        specularmap: {
                            specularMap: {
                                value: null
                            }
                        },
                        envmap: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            reflectivity: {
                                value: 1
                            },
                            ior: {
                                value: 1.5
                            },
                            refractionRatio: {
                                value: .98
                            },
                            maxMipLevel: {
                                value: 0
                            }
                        },
                        aomap: {
                            aoMap: {
                                value: null
                            },
                            aoMapIntensity: {
                                value: 1
                            }
                        },
                        lightmap: {
                            lightMap: {
                                value: null
                            },
                            lightMapIntensity: {
                                value: 1
                            }
                        },
                        emissivemap: {
                            emissiveMap: {
                                value: null
                            }
                        },
                        bumpmap: {
                            bumpMap: {
                                value: null
                            },
                            bumpScale: {
                                value: 1
                            }
                        },
                        normalmap: {
                            normalMap: {
                                value: null
                            },
                            normalScale: {
                                value: new pt(1, 1)
                            }
                        },
                        displacementmap: {
                            displacementMap: {
                                value: null
                            },
                            displacementScale: {
                                value: 1
                            },
                            displacementBias: {
                                value: 0
                            }
                        },
                        roughnessmap: {
                            roughnessMap: {
                                value: null
                            }
                        },
                        metalnessmap: {
                            metalnessMap: {
                                value: null
                            }
                        },
                        gradientmap: {
                            gradientMap: {
                                value: null
                            }
                        },
                        fog: {
                            fogDensity: {
                                value: 25e-5
                            },
                            fogNear: {
                                value: 1
                            },
                            fogFar: {
                                value: 2e3
                            },
                            fogColor: {
                                value: new Xe(16777215)
                            }
                        },
                        lights: {
                            ambientLightColor: {
                                value: []
                            },
                            lightProbe: {
                                value: []
                            },
                            directionalLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    color: {}
                                }
                            },
                            directionalLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            directionalShadowMap: {
                                value: []
                            },
                            directionalShadowMatrix: {
                                value: []
                            },
                            spotLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    direction: {},
                                    distance: {},
                                    coneCos: {},
                                    penumbraCos: {},
                                    decay: {}
                                }
                            },
                            spotLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {}
                                }
                            },
                            spotShadowMap: {
                                value: []
                            },
                            spotShadowMatrix: {
                                value: []
                            },
                            pointLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    decay: {},
                                    distance: {}
                                }
                            },
                            pointLightShadows: {
                                value: [],
                                properties: {
                                    shadowBias: {},
                                    shadowNormalBias: {},
                                    shadowRadius: {},
                                    shadowMapSize: {},
                                    shadowCameraNear: {},
                                    shadowCameraFar: {}
                                }
                            },
                            pointShadowMap: {
                                value: []
                            },
                            pointShadowMatrix: {
                                value: []
                            },
                            hemisphereLights: {
                                value: [],
                                properties: {
                                    direction: {},
                                    skyColor: {},
                                    groundColor: {}
                                }
                            },
                            rectAreaLights: {
                                value: [],
                                properties: {
                                    color: {},
                                    position: {},
                                    width: {},
                                    height: {}
                                }
                            },
                            ltc_1: {
                                value: null
                            },
                            ltc_2: {
                                value: null
                            }
                        },
                        points: {
                            diffuse: {
                                value: new Xe(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            size: {
                                value: 1
                            },
                            scale: {
                                value: 1
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaTest: {
                                value: 0
                            },
                            uvTransform: {
                                value: new ft
                            }
                        },
                        sprite: {
                            diffuse: {
                                value: new Xe(16777215)
                            },
                            opacity: {
                                value: 1
                            },
                            center: {
                                value: new pt(.5, .5)
                            },
                            rotation: {
                                value: 0
                            },
                            map: {
                                value: null
                            },
                            alphaMap: {
                                value: null
                            },
                            alphaTest: {
                                value: 0
                            },
                            uvTransform: {
                                value: new ft
                            }
                        }
                    },
                    Qn = {
                        basic: {
                            uniforms: In([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.fog]),
                            vertexShader: Jn.meshbasic_vert,
                            fragmentShader: Jn.meshbasic_frag
                        },
                        lambert: {
                            uniforms: In([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.fog, Kn.lights, {
                                emissive: {
                                    value: new Xe(0)
                                }
                            }]),
                            vertexShader: Jn.meshlambert_vert,
                            fragmentShader: Jn.meshlambert_frag
                        },
                        phong: {
                            uniforms: In([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.fog, Kn.lights, {
                                emissive: {
                                    value: new Xe(0)
                                },
                                specular: {
                                    value: new Xe(1118481)
                                },
                                shininess: {
                                    value: 30
                                }
                            }]),
                            vertexShader: Jn.meshphong_vert,
                            fragmentShader: Jn.meshphong_frag
                        },
                        standard: {
                            uniforms: In([Kn.common, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.roughnessmap, Kn.metalnessmap, Kn.fog, Kn.lights, {
                                emissive: {
                                    value: new Xe(0)
                                },
                                roughness: {
                                    value: 1
                                },
                                metalness: {
                                    value: 0
                                },
                                envMapIntensity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Jn.meshphysical_vert,
                            fragmentShader: Jn.meshphysical_frag
                        },
                        toon: {
                            uniforms: In([Kn.common, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.gradientmap, Kn.fog, Kn.lights, {
                                emissive: {
                                    value: new Xe(0)
                                }
                            }]),
                            vertexShader: Jn.meshtoon_vert,
                            fragmentShader: Jn.meshtoon_frag
                        },
                        matcap: {
                            uniforms: In([Kn.common, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.fog, {
                                matcap: {
                                    value: null
                                }
                            }]),
                            vertexShader: Jn.meshmatcap_vert,
                            fragmentShader: Jn.meshmatcap_frag
                        },
                        points: {
                            uniforms: In([Kn.points, Kn.fog]),
                            vertexShader: Jn.points_vert,
                            fragmentShader: Jn.points_frag
                        },
                        dashed: {
                            uniforms: In([Kn.common, Kn.fog, {
                                scale: {
                                    value: 1
                                },
                                dashSize: {
                                    value: 1
                                },
                                totalSize: {
                                    value: 2
                                }
                            }]),
                            vertexShader: Jn.linedashed_vert,
                            fragmentShader: Jn.linedashed_frag
                        },
                        depth: {
                            uniforms: In([Kn.common, Kn.displacementmap]),
                            vertexShader: Jn.depth_vert,
                            fragmentShader: Jn.depth_frag
                        },
                        normal: {
                            uniforms: In([Kn.common, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Jn.meshnormal_vert,
                            fragmentShader: Jn.meshnormal_frag
                        },
                        sprite: {
                            uniforms: In([Kn.sprite, Kn.fog]),
                            vertexShader: Jn.sprite_vert,
                            fragmentShader: Jn.sprite_frag
                        },
                        background: {
                            uniforms: {
                                uvTransform: {
                                    value: new ft
                                },
                                t2D: {
                                    value: null
                                }
                            },
                            vertexShader: Jn.background_vert,
                            fragmentShader: Jn.background_frag
                        },
                        cube: {
                            uniforms: In([Kn.envmap, {
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Jn.cube_vert,
                            fragmentShader: Jn.cube_frag
                        },
                        equirect: {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: Jn.equirect_vert,
                            fragmentShader: Jn.equirect_frag
                        },
                        distanceRGBA: {
                            uniforms: In([Kn.common, Kn.displacementmap, {
                                referencePosition: {
                                    value: new Et
                                },
                                nearDistance: {
                                    value: 1
                                },
                                farDistance: {
                                    value: 1e3
                                }
                            }]),
                            vertexShader: Jn.distanceRGBA_vert,
                            fragmentShader: Jn.distanceRGBA_frag
                        },
                        shadow: {
                            uniforms: In([Kn.lights, Kn.fog, {
                                color: {
                                    value: new Xe(0)
                                },
                                opacity: {
                                    value: 1
                                }
                            }]),
                            vertexShader: Jn.shadow_vert,
                            fragmentShader: Jn.shadow_frag
                        }
                    };

                function $n(t, e, n, r, i) {
                    const s = new Xe(0);
                    let o, a, c = 0,
                        l = null,
                        u = 0,
                        h = null;

                    function d(t, e) {
                        n.buffers.color.setClear(t.r, t.g, t.b, e, i)
                    }
                    return {
                        getClearColor: function() {
                            return s
                        },
                        setClearColor: function(t, e = 1) {
                            s.set(t), c = e, d(s, c)
                        },
                        getClearAlpha: function() {
                            return c
                        },
                        setClearAlpha: function(t) {
                            c = t, d(s, c)
                        },
                        render: function(n, i) {
                            let p = !1,
                                f = !0 === i.isScene ? i.background : null;
                            f && f.isTexture && (f = e.get(f));
                            const m = t.xr,
                                g = m.getSession && m.getSession();
                            g && "additive" === g.environmentBlendMode && (f = null), null === f ? d(s, c) : f && f.isColor && (d(f, 1), p = !0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), f && (f.isCubeTexture || 306 === f.mapping) ? (void 0 === a && (a = new Ln(new Pn(1, 1, 1), new On({
                                name: "BackgroundCubeMaterial",
                                uniforms: Cn(Qn.cube.uniforms),
                                vertexShader: Qn.cube.vertexShader,
                                fragmentShader: Qn.cube.fragmentShader,
                                side: 1,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }, Object.defineProperty(a.material, "envMap", {get: function() {
                                    return this.uniforms.envMap.value
                                }
                            }), r.update(a)), a.material.uniforms.envMap.value = f, a.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, l === f && u === f.version && h === t.toneMapping || (a.material.needsUpdate = !0, l = f, u = f.version, h = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Ln(new Yn(2, 2), new On({
                                name: "BackgroundMaterial",
                                uniforms: Cn(Qn.background.uniforms),
                                vertexShader: Qn.background.vertexShader,
                                fragmentShader: Qn.background.fragmentShader,
                                side: _,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {get: function() {
                                    return this.uniforms.t2D.value
                                }
                            }), r.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), l === f && u === f.version && h === t.toneMapping || (o.material.needsUpdate = !0, l = f, u = f.version, h = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                        }
                    }
                }

                function tr(t, e, n, r) {
                    const i = t.getParameter(34921),
                        s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                        o = r.isWebGL2 || null !== s,
                        a = {},
                        c = f(null);
                    let l = c;

                    function u() {
                        return r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
                    }

                    function h(e) {
                        return r.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
                    }

                    function d(e) {
                        return r.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
                    }

                    function p(t, e, n) {
                        const r = !0 === n.wireframe;
                        let i = a[t.id];
                        void 0 === i && (i = {}, a[t.id] = i);
                        let s = i[e.id];
                        void 0 === s && (s = {}, i[e.id] = s);
                        let o = s[r];
                        return void 0 === o && (o = f(u()), s[r] = o), o
                    }

                    function f(t) {
                        const e = [],
                            n = [],
                            r = [];
                        for (let t = 0; t < i; t++) e[t] = 0, n[t] = 0, r[t] = 0;
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: e,
                            enabledAttributes: n,
                            attributeDivisors: r,
                            object: t,
                            attributes: {},
                            index: null
                        }
                    }

                    function m() {
                        const t = l.newAttributes;
                        for (let e = 0, n = t.length; e < n; e++) t[e] = 0
                    }

                    function g(t) {
                        v(t, 0)
                    }

                    function v(n, i) {
                        const s = l.newAttributes,
                            o = l.enabledAttributes,
                            a = l.attributeDivisors;
                        if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== i) {
                            (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), a[n] = i
                        }
                    }

                    function y() {
                        const e = l.newAttributes,
                            n = l.enabledAttributes;
                        for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
                    }

                    function x(e, n, i, s, o, a) {
                        !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, s, o, a) : t.vertexAttribIPointer(e, n, i, o, a)
                    }

                    function _(i, s, o, a) {
                        if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                        m();
                        const c = a.attributes,
                            l = o.getAttributes(),
                            u = s.defaultAttributeValues;
                        for (const e in l) {
                            const r = l[e];
                            if (r.location >= 0) {
                                let s = c[e];
                                if (void 0 === s && ("instanceMatrix" === e && i.instanceMatrix && (s = i.instanceMatrix), "instanceColor" === e && i.instanceColor && (s = i.instanceColor)), void 0 !== s) {
                                    const e = s.normalized,
                                        o = s.itemSize,
                                        c = n.get(s);
                                    if (void 0 === c) continue;
                                    const l = c.buffer,
                                        u = c.type,
                                        h = c.bytesPerElement;
                                    if (s.isInterleavedBufferAttribute) {
                                        const n = s.data,
                                            c = n.stride,
                                            d = s.offset;
                                        if (n && n.isInstancedInterleavedBuffer) {
                                            for (let t = 0; t < r.locationSize; t++) v(r.location + t, n.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)
                                        } else
                                            for (let t = 0; t < r.locationSize; t++) g(r.location + t);
                                        t.bindBuffer(34962, l);
                                        for (let t = 0; t < r.locationSize; t++) x(r.location + t, o / r.locationSize, u, e, c * h, (d + o / r.locationSize * t) * h)
                                    } else {
                                        if (s.isInstancedBufferAttribute) {
                                            for (let t = 0; t < r.locationSize; t++) v(r.location + t, s.meshPerAttribute);
                                            !0 !== i.isInstancedMesh && void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)
                                        } else
                                            for (let t = 0; t < r.locationSize; t++) g(r.location + t);
                                        t.bindBuffer(34962, l);
                                        for (let t = 0; t < r.locationSize; t++) x(r.location + t, o / r.locationSize, u, e, o * h, o / r.locationSize * t * h)
                                    }
                                } else if (void 0 !== u) {
                                    const n = u[e];
                                    if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            t.vertexAttrib2fv(r.location, n);
                                            break;
                                        case 3:
                                            t.vertexAttrib3fv(r.location, n);
                                            break;
                                        case 4:
                                            t.vertexAttrib4fv(r.location, n);
                                            break;
                                        default:
                                            t.vertexAttrib1fv(r.location, n)
                                    }
                                }
                            }
                        }
                        y()
                    }

                    function b() {
                        w(), l !== c && (l = c, h(l.object))
                    }

                    function w() {
                        c.geometry = null, c.program = null, c.wireframe = !1
                    }
                    return {
                        setup: function(e, r, i, s, a) {
                            let c = !1;
                            if (o) {
                                const t = p(s, i, r);
                                l !== t && (l = t, h(l.object)), c = function(t, e) {
                                    const n = l.attributes,
                                        r = t.attributes;
                                    let i = 0;
                                    for (const t in r) {
                                        const e = n[t],
                                            s = r[t];
                                        if (void 0 === e) return !0;
                                        if (e.attribute !== s) return !0;
                                        if (e.data !== s.data) return !0;
                                        i++
                                    }
                                    return l.attributesNum !== i || l.index !== e
                                }(s, a), c && function(t, e) {
                                    const n = {},
                                        r = t.attributes;
                                    let i = 0;
                                    for (const t in r) {
                                        const e = r[t],
                                            s = {};
                                        s.attribute = e, e.data && (s.data = e.data), n[t] = s, i++
                                    }
                                    l.attributes = n, l.attributesNum = i, l.index = e
                                }(s, a)
                            } else {
                                const t = !0 === r.wireframe;
                                l.geometry === s.id && l.program === i.id && l.wireframe === t || (l.geometry = s.id, l.program = i.id, l.wireframe = t, c = !0)
                            }!0 === e.isInstancedMesh && (c = !0), null !== a && n.update(a, 34963), c && (_(e, r, i, s), null !== a && t.bindBuffer(34963, n.get(a).buffer))
                        },
                        reset: b,
                        resetDefaultState: w,
                        dispose: function() {
                            b();
                            for (const t in a) {
                                const e = a[t];
                                for (const t in e) {
                                    const n = e[t];
                                    for (const t in n) d(n[t].object), delete n[t];
                                    delete e[t]
                                }
                                delete a[t]
                            }
                        },
                        releaseStatesOfGeometry: function(t) {
                            if (void 0 === a[t.id]) return;
                            const e = a[t.id];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) d(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete a[t.id]
                        },
                        releaseStatesOfProgram: function(t) {
                            for (const e in a) {
                                const n = a[e];
                                if (void 0 === n[t.id]) continue;
                                const r = n[t.id];
                                for (const t in r) d(r[t].object), delete r[t];
                                delete n[t.id]
                            }
                        },
                        initAttributes: m,
                        enableAttribute: g,
                        disableUnusedAttributes: y
                    }
                }

                function er(t, e, n, r) {
                    const i = r.isWebGL2;
                    let s;
                    this.setMode = function(t) {
                        s = t
                    }, this.render = function(e, r) {
                        t.drawArrays(s, e, r), n.update(r, s, 1)
                    }, this.renderInstances = function(r, o, a) {
                        if (0 === a) return;
                        let c, l;
                        if (i) c = t, l = "drawArraysInstanced";
                        else if (c = e.get("ANGLE_instanced_arrays"), l = "drawArraysInstancedANGLE", null === c) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        c[l](s, r, o, a), n.update(o, s, a)
                    }
                }

                function nr(t, e, n) {
                    let r;

                    function i(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                    }
                    const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                    let o = void 0 !== n.precision ? n.precision : "highp";
                    const a = i(o);
                    a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                    const c = s || e.has("WEBGL_draw_buffers"),
                        l = !0 === n.logarithmicDepthBuffer,
                        u = t.getParameter(34930),
                        h = t.getParameter(35660),
                        d = t.getParameter(3379),
                        p = t.getParameter(34076),
                        f = t.getParameter(34921),
                        m = t.getParameter(36347),
                        g = t.getParameter(36348),
                        v = t.getParameter(36349),
                        y = h > 0,
                        x = s || e.has("OES_texture_float");
                    return {
                        isWebGL2: s,
                        drawBuffers: c,
                        getMaxAnisotropy: function() {
                            if (void 0 !== r) return r;
                            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                                const n = e.get("EXT_texture_filter_anisotropic");
                                r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                            } else r = 0;
                            return r
                        },
                        getMaxPrecision: i,
                        precision: o,
                        logarithmicDepthBuffer: l,
                        maxTextures: u,
                        maxVertexTextures: h,
                        maxTextureSize: d,
                        maxCubemapSize: p,
                        maxAttributes: f,
                        maxVertexUniforms: m,
                        maxVaryings: g,
                        maxFragmentUniforms: v,
                        vertexTextures: y,
                        floatFragmentTextures: x,
                        floatVertexTextures: y && x,
                        maxSamples: s ? t.getParameter(36183) : 0
                    }
                }

                function rr(t) {
                    const e = this;
                    let n = null,
                        r = 0,
                        i = !1,
                        s = !1;
                    const o = new Vn,
                        a = new ft,
                        c = {
                            value: null,
                            needsUpdate: !1
                        };

                    function l() {
                        c.value !== n && (c.value = n, c.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
                    }

                    function u(t, n, r, i) {
                        const s = null !== t ? t.length : 0;
                        let l = null;
                        if (0 !== s) {
                            if (l = c.value, !0 !== i || null === l) {
                                const e = r + 4 * s,
                                    i = n.matrixWorldInverse;
                                a.getNormalMatrix(i), (null === l || l.length < e) && (l = new Float32Array(e));
                                for (let e = 0, n = r; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(i, a), o.normal.toArray(l, n), l[n + 3] = o.constant
                            }
                            c.value = l, c.needsUpdate = !0
                        }
                        return e.numPlanes = s, e.numIntersection = 0, l
                    }
                    this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) {
                        const o = 0 !== t.length || e || 0 !== r || i;
                        return i = e, n = u(t, s, 0), r = t.length, o
                    }, this.beginShadows = function() {
                        s = !0, u(null)
                    }, this.endShadows = function() {
                        s = !1, l()
                    }, this.setState = function(e, o, a) {
                        const h = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            f = t.get(e);
                        if (!i || null === h || 0 === h.length || s && !p) s ? u(null) : l();
                        else {
                            const t = s ? 0 : r,
                                e = 4 * t;
                            let i = f.clippingState || null;
                            c.value = i, i = u(h, o, e, a);
                            for (let t = 0; t !== e; ++t) i[t] = n[t];
                            f.clippingState = i, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                        }
                    }
                }

                function ir(t) {
                    let e = new WeakMap;

                    function n(t, e) {
                        return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t
                    }

                    function r(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", r);
                        const i = e.get(n);
                        void 0 !== i && (e.delete(n), i.dispose())
                    }
                    return {get: function(i) {
                            if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                                const s = i.mapping;
                                if (303 === s || 304 === s) {
                                    if (e.has(i)) {
                                        return n(e.get(i).texture, i.mapping)
                                    } {
                                        const s = i.image;
                                        if (s && s.height > 0) {
                                            const o = t.getRenderTarget(),
                                                a = new kn(s.height / 2);
                                            return a.fromEquirectangularTexture(t, i), e.set(i, a), t.setRenderTarget(o), i.addEventListener("dispose", r), n(a.texture, i.mapping)
                                        }
                                        return null
                                    }
                                }
                            }
                            return i
                        },
                        dispose: function() {
                            e = new WeakMap
                        }
                    }
                }
                Qn.physical = {
                    uniforms: In([Qn.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatNormalScale: {
                            value: new pt(1, 1)
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        sheen: {
                            value: 0
                        },
                        sheenTint: {
                            value: new Xe(0)
                        },
                        sheenRoughness: {
                            value: 0
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionSamplerSize: {
                            value: new pt
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationTint: {
                            value: new Xe(0)
                        },
                        specularIntensity: {
                            value: 0
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularTint: {
                            value: new Xe(1, 1, 1)
                        },
                        specularTintMap: {
                            value: null
                        }
                    }]),
                    vertexShader: Jn.meshphysical_vert,
                    fragmentShader: Jn.meshphysical_frag
                };
                class sr extends Nn {
                    constructor(t = -1, e = 1, n = 1, r = -1, i = .1, s = 2e3) {
                        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix()
                    }
                    copy(t, e) {
                        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                    }
                    setViewOffset(t, e, n, r, i, s) {
                        null === this.view && (this.view = {
                            enabled: !0,
                            fullWidth: 1,
                            fullHeight: 1,
                            offsetX: 0,
                            offsetY: 0,
                            width: 1,
                            height: 1
                        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const t = (this.right - this.left) / (2 * this.zoom),
                            e = (this.top - this.bottom) / (2 * this.zoom),
                            n = (this.right + this.left) / 2,
                            r = (this.top + this.bottom) / 2;
                        let i = n - t,
                            s = n + t,
                            o = r + e,
                            a = r - e;
                        if (null !== this.view && this.view.enabled) {
                            const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            i += t * this.view.offsetX, s = i + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(i, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                    }
                }
                sr.prototype.isOrthographicCamera = !0;
                class or extends On {
                    constructor(t) {
                        super(t), this.type = "RawShaderMaterial"
                    }
                }
                or.prototype.isRawShaderMaterial = !0;
                const ar = Math.pow(2, 8),
                    cr = [.125, .215, .35, .446, .526, .582],
                    lr = 5 + cr.length,
                    ur = {
                        [X]: 0, [Y]: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6
                    },
                    hr = new sr,
                    {
                        _lodPlanes: dr,
                        _sizeLods: pr,
                        _sigmas: fr
                    } = function() {
                        const t = [],
                            e = [],
                            n = [];
                        let r = 8;
                        for (let i = 0; i < lr; i++) {
                            const s = Math.pow(2, r);
                            e.push(s);
                            let o = 1 / s;
                            i > 4 ? o = cr[i - 8 + 4 - 1] : 0 == i && (o = 0), n.push(o);
                            const a = 1 / (s - 1),
                                c = -a / 2,
                                l = 1 + a / 2,
                                u = [c, c, l, c, l, l, c, c, l, l, c, l],
                                h = 6,
                                d = 6,
                                p = 3,
                                f = 2,
                                m = 1,
                                g = new Float32Array(p * d * h),
                                v = new Float32Array(f * d * h),
                                y = new Float32Array(m * d * h);
                            for (let t = 0; t < h; t++) {
                                const e = t % 3 * 2 / 3 - 1,
                                    n = t > 2 ? 0 : -1,
                                    r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                                g.set(r, p * d * t), v.set(u, f * d * t);
                                const i = [t, t, t, t, t, t];
                                y.set(i, m * d * t)
                            }
                            const x = new un;
                            x.setAttribute("position", new Qe(g, p)), x.setAttribute("uv", new Qe(v, f)), x.setAttribute("faceIndex", new Qe(y, m)), t.push(x), r > 4 && r--
                        }
                        return {
                            _lodPlanes: t,
                            _sizeLods: e,
                            _sigmas: n
                        }
                    }(),
                    mr = new Xe;
                let gr = null;
                const vr = (1 + Math.sqrt(5)) / 2,
                    yr = 1 / vr,
                    xr = [new Et(1, 1, 1), new Et(-1, 1, 1), new Et(1, 1, -1), new Et(-1, 1, -1), new Et(0, vr, yr), new Et(0, vr, -yr), new Et(yr, 0, vr), new Et(-yr, 0, vr), new Et(vr, yr, 0), new Et(-vr, yr, 0)];
                class _r {
                    constructor(t) {
                        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
                            const e = new Float32Array(t),
                                n = new Et(0, 1, 0);
                            return new or({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: t
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: e
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: n
                                    },
                                    inputEncoding: {
                                        value: ur[X]
                                    },
                                    outputEncoding: {
                                        value: ur[X]
                                    }
                                },
                                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            })
                        }(20), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(t, e = 0, n = .1, r = 100) {
                        gr = this._renderer.getRenderTarget();
                        const i = this._allocateTargets();
                        return this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i
                    }
                    fromEquirectangular(t) {
                        return this._fromTexture(t)
                    }
                    fromCubemap(t) {
                        return this._fromTexture(t)
                    }
                    compileCubemapShader() {
                        null === this._cubemapShader && (this._cubemapShader = Tr(), this._compileMaterial(this._cubemapShader))
                    }
                    compileEquirectangularShader() {
                        null === this._equirectShader && (this._equirectShader = Sr(), this._compileMaterial(this._equirectShader))
                    }
                    dispose() {
                        this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                        for (let t = 0; t < dr.length; t++) dr[t].dispose()
                    }
                    _cleanup(t) {
                        this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(gr), t.scissorTest = !1, Mr(t, 0, 0, t.width, t.height)
                    }
                    _fromTexture(t) {
                        gr = this._renderer.getRenderTarget();
                        const e = this._allocateTargets(t);
                        return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
                    }
                    _allocateTargets(t) {
                        const e = {
                                magFilter: E,
                                minFilter: E,
                                generateMipmaps: !1,
                                type: I,
                                format: 1023,
                                encoding: br(t) ? t.encoding : 3002,
                                depthBuffer: !1
                            },
                            n = wr(e);
                        return n.depthBuffer = !t, this._pingPongRenderTarget = wr(e), n
                    }
                    _compileMaterial(t) {
                        const e = new Ln(dr[0], t);
                        this._renderer.compile(e, hr)
                    }
                    _sceneToCubeUV(t, e, n, r) {
                        const i = new Bn(90, 1, e, n),
                            s = [1, -1, 1, 1, 1, 1],
                            o = [1, 1, 1, -1, -1, -1],
                            a = this._renderer,
                            c = a.autoClear,
                            l = a.outputEncoding,
                            u = a.toneMapping;
                        a.getClearColor(mr), a.toneMapping = 0, a.outputEncoding = X, a.autoClear = !1;
                        const h = new Ye({
                                name: "PMREM.Background",
                                side: 1,
                                depthWrite: !1,
                                depthTest: !1
                            }),
                            d = new Ln(new Pn, h);
                        let p = !1;
                        const f = t.background;
                        f ? f.isColor && (h.color.copy(f), t.background = null, p = !0) : (h.color.copy(mr), p = !0);
                        for (let e = 0; e < 6; e++) {
                            const n = e % 3;
                            0 == n ? (i.up.set(0, s[e], 0), i.lookAt(o[e], 0, 0)) : 1 == n ? (i.up.set(0, 0, s[e]), i.lookAt(0, o[e], 0)) : (i.up.set(0, s[e], 0), i.lookAt(0, 0, o[e])), Mr(r, n * ar, e > 2 ? ar : 0, ar, ar), a.setRenderTarget(r), p && a.render(d, i), a.render(t, i)
                        }
                        d.geometry.dispose(), d.material.dispose(), a.toneMapping = u, a.outputEncoding = l, a.autoClear = c, t.background = f
                    }
                    _setEncoding(t, e) {
                        !0 === this._renderer.capabilities.isWebGL2 && e.format === z && e.type === I && e.encoding === Y ? t.value = ur[X] : t.value = ur[e.encoding]
                    }
                    _textureToCubeUV(t, e) {
                        const n = this._renderer;
                        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Tr()) : null == this._equirectShader && (this._equirectShader = Sr());
                        const r = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                            i = new Ln(dr[0], r),
                            s = r.uniforms;
                        s.envMap.value = t, t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height), this._setEncoding(s.inputEncoding, t), this._setEncoding(s.outputEncoding, e.texture), Mr(e, 0, 0, 3 * ar, 2 * ar), n.setRenderTarget(e), n.render(i, hr)
                    }
                    _applyPMREM(t) {
                        const e = this._renderer,
                            n = e.autoClear;
                        e.autoClear = !1;
                        for (let e = 1; e < lr; e++) {
                            const n = Math.sqrt(fr[e] * fr[e] - fr[e - 1] * fr[e - 1]),
                                r = xr[(e - 1) % xr.length];
                            this._blur(t, e - 1, e, n, r)
                        }
                        e.autoClear = n
                    }
                    _blur(t, e, n, r, i) {
                        const s = this._pingPongRenderTarget;
                        this._halfBlur(t, s, e, n, r, "latitudinal", i), this._halfBlur(s, t, n, n, r, "longitudinal", i)
                    }
                    _halfBlur(t, e, n, r, i, s, o) {
                        const a = this._renderer,
                            c = this._blurMaterial;
                        "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                        const l = new Ln(dr[r], c),
                            u = c.uniforms,
                            h = pr[n] - 1,
                            d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                            p = i / d,
                            f = isFinite(i) ? 1 + Math.floor(3 * p) : 20;
                        f > 20 && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                        const m = [];
                        let g = 0;
                        for (let t = 0; t < 20; ++t) {
                            const e = t / p,
                                n = Math.exp(-e * e / 2);
                            m.push(n), 0 == t ? g += n : t < f && (g += 2 * n)
                        }
                        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
                        u.envMap.value = t.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, o && (u.poleAxis.value = o), u.dTheta.value = d, u.mipInt.value = 8 - n, this._setEncoding(u.inputEncoding, t.texture), this._setEncoding(u.outputEncoding, t.texture);
                        const v = pr[r];
                        Mr(e, 3 * Math.max(0, ar - 2 * v), (0 === r ? 0 : 2 * ar) + 2 * v * (r > 4 ? r - 8 + 4 : 0), 3 * v, 2 * v), a.setRenderTarget(e), a.render(l, hr)
                    }
                }

                function br(t) {
                    return void 0 !== t && t.type === I && (t.encoding === X || t.encoding === Y || 3007 === t.encoding)
                }

                function wr(t) {
                    const e = new Mt(3 * ar, 3 * ar, t);
                    return e.texture.mapping = 306, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
                }

                function Mr(t, e, n, r, i) {
                    t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
                }

                function Sr() {
                    const t = new pt(1, 1);
                    return new or({
                        name: "EquirectangularToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            texelSize: {
                                value: t
                            },
                            inputEncoding: {
                                value: ur[X]
                            },
                            outputEncoding: {
                                value: ur[X]
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function Tr() {
                    return new or({
                        name: "CubemapToCubeUV",
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            inputEncoding: {
                                value: ur[X]
                            },
                            outputEncoding: {
                                value: ur[X]
                            }
                        },
                        vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function Er(t) {
                    let e = new WeakMap,
                        n = null;

                    function r(t) {
                        const n = t.target;
                        n.removeEventListener("dispose", r);
                        const i = e.get(n);
                        void 0 !== i && (e.delete(n), i.dispose())
                    }
                    return {get: function(i) {
                            if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                                const s = i.mapping,
                                    o = 303 === s || 304 === s,
                                    a = 301 === s || 302 === s;
                                if (o || a) {
                                    if (e.has(i)) return e.get(i).texture; {
                                        const s = i.image;
                                        if (o && s && s.height > 0 || a && s && function(t) {
                                                let e = 0;
                                                for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                                return 6 === e
                                            }(s)) {
                                            const s = t.getRenderTarget();
                                            null === n && (n = new _r(t));
                                            const a = o ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                            return e.set(i, a), t.setRenderTarget(s), i.addEventListener("dispose", r), a.texture
                                        }
                                        return null
                                    }
                                }
                            }
                            return i
                        },
                        dispose: function() {
                            e = new WeakMap, null !== n && (n.dispose(), n = null)
                        }
                    }
                }

                function Ar(t) {
                    const e = Object.assign({}, g || {});

                    function n(n) {
                        if (void 0 !== e[n]) return e[n];
                        let r;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                r = t.getExtension(n)
                        }
                        return e[n] = r, r
                    }
                    return {
                        has: function(t) {
                            return null !== n(t)
                        },
                        init: function(t) {
                            t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
                        },
                        get: function(t) {
                            const e = n(t) || null;
                            return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                        }
                    }
                }

                function Lr(t, e, n, r) {
                    const i = {},
                        s = new WeakMap;

                    function o(t) {
                        const a = t.target;
                        null !== a.index && e.remove(a.index);
                        for (const t in a.attributes) e.remove(a.attributes[t]);
                        a.removeEventListener("dispose", o), delete i[a.id];
                        const c = s.get(a);
                        c && (e.remove(c), s.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                    }

                    function a(t) {
                        const n = [],
                            r = t.index,
                            i = t.attributes.position;
                        let o = 0;
                        if (null !== r) {
                            const t = r.array;
                            o = r.version;
                            for (let e = 0, r = t.length; e < r; e += 3) {
                                const r = t[e + 0],
                                    i = t[e + 1],
                                    s = t[e + 2];
                                n.push(r, i, i, s, s, r)
                            }
                        } else {
                            const t = i.array;
                            o = i.version;
                            for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                                const t = e + 0,
                                    r = e + 1,
                                    i = e + 2;
                                n.push(t, r, r, i, i, t)
                            }
                        }
                        const a = new(mt(n) > 65535 ? tn : $e)(n, 1);
                        a.version = o;
                        const c = s.get(t);
                        c && e.remove(c), s.set(t, a)
                    }
                    return {get: function(t, e) {
                            return !0 === i[e.id] || (e.addEventListener("dispose", o), i[e.id] = !0, n.memory.geometries++), e
                        },
                        update: function(t) {
                            const n = t.attributes;
                            for (const t in n) e.update(n[t], 34962);
                            const r = t.morphAttributes;
                            for (const t in r) {
                                const n = r[t];
                                for (let t = 0, r = n.length; t < r; t++) e.update(n[t], 34962)
                            }
                        },
                        getWireframeAttribute: function(t) {
                            const e = s.get(t);
                            if (e) {
                                const n = t.index;
                                null !== n && e.version < n.version && a(t)
                            } else a(t);
                            return s.get(t)
                        }
                    }
                }

                function Rr(t, e, n, r) {
                    const i = r.isWebGL2;
                    let s, o, a;
                    this.setMode = function(t) {
                        s = t
                    }, this.setIndex = function(t) {
                        o = t.type, a = t.bytesPerElement
                    }, this.render = function(e, r) {
                        t.drawElements(s, r, o, e * a), n.update(r, s, 1)
                    }, this.renderInstances = function(r, c, l) {
                        if (0 === l) return;
                        let u, h;
                        if (i) u = t, h = "drawElementsInstanced";
                        else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        u[h](s, c, o, r * a, l), n.update(c, s, l)
                    }
                }

                function Pr(t) {
                    const e = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                    return {
                        memory: {
                            geometries: 0,
                            textures: 0
                        },
                        render: e,
                        programs: null,
                        autoReset: !0,
                        reset: function() {
                            e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                        },
                        update: function(t, n, r) {
                            switch (e.calls++, n) {
                                case 4:
                                    e.triangles += r * (t / 3);
                                    break;
                                case 1:
                                    e.lines += r * (t / 2);
                                    break;
                                case 3:
                                    e.lines += r * (t - 1);
                                    break;
                                case 2:
                                    e.lines += r * t;
                                    break;
                                case 0:
                                    e.points += r * t;
                                    break;
                                default:
                                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                            }
                        }
                    }
                }
                class Cr extends _t {
                    constructor(t = null, e = 1, n = 1, r = 1) {
                        super(null), this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: r
                        }, this.magFilter = E, this.minFilter = E, this.wrapR = S, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                    }
                }

                function Ir(t, e) {
                    return t[0] - e[0]
                }

                function Dr(t, e) {
                    return Math.abs(e[1]) - Math.abs(t[1])
                }

                function Or(t, e) {
                    let n = 1;
                    const r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
                    r instanceof Int8Array ? n = 127 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), t.divideScalar(n)
                }

                function Nr(t, e, n) {
                    const r = {},
                        i = new Float32Array(8),
                        s = new WeakMap,
                        o = new Et,
                        a = [];
                    for (let t = 0; t < 8; t++) a[t] = [t, 0];
                    return {
                        update: function(c, l, u, h) {
                            const d = c.morphTargetInfluences;
                            if (!0 === e.isWebGL2) {
                                const r = l.morphAttributes.position.length;
                                let i = s.get(l);
                                if (void 0 === i || i.count !== r) {
                                    void 0 !== i && i.texture.dispose();
                                    const t = void 0 !== l.morphAttributes.normal,
                                        n = l.morphAttributes.position,
                                        a = l.morphAttributes.normal || [],
                                        c = !0 === t ? 2 : 1;
                                    let u = l.attributes.position.count * c,
                                        h = 1;
                                    u > e.maxTextureSize && (h = Math.ceil(u / e.maxTextureSize), u = e.maxTextureSize);
                                    const d = new Float32Array(u * h * 4 * r),
                                        p = new Cr(d, u, h, r);
                                    p.format = z, p.type = D;
                                    const f = 4 * c;
                                    for (let e = 0; e < r; e++) {
                                        const r = n[e],
                                            i = a[e],
                                            s = u * h * 4 * e;
                                        for (let e = 0; e < r.count; e++) {
                                            o.fromBufferAttribute(r, e), !0 === r.normalized && Or(o, r);
                                            const n = e * f;
                                            d[s + n + 0] = o.x, d[s + n + 1] = o.y, d[s + n + 2] = o.z, d[s + n + 3] = 0, !0 === t && (o.fromBufferAttribute(i, e), !0 === i.normalized && Or(o, i), d[s + n + 4] = o.x, d[s + n + 5] = o.y, d[s + n + 6] = o.z, d[s + n + 7] = 0)
                                        }
                                    }
                                    i = {
                                        count: r,
                                        texture: p,
                                        size: new pt(u, h)
                                    }, s.set(l, i)
                                }
                                let a = 0;
                                for (let t = 0; t < d.length; t++) a += d[t];
                                const c = l.morphTargetsRelative ? 1 : 1 - a;
                                h.getUniforms().setValue(t, "morphTargetBaseInfluence", c), h.getUniforms().setValue(t, "morphTargetInfluences", d), h.getUniforms().setValue(t, "morphTargetsTexture", i.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", i.size)
                            } else {
                                const e = void 0 === d ? 0 : d.length;
                                let n = r[l.id];
                                if (void 0 === n || n.length !== e) {
                                    n = [];
                                    for (let t = 0; t < e; t++) n[t] = [t, 0];
                                    r[l.id] = n
                                }
                                for (let t = 0; t < e; t++) {
                                    const e = n[t];
                                    e[0] = t, e[1] = d[t]
                                }
                                n.sort(Dr);
                                for (let t = 0; t < 8; t++) t < e && n[t][1] ? (a[t][0] = n[t][0], a[t][1] = n[t][1]) : (a[t][0] = Number.MAX_SAFE_INTEGER, a[t][1] = 0);
                                a.sort(Ir);
                                const s = l.morphAttributes.position,
                                    o = l.morphAttributes.normal;
                                let c = 0;
                                for (let t = 0; t < 8; t++) {
                                    const e = a[t],
                                        n = e[0],
                                        r = e[1];
                                    n !== Number.MAX_SAFE_INTEGER && r ? (s && l.getAttribute("morphTarget" + t) !== s[n] && l.setAttribute("morphTarget" + t, s[n]), o && l.getAttribute("morphNormal" + t) !== o[n] && l.setAttribute("morphNormal" + t, o[n]), i[t] = r, c += r) : (s && !0 === l.hasAttribute("morphTarget" + t) && l.deleteAttribute("morphTarget" + t), o && !0 === l.hasAttribute("morphNormal" + t) && l.deleteAttribute("morphNormal" + t), i[t] = 0)
                                }
                                const u = l.morphTargetsRelative ? 1 : 1 - c;
                                h.getUniforms().setValue(t, "morphTargetBaseInfluence", u), h.getUniforms().setValue(t, "morphTargetInfluences", i)
                            }
                        }
                    }
                }

                function Br(t, e, n, r) {
                    let i = new WeakMap;

                    function s(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                    }
                    return {
                        update: function(t) {
                            const o = r.render.frame,
                                a = t.geometry,
                                c = e.get(t, a);
                            return i.get(c) !== o && (e.update(c), i.set(c, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), c
                        },
                        dispose: function() {
                            i = new WeakMap
                        }
                    }
                }
                Cr.prototype.isDataTexture2DArray = !0;
                class zr extends _t {
                    constructor(t = null, e = 1, n = 1, r = 1) {
                        super(null), this.image = {
                            data: t,
                            width: e,
                            height: n,
                            depth: r
                        }, this.magFilter = E, this.minFilter = E, this.wrapR = S, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                    }
                }
                zr.prototype.isDataTexture3D = !0;
                const Fr = new _t,
                    kr = new Cr,
                    Ur = new zr,
                    Hr = new Fn,
                    Gr = [],
                    Vr = [],
                    Wr = new Float32Array(16),
                    jr = new Float32Array(9),
                    Zr = new Float32Array(4);

                function qr(t, e, n) {
                    const r = t[0];
                    if (r <= 0 || r > 0) return t;
                    const i = e * n;
                    let s = Gr[i];
                    if (void 0 === s && (s = new Float32Array(i), Gr[i] = s), 0 !== e) {
                        r.toArray(s, 0);
                        for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(s, i)
                    }
                    return s
                }

                function Xr(t, e) {
                    if (t.length !== e.length) return !1;
                    for (let n = 0, r = t.length; n < r; n++)
                        if (t[n] !== e[n]) return !1;
                    return !0
                }

                function Yr(t, e) {
                    for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
                }

                function Jr(t, e) {
                    let n = Vr[e];
                    void 0 === n && (n = new Int32Array(e), Vr[e] = n);
                    for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
                    return n
                }

                function Kr(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
                }

                function Qr(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                    else {
                        if (Xr(n, e)) return;
                        t.uniform2fv(this.addr, e), Yr(n, e)
                    }
                }

                function $r(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                    else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                    else {
                        if (Xr(n, e)) return;
                        t.uniform3fv(this.addr, e), Yr(n, e)
                    }
                }

                function ti(t, e) {
                    const n = this.cache;
                    if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                    else {
                        if (Xr(n, e)) return;
                        t.uniform4fv(this.addr, e), Yr(n, e)
                    }
                }

                function ei(t, e) {
                    const n = this.cache,
                        r = e.elements;
                    if (void 0 === r) {
                        if (Xr(n, e)) return;
                        t.uniformMatrix2fv(this.addr, !1, e), Yr(n, e)
                    } else {
                        if (Xr(n, r)) return;
                        Zr.set(r), t.uniformMatrix2fv(this.addr, !1, Zr), Yr(n, r)
                    }
                }

                function ni(t, e) {
                    const n = this.cache,
                        r = e.elements;
                    if (void 0 === r) {
                        if (Xr(n, e)) return;
                        t.uniformMatrix3fv(this.addr, !1, e), Yr(n, e)
                    } else {
                        if (Xr(n, r)) return;
                        jr.set(r), t.uniformMatrix3fv(this.addr, !1, jr), Yr(n, r)
                    }
                }

                function ri(t, e) {
                    const n = this.cache,
                        r = e.elements;
                    if (void 0 === r) {
                        if (Xr(n, e)) return;
                        t.uniformMatrix4fv(this.addr, !1, e), Yr(n, e)
                    } else {
                        if (Xr(n, r)) return;
                        Wr.set(r), t.uniformMatrix4fv(this.addr, !1, Wr), Yr(n, r)
                    }
                }

                function ii(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
                }

                function si(t, e) {
                    const n = this.cache;
                    Xr(n, e) || (t.uniform2iv(this.addr, e), Yr(n, e))
                }

                function oi(t, e) {
                    const n = this.cache;
                    Xr(n, e) || (t.uniform3iv(this.addr, e), Yr(n, e))
                }

                function ai(t, e) {
                    const n = this.cache;
                    Xr(n, e) || (t.uniform4iv(this.addr, e), Yr(n, e))
                }

                function ci(t, e) {
                    const n = this.cache;
                    n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
                }

                function li(t, e) {
                    const n = this.cache;
                    Xr(n, e) || (t.uniform2uiv(this.addr, e), Yr(n, e))
                }

                function ui(t, e) {
                    const n = this.cache;
                    Xr(n, e) || (t.uniform3uiv(this.addr, e), Yr(n, e))
                }

                function hi(t, e) {
                    const n = this.cache;
                    Xr(n, e) || (t.uniform4uiv(this.addr, e), Yr(n, e))
                }

                function di(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || Fr, i)
                }

                function pi(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || Ur, i)
                }

                function fi(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || Hr, i)
                }

                function mi(t, e, n) {
                    const r = this.cache,
                        i = n.allocateTextureUnit();
                    r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || kr, i)
                }

                function gi(t, e) {
                    t.uniform1fv(this.addr, e)
                }

                function vi(t, e) {
                    const n = qr(e, this.size, 2);
                    t.uniform2fv(this.addr, n)
                }

                function yi(t, e) {
                    const n = qr(e, this.size, 3);
                    t.uniform3fv(this.addr, n)
                }

                function xi(t, e) {
                    const n = qr(e, this.size, 4);
                    t.uniform4fv(this.addr, n)
                }

                function _i(t, e) {
                    const n = qr(e, this.size, 4);
                    t.uniformMatrix2fv(this.addr, !1, n)
                }

                function bi(t, e) {
                    const n = qr(e, this.size, 9);
                    t.uniformMatrix3fv(this.addr, !1, n)
                }

                function wi(t, e) {
                    const n = qr(e, this.size, 16);
                    t.uniformMatrix4fv(this.addr, !1, n)
                }

                function Mi(t, e) {
                    t.uniform1iv(this.addr, e)
                }

                function Si(t, e) {
                    t.uniform2iv(this.addr, e)
                }

                function Ti(t, e) {
                    t.uniform3iv(this.addr, e)
                }

                function Ei(t, e) {
                    t.uniform4iv(this.addr, e)
                }

                function Ai(t, e) {
                    t.uniform1uiv(this.addr, e)
                }

                function Li(t, e) {
                    t.uniform2uiv(this.addr, e)
                }

                function Ri(t, e) {
                    t.uniform3uiv(this.addr, e)
                }

                function Pi(t, e) {
                    t.uniform4uiv(this.addr, e)
                }

                function Ci(t, e, n) {
                    const r = e.length,
                        i = Jr(n, r);
                    t.uniform1iv(this.addr, i);
                    for (let t = 0; t !== r; ++t) n.safeSetTexture2D(e[t] || Fr, i[t])
                }

                function Ii(t, e, n) {
                    const r = e.length,
                        i = Jr(n, r);
                    t.uniform1iv(this.addr, i);
                    for (let t = 0; t !== r; ++t) n.safeSetTextureCube(e[t] || Hr, i[t])
                }

                function Di(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return Kr;
                            case 35664:
                                return Qr;
                            case 35665:
                                return $r;
                            case 35666:
                                return ti;
                            case 35674:
                                return ei;
                            case 35675:
                                return ni;
                            case 35676:
                                return ri;
                            case 5124:
                            case 35670:
                                return ii;
                            case 35667:
                            case 35671:
                                return si;
                            case 35668:
                            case 35672:
                                return oi;
                            case 35669:
                            case 35673:
                                return ai;
                            case 5125:
                                return ci;
                            case 36294:
                                return li;
                            case 36295:
                                return ui;
                            case 36296:
                                return hi;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return di;
                            case 35679:
                            case 36299:
                            case 36307:
                                return pi;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return fi;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return mi
                        }
                    }(e.type)
                }

                function Oi(t, e, n) {
                    this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                        switch (t) {
                            case 5126:
                                return gi;
                            case 35664:
                                return vi;
                            case 35665:
                                return yi;
                            case 35666:
                                return xi;
                            case 35674:
                                return _i;
                            case 35675:
                                return bi;
                            case 35676:
                                return wi;
                            case 5124:
                            case 35670:
                                return Mi;
                            case 35667:
                            case 35671:
                                return Si;
                            case 35668:
                            case 35672:
                                return Ti;
                            case 35669:
                            case 35673:
                                return Ei;
                            case 5125:
                                return Ai;
                            case 36294:
                                return Li;
                            case 36295:
                                return Ri;
                            case 36296:
                                return Pi;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Ci;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Ii
                        }
                    }(e.type)
                }

                function Ni(t) {
                    this.id = t, this.seq = [], this.map = {}
                }
                Oi.prototype.updateCache = function(t) {
                    const e = this.cache;
                    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Yr(e, t)
                }, Ni.prototype.setValue = function(t, e, n) {
                    const r = this.seq;
                    for (let i = 0, s = r.length; i !== s; ++i) {
                        const s = r[i];
                        s.setValue(t, e[s.id], n)
                    }
                };
                const Bi = /(\w+)(\])?(\[|\.)?/g;

                function zi(t, e) {
                    t.seq.push(e), t.map[e.id] = e
                }

                function Fi(t, e, n) {
                    const r = t.name,
                        i = r.length;
                    for (Bi.lastIndex = 0;;) {
                        const s = Bi.exec(r),
                            o = Bi.lastIndex;
                        let a = s[1];
                        const c = "]" === s[2],
                            l = s[3];
                        if (c && (a |= 0), void 0 === l || "[" === l && o + 2 === i) {
                            zi(n, void 0 === l ? new Di(a, t, e) : new Oi(a, t, e));
                            break
                        } {
                            let t = n.map[a];
                            void 0 === t && (t = new Ni(a), zi(n, t)), n = t
                        }
                    }
                }

                function ki(t, e) {
                    this.seq = [], this.map = {};
                    const n = t.getProgramParameter(e, 35718);
                    for (let r = 0; r < n; ++r) {
                        const n = t.getActiveUniform(e, r);
                        Fi(n, t.getUniformLocation(e, n.name), this)
                    }
                }

                function Ui(t, e, n) {
                    const r = t.createShader(e);
                    return t.shaderSource(r, n), t.compileShader(r), r
                }
                ki.prototype.setValue = function(t, e, n, r) {
                    const i = this.map[e];
                    void 0 !== i && i.setValue(t, n, r)
                }, ki.prototype.setOptional = function(t, e, n) {
                    const r = e[n];
                    void 0 !== r && this.setValue(t, n, r)
                }, ki.upload = function(t, e, n, r) {
                    for (let i = 0, s = e.length; i !== s; ++i) {
                        const s = e[i],
                            o = n[s.id];
                        !1 !== o.needsUpdate && s.setValue(t, o.value, r)
                    }
                }, ki.seqWithValue = function(t, e) {
                    const n = [];
                    for (let r = 0, i = t.length; r !== i; ++r) {
                        const i = t[r];
                        i.id in e && n.push(i)
                    }
                    return n
                };
                let Hi = 0;

                function Gi(t) {
                    switch (t) {
                        case X:
                            return ["Linear", "( value )"];
                        case Y:
                            return ["sRGB", "( value )"];
                        case 3002:
                            return ["RGBE", "( value )"];
                        case 3004:
                            return ["RGBM", "( value, 7.0 )"];
                        case 3005:
                            return ["RGBM", "( value, 16.0 )"];
                        case 3006:
                            return ["RGBD", "( value, 256.0 )"];
                        case 3007:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        case 3003:
                            return ["LogLuv", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                    }
                }

                function Vi(t, e, n) {
                    const r = t.getShaderParameter(e, 35713),
                        i = t.getShaderInfoLog(e).trim();
                    return r && "" === i ? "" : n.toUpperCase() + "\n\n" + i + "\n\n" + function(t) {
                        const e = t.split("\n");
                        for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                        return e.join("\n")
                    }(t.getShaderSource(e))
                }

                function Wi(t, e) {
                    const n = Gi(e);
                    return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
                }

                function ji(t, e) {
                    const n = Gi(e);
                    return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
                }

                function Zi(t, e) {
                    let n;
                    switch (e) {
                        case 1:
                            n = "Linear";
                            break;
                        case 2:
                            n = "Reinhard";
                            break;
                        case 3:
                            n = "OptimizedCineon";
                            break;
                        case 4:
                            n = "ACESFilmic";
                            break;
                        case 5:
                            n = "Custom";
                            break;
                        default:
                            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
                }

                function qi(t) {
                    return "" !== t
                }

                function Xi(t, e) {
                    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
                }

                function Yi(t, e) {
                    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
                }
                const Ji = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function Ki(t) {
                    return t.replace(Ji, Qi)
                }

                function Qi(t, e) {
                    const n = Jn[e];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                    return Ki(n)
                }
                const $i = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                    ts = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function es(t) {
                    return t.replace(ts, rs).replace($i, ns)
                }

                function ns(t, e, n, r) {
                    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), rs(t, e, n, r)
                }

                function rs(t, e, n, r) {
                    let i = "";
                    for (let t = parseInt(e); t < parseInt(n); t++) i += r.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                    return i
                }

                function is(t) {
                    let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                    return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
                }

                function ss(t, e, n, r) {
                    const i = t.getContext(),
                        s = n.defines;
                    let o = n.vertexShader,
                        a = n.fragmentShader;
                    const c = function(t) {
                            let e = "SHADOWMAP_TYPE_BASIC";
                            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                        }(n),
                        l = function(t) {
                            let e = "ENVMAP_TYPE_CUBE";
                            if (t.envMap) switch (t.envMapMode) {
                                case 301:
                                case 302:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case 306:
                                case 307:
                                    e = "ENVMAP_TYPE_CUBE_UV"
                            }
                            return e
                        }(n),
                        u = function(t) {
                            let e = "ENVMAP_MODE_REFLECTION";
                            if (t.envMap) switch (t.envMapMode) {
                                case 302:
                                case 307:
                                    e = "ENVMAP_MODE_REFRACTION"
                            }
                            return e
                        }(n),
                        h = function(t) {
                            let e = "ENVMAP_BLENDING_NONE";
                            if (t.envMap) switch (t.combine) {
                                case 0:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case 1:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case 2:
                                    e = "ENVMAP_BLENDING_ADD"
                            }
                            return e
                        }(n),
                        d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                        p = n.isWebGL2 ? "" : function(t) {
                            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(qi).join("\n")
                        }(n),
                        f = function(t) {
                            const e = [];
                            for (const n in t) {
                                const r = t[n];
                                !1 !== r && e.push("#define " + n + " " + r)
                            }
                            return e.join("\n")
                        }(s),
                        m = i.createProgram();
                    let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                    n.isRawShaderMaterial ? (g = [f].filter(qi).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(qi).join("\n"), v.length > 0 && (v += "\n")) : (g = [is(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(qi).join("\n"), v = [p, is(n), "#define SHADER_NAME " + n.shaderName, f, "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Jn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Zi("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === B ? "#define OPAQUE" : "", Jn.encodings_pars_fragment, n.map ? Wi("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Wi("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Wi("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Wi("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? Wi("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? Wi("lightMapTexelToLinear", n.lightMapEncoding) : "", ji("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(qi).join("\n")), o = Ki(o), o = Xi(o, n), o = Yi(o, n), a = Ki(a), a = Xi(a, n), a = Yi(a, n), o = es(o), a = es(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                    const x = y + v + a,
                        _ = Ui(i, 35633, y + g + o),
                        b = Ui(i, 35632, x);
                    if (i.attachShader(m, _), i.attachShader(m, b), void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), t.debug.checkShaderErrors) {
                        const t = i.getProgramInfoLog(m).trim(),
                            e = i.getShaderInfoLog(_).trim(),
                            n = i.getShaderInfoLog(b).trim();
                        let r = !0,
                            s = !0;
                        if (!1 === i.getProgramParameter(m, 35714)) {
                            r = !1;
                            const e = Vi(i, _, "vertex"),
                                n = Vi(i, b, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
                        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (s = !1);
                        s && (this.diagnostics = {
                            runnable: r,
                            programLog: t,
                            vertexShader: {
                                log: e,
                                prefix: g
                            },
                            fragmentShader: {
                                log: n,
                                prefix: v
                            }
                        })
                    }
                    let w, M;
                    return i.deleteShader(_), i.deleteShader(b), this.getUniforms = function() {
                        return void 0 === w && (w = new ki(i, m)), w
                    }, this.getAttributes = function() {
                        return void 0 === M && (M = function(t, e) {
                            const n = {},
                                r = t.getProgramParameter(e, 35721);
                            for (let i = 0; i < r; i++) {
                                const r = t.getActiveAttrib(e, i),
                                    s = r.name;
                                let o = 1;
                                35674 === r.type && (o = 2), 35675 === r.type && (o = 3), 35676 === r.type && (o = 4), n[s] = {
                                    type: r.type,
                                    location: t.getAttribLocation(e, s),
                                    locationSize: o
                                }
                            }
                            return n
                        }(i, m)), M
                    }, this.destroy = function() {
                        r.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0
                    }, this.name = n.shaderName, this.id = Hi++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = b, this
                }

                function os(t, e, n, r, i, s, o) {
                    const a = [],
                        c = i.isWebGL2,
                        l = i.logarithmicDepthBuffer,
                        u = i.floatVertexTextures,
                        h = i.maxVertexUniforms,
                        d = i.vertexTextures;
                    let p = i.precision;
                    const f = {
                            MeshDepthMaterial: "depth",
                            MeshDistanceMaterial: "distanceRGBA",
                            MeshNormalMaterial: "normal",
                            MeshBasicMaterial: "basic",
                            MeshLambertMaterial: "lambert",
                            MeshPhongMaterial: "phong",
                            MeshToonMaterial: "toon",
                            MeshStandardMaterial: "physical",
                            MeshPhysicalMaterial: "physical",
                            MeshMatcapMaterial: "matcap",
                            LineBasicMaterial: "basic",
                            LineDashedMaterial: "dashed",
                            PointsMaterial: "points",
                            ShadowMaterial: "shadow",
                            SpriteMaterial: "sprite"
                        },
                        m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "sheen", "transmission", "transmissionMap", "thicknessMap"];

                    function g(t) {
                        const e = t.skeleton.bones;
                        if (u) return 1024; {
                            const t = h,
                                n = Math.floor((t - 20) / 4),
                                r = Math.min(n, e.length);
                            return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
                        }
                    }

                    function v(t) {
                        let e;
                        return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = X, c && t && t.isTexture && t.format === z && t.type === I && t.encoding === Y && (e = X), e
                    }
                    return {
                        getParameters: function(s, a, h, m, y) {
                            const x = m.fog,
                                _ = s.isMeshStandardMaterial ? m.environment : null,
                                w = (s.isMeshStandardMaterial ? n : e).get(s.envMap || _),
                                M = f[s.type],
                                S = y.isSkinnedMesh ? g(y) : 0;
                            let T, E;
                            if (null !== s.precision && (p = i.getMaxPrecision(s.precision), p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead.")), M) {
                                const t = Qn[M];
                                T = t.vertexShader, E = t.fragmentShader
                            } else T = s.vertexShader, E = s.fragmentShader;
                            const A = t.getRenderTarget(),
                                L = s.alphaTest > 0,
                                R = s.clearcoat > 0;
                            return {
                                isWebGL2: c,
                                shaderID: M,
                                shaderName: s.type,
                                vertexShader: T,
                                fragmentShader: E,
                                defines: s.defines,
                                isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                                glslVersion: s.glslVersion,
                                precision: p,
                                instancing: !0 === y.isInstancedMesh,
                                instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
                                supportsVertexTextures: d,
                                outputEncoding: null !== A ? v(A.texture) : t.outputEncoding,
                                map: !!s.map,
                                mapEncoding: v(s.map),
                                matcap: !!s.matcap,
                                matcapEncoding: v(s.matcap),
                                envMap: !!w,
                                envMapMode: w && w.mapping,
                                envMapEncoding: v(w),
                                envMapCubeUV: !!w && (306 === w.mapping || 307 === w.mapping),
                                lightMap: !!s.lightMap,
                                lightMapEncoding: v(s.lightMap),
                                aoMap: !!s.aoMap,
                                emissiveMap: !!s.emissiveMap,
                                emissiveMapEncoding: v(s.emissiveMap),
                                bumpMap: !!s.bumpMap,
                                normalMap: !!s.normalMap,
                                objectSpaceNormalMap: 1 === s.normalMapType,
                                tangentSpaceNormalMap: s.normalMapType === J,
                                clearcoat: R,
                                clearcoatMap: R && !!s.clearcoatMap,
                                clearcoatRoughnessMap: R && !!s.clearcoatRoughnessMap,
                                clearcoatNormalMap: R && !!s.clearcoatNormalMap,
                                displacementMap: !!s.displacementMap,
                                roughnessMap: !!s.roughnessMap,
                                metalnessMap: !!s.metalnessMap,
                                specularMap: !!s.specularMap,
                                specularIntensityMap: !!s.specularIntensityMap,
                                specularTintMap: !!s.specularTintMap,
                                specularTintMapEncoding: v(s.specularTintMap),
                                alphaMap: !!s.alphaMap,
                                alphaTest: L,
                                gradientMap: !!s.gradientMap,
                                sheen: s.sheen > 0,
                                transmission: s.transmission > 0,
                                transmissionMap: !!s.transmissionMap,
                                thicknessMap: !!s.thicknessMap,
                                combine: s.combine,
                                vertexTangents: !!s.normalMap && !!y.geometry && !!y.geometry.attributes.tangent,
                                vertexColors: s.vertexColors,
                                vertexAlphas: !0 === s.vertexColors && !!y.geometry && !!y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
                                vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap),
                                uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularTintMap || !s.displacementMap),
                                fog: !!x,
                                useFog: s.fog,
                                fogExp2: x && x.isFogExp2,
                                flatShading: !!s.flatShading,
                                sizeAttenuation: s.sizeAttenuation,
                                logarithmicDepthBuffer: l,
                                skinning: !0 === y.isSkinnedMesh && S > 0,
                                maxBones: S,
                                useVertexTexture: u,
                                morphTargets: !!y.geometry && !!y.geometry.morphAttributes.position,
                                morphNormals: !!y.geometry && !!y.geometry.morphAttributes.normal,
                                morphTargetsCount: y.geometry && y.geometry.morphAttributes.position ? y.geometry.morphAttributes.position.length : 0,
                                numDirLights: a.directional.length,
                                numPointLights: a.point.length,
                                numSpotLights: a.spot.length,
                                numRectAreaLights: a.rectArea.length,
                                numHemiLights: a.hemi.length,
                                numDirLightShadows: a.directionalShadowMap.length,
                                numPointLightShadows: a.pointShadowMap.length,
                                numSpotLightShadows: a.spotShadowMap.length,
                                numClippingPlanes: o.numPlanes,
                                numClipIntersection: o.numIntersection,
                                format: s.format,
                                dithering: s.dithering,
                                shadowMapEnabled: t.shadowMap.enabled && h.length > 0,
                                shadowMapType: t.shadowMap.type,
                                toneMapping: s.toneMapped ? t.toneMapping : 0,
                                physicallyCorrectLights: t.physicallyCorrectLights,
                                premultipliedAlpha: s.premultipliedAlpha,
                                doubleSided: s.side === b,
                                flipSided: 1 === s.side,
                                depthPacking: void 0 !== s.depthPacking && s.depthPacking,
                                index0AttributeName: s.index0AttributeName,
                                extensionDerivatives: s.extensions && s.extensions.derivatives,
                                extensionFragDepth: s.extensions && s.extensions.fragDepth,
                                extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                                extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                                rendererExtensionFragDepth: c || r.has("EXT_frag_depth"),
                                rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"),
                                rendererExtensionShaderTextureLod: c || r.has("EXT_shader_texture_lod"),
                                customProgramCacheKey: s.customProgramCacheKey()
                            }
                        },
                        getProgramCacheKey: function(e) {
                            const n = [];
                            if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                            if (!1 === e.isRawShaderMaterial) {
                                for (let t = 0; t < m.length; t++) n.push(e[m[t]]);
                                n.push(t.outputEncoding), n.push(t.gammaFactor)
                            }
                            return n.push(e.customProgramCacheKey), n.join()
                        },
                        getUniforms: function(t) {
                            const e = f[t.type];
                            let n;
                            if (e) {
                                const t = Qn[e];
                                n = Dn.clone(t.uniforms)
                            } else n = t.uniforms;
                            return n
                        },
                        acquireProgram: function(e, n) {
                            let r;
                            for (let t = 0, e = a.length; t < e; t++) {
                                const e = a[t];
                                if (e.cacheKey === n) {
                                    r = e, ++r.usedTimes;
                                    break
                                }
                            }
                            return void 0 === r && (r = new ss(t, n, e, s), a.push(r)), r
                        },
                        releaseProgram: function(t) {
                            if (0 == --t.usedTimes) {
                                const e = a.indexOf(t);
                                a[e] = a[a.length - 1], a.pop(), t.destroy()
                            }
                        },
                        programs: a
                    }
                }

                function as() {
                    let t = new WeakMap;
                    return {get: function(e) {
                            let n = t.get(e);
                            return void 0 === n && (n = {}, t.set(e, n)), n
                        },
                        remove: function(e) {
                            t.delete(e)
                        },
                        update: function(e, n, r) {
                            t.get(e)[n] = r
                        },
                        dispose: function() {
                            t = new WeakMap
                        }
                    }
                }

                function cs(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                }

                function ls(t, e) {
                    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                }

                function us(t) {
                    const e = [];
                    let n = 0;
                    const r = [],
                        i = [],
                        s = [],
                        o = {
                            id: -1
                        };

                    function a(r, i, s, a, c, l) {
                        let u = e[n];
                        const h = t.get(s);
                        return void 0 === u ? (u = {
                            id: r.id,
                            object: r,
                            geometry: i,
                            material: s,
                            program: h.program || o,
                            groupOrder: a,
                            renderOrder: r.renderOrder,
                            z: c,
                            group: l
                        }, e[n] = u) : (u.id = r.id, u.object = r, u.geometry = i, u.material = s, u.program = h.program || o, u.groupOrder = a, u.renderOrder = r.renderOrder, u.z = c, u.group = l), n++, u
                    }
                    return {
                        opaque: r,
                        transmissive: i,
                        transparent: s,
                        init: function() {
                            n = 0, r.length = 0, i.length = 0, s.length = 0
                        },
                        push: function(t, e, n, o, c, l) {
                            const u = a(t, e, n, o, c, l);
                            n.transmission > 0 ? i.push(u) : !0 === n.transparent ? s.push(u) : r.push(u)
                        },
                        unshift: function(t, e, n, o, c, l) {
                            const u = a(t, e, n, o, c, l);
                            n.transmission > 0 ? i.unshift(u) : !0 === n.transparent ? s.unshift(u) : r.unshift(u)
                        },
                        finish: function() {
                            for (let t = n, r = e.length; t < r; t++) {
                                const n = e[t];
                                if (null === n.id) break;
                                n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                            }
                        },
                        sort: function(t, e) {
                            r.length > 1 && r.sort(t || cs), i.length > 1 && i.sort(e || ls), s.length > 1 && s.sort(e || ls)
                        }
                    }
                }

                function hs(t) {
                    let e = new WeakMap;
                    return {get: function(n, r) {
                            let i;
                            return !1 === e.has(n) ? (i = new us(t), e.set(n, [i])) : r >= e.get(n).length ? (i = new us(t), e.get(n).push(i)) : i = e.get(n)[r], i
                        },
                        dispose: function() {
                            e = new WeakMap
                        }
                    }
                }

                function ds() {
                    const t = {};
                    return {get: function(e) {
                            if (void 0 !== t[e.id]) return t[e.id];
                            let n;
                            switch (e.type) {
                                case "DirectionalLight":
                                    n = {
                                        direction: new Et,
                                        color: new Xe
                                    };
                                    break;
                                case "SpotLight":
                                    n = {
                                        position: new Et,
                                        direction: new Et,
                                        color: new Xe,
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        position: new Et,
                                        color: new Xe,
                                        distance: 0,
                                        decay: 0
                                    };
                                    break;
                                case "HemisphereLight":
                                    n = {
                                        direction: new Et,
                                        skyColor: new Xe,
                                        groundColor: new Xe
                                    };
                                    break;
                                case "RectAreaLight":
                                    n = {
                                        color: new Xe,
                                        position: new Et,
                                        halfWidth: new Et,
                                        halfHeight: new Et
                                    }
                            }
                            return t[e.id] = n, n
                        }
                    }
                }
                let ps = 0;

                function fs(t, e) {
                    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
                }

                function ms(t, e) {
                    const n = new ds,
                        r = function() {
                            const t = {};
                            return {get: function(e) {
                                    if (void 0 !== t[e.id]) return t[e.id];
                                    let n;
                                    switch (e.type) {
                                        case "DirectionalLight":
                                        case "SpotLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new pt
                                            };
                                            break;
                                        case "PointLight":
                                            n = {
                                                shadowBias: 0,
                                                shadowNormalBias: 0,
                                                shadowRadius: 1,
                                                shadowMapSize: new pt,
                                                shadowCameraNear: 1,
                                                shadowCameraFar: 1e3
                                            }
                                    }
                                    return t[e.id] = n, n
                                }
                            }
                        }(),
                        i = {
                            version: 0,
                            hash: {
                                directionalLength: -1,
                                pointLength: -1,
                                spotLength: -1,
                                rectAreaLength: -1,
                                hemiLength: -1,
                                numDirectionalShadows: -1,
                                numPointShadows: -1,
                                numSpotShadows: -1
                            },
                            ambient: [0, 0, 0],
                            probe: [],
                            directional: [],
                            directionalShadow: [],
                            directionalShadowMap: [],
                            directionalShadowMatrix: [],
                            spot: [],
                            spotShadow: [],
                            spotShadowMap: [],
                            spotShadowMatrix: [],
                            rectArea: [],
                            rectAreaLTC1: null,
                            rectAreaLTC2: null,
                            point: [],
                            pointShadow: [],
                            pointShadowMap: [],
                            pointShadowMatrix: [],
                            hemi: []
                        };
                    for (let t = 0; t < 9; t++) i.probe.push(new Et);
                    const s = new Et,
                        o = new re,
                        a = new re;
                    return {
                        setup: function(s, o) {
                            let a = 0,
                                c = 0,
                                l = 0;
                            for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
                            let u = 0,
                                h = 0,
                                d = 0,
                                p = 0,
                                f = 0,
                                m = 0,
                                g = 0,
                                v = 0;
                            s.sort(fs);
                            const y = !0 !== o ? Math.PI : 1;
                            for (let t = 0, e = s.length; t < e; t++) {
                                const e = s[t],
                                    o = e.color,
                                    x = e.intensity,
                                    _ = e.distance,
                                    b = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                                if (e.isAmbientLight) a += o.r * x * y, c += o.g * x * y, l += o.b * x * y;
                                else if (e.isLightProbe)
                                    for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], x);
                                else if (e.isDirectionalLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity * y), e.castShadow) {
                                        const t = e.shadow,
                                            n = r.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[u] = n, i.directionalShadowMap[u] = b, i.directionalShadowMatrix[u] = e.shadow.matrix, m++
                                    }
                                    i.directional[u] = t, u++
                                } else if (e.isSpotLight) {
                                    const t = n.get(e);
                                    if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(o).multiplyScalar(x * y), t.distance = _, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = r.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[d] = n, i.spotShadowMap[d] = b, i.spotShadowMatrix[d] = e.shadow.matrix, v++
                                    }
                                    i.spot[d] = t, d++
                                } else if (e.isRectAreaLight) {
                                    const t = n.get(e);
                                    t.color.copy(o).multiplyScalar(x), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[p] = t, p++
                                } else if (e.isPointLight) {
                                    const t = n.get(e);
                                    if (t.color.copy(e.color).multiplyScalar(e.intensity * y), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                        const t = e.shadow,
                                            n = r.get(e);
                                        n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[h] = n, i.pointShadowMap[h] = b, i.pointShadowMatrix[h] = e.shadow.matrix, g++
                                    }
                                    i.point[h] = t, h++
                                } else if (e.isHemisphereLight) {
                                    const t = n.get(e);
                                    t.skyColor.copy(e.color).multiplyScalar(x * y), t.groundColor.copy(e.groundColor).multiplyScalar(x * y), i.hemi[f] = t, f++
                                }
                            }
                            p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Kn.LTC_FLOAT_1, i.rectAreaLTC2 = Kn.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Kn.LTC_HALF_1, i.rectAreaLTC2 = Kn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = a, i.ambient[1] = c, i.ambient[2] = l;
                            const x = i.hash;
                            x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (i.directional.length = u, i.spot.length = d, i.rectArea.length = p, i.point.length = h, i.hemi.length = f, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = g, i.spotShadowMatrix.length = v, x.directionalLength = u, x.pointLength = h, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, i.version = ps++)
                        },
                        setupView: function(t, e) {
                            let n = 0,
                                r = 0,
                                c = 0,
                                l = 0,
                                u = 0;
                            const h = e.matrixWorldInverse;
                            for (let e = 0, d = t.length; e < d; e++) {
                                const d = t[e];
                                if (d.isDirectionalLight) {
                                    const t = i.directional[n];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), n++
                                } else if (d.isSpotLight) {
                                    const t = i.spot[c];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), c++
                                } else if (d.isRectAreaLight) {
                                    const t = i.rectArea[l];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), a.identity(), o.copy(d.matrixWorld), o.premultiply(h), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), l++
                                } else if (d.isPointLight) {
                                    const t = i.point[r];
                                    t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), r++
                                } else if (d.isHemisphereLight) {
                                    const t = i.hemi[u];
                                    t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), t.direction.normalize(), u++
                                }
                            }
                        },
                        state: i
                    }
                }

                function gs(t, e) {
                    const n = new ms(t, e),
                        r = [],
                        i = [];
                    return {
                        init: function() {
                            r.length = 0, i.length = 0
                        },
                        state: {
                            lightsArray: r,
                            shadowsArray: i,
                            lights: n
                        },
                        setupLights: function(t) {
                            n.setup(r, t)
                        },
                        setupLightsView: function(t) {
                            n.setupView(r, t)
                        },
                        pushLight: function(t) {
                            r.push(t)
                        },
                        pushShadow: function(t) {
                            i.push(t)
                        }
                    }
                }

                function vs(t, e) {
                    let n = new WeakMap;
                    return {get: function(r, i = 0) {
                            let s;
                            return !1 === n.has(r) ? (s = new gs(t, e), n.set(r, [s])) : i >= n.get(r).length ? (s = new gs(t, e), n.get(r).push(s)) : s = n.get(r)[i], s
                        },
                        dispose: function() {
                            n = new WeakMap
                        }
                    }
                }
                class ys extends He {
                    constructor(t) {
                        super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                    }
                }
                ys.prototype.isMeshDepthMaterial = !0;
                class xs extends He {
                    constructor(t) {
                        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Et, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                    }
                }
                xs.prototype.isMeshDistanceMaterial = !0;

                function _s(t, e, n) {
                    let r = new Zn;
                    const i = new pt,
                        s = new pt,
                        o = new wt,
                        a = new ys({
                            depthPacking: 3201
                        }),
                        c = new xs,
                        l = {},
                        u = n.maxTextureSize,
                        h = {
                            0: 1,
                            1: _,
                            2: b
                        },
                        d = new On({
                            uniforms: {
                                shadow_pass: {
                                    value: null
                                },
                                resolution: {
                                    value: new pt
                                },
                                radius: {
                                    value: 4
                                },
                                samples: {
                                    value: 8
                                }
                            },
                            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                        }),
                        p = d.clone();
                    p.defines.HORIZONTAL_PASS = 1;
                    const f = new un;
                    f.setAttribute("position", new Qe(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                    const m = new Ln(f, d),
                        g = this;

                    function v(n, r) {
                        const i = e.update(m);
                        d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, d.uniforms.samples.value = n.blurSamples, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, p.uniforms.samples.value = n.blurSamples, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, p, m, null)
                    }

                    function y(e, n, r, i, s, o, u) {
                        let d = null;
                        const p = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                        if (d = void 0 !== p ? p : !0 === i.isPointLight ? c : a, t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length || r.displacementMap && 0 !== r.displacementScale || r.alphaMap && r.alphaTest > 0) {
                            const t = d.uuid,
                                e = r.uuid;
                            let n = l[t];
                            void 0 === n && (n = {}, l[t] = n);
                            let i = n[e];
                            void 0 === i && (i = d.clone(), n[e] = i), d = i
                        }
                        return d.visible = r.visible, d.wireframe = r.wireframe, d.side = 3 === u ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[r.side], d.alphaMap = r.alphaMap, d.alphaTest = r.alphaTest, d.clipShadows = r.clipShadows, d.clippingPlanes = r.clippingPlanes, d.clipIntersection = r.clipIntersection, d.displacementMap = r.displacementMap, d.displacementScale = r.displacementScale, d.displacementBias = r.displacementBias, d.wireframeLinewidth = r.wireframeLinewidth, d.linewidth = r.linewidth, !0 === i.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(i.matrixWorld), d.nearDistance = s, d.farDistance = o), d
                    }

                    function x(n, i, s, o, a) {
                        if (!1 === n.visible) return;
                        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || r.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                            const r = e.update(n),
                                i = n.material;
                            if (Array.isArray(i)) {
                                const e = r.groups;
                                for (let c = 0, l = e.length; c < l; c++) {
                                    const l = e[c],
                                        u = i[l.materialIndex];
                                    if (u && u.visible) {
                                        const e = y(n, 0, u, o, s.near, s.far, a);
                                        t.renderBufferDirect(s, null, r, e, n, l)
                                    }
                                }
                            } else if (i.visible) {
                                const e = y(n, 0, i, o, s.near, s.far, a);
                                t.renderBufferDirect(s, null, r, e, n, null)
                            }
                        }
                        const c = n.children;
                        for (let t = 0, e = c.length; t < e; t++) x(c[t], i, s, o, a)
                    }
                    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, a) {
                        if (!1 === g.enabled) return;
                        if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
                        if (0 === e.length) return;
                        const c = t.getRenderTarget(),
                            l = t.getActiveCubeFace(),
                            h = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (let c = 0, l = e.length; c < l; c++) {
                            const l = e[c],
                                h = l.shadow;
                            if (void 0 === h) {
                                console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                                continue
                            }
                            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                            i.copy(h.mapSize);
                            const p = h.getFrameExtents();
                            if (i.multiply(p), s.copy(h.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / p.x), i.x = s.x * p.x, h.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / p.y), i.y = s.y * p.y, h.mapSize.y = s.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) {
                                const t = {
                                    minFilter: R,
                                    magFilter: R,
                                    format: z
                                };
                                h.map = new Mt(i.x, i.y, t), h.map.texture.name = l.name + ".shadowMap", h.mapPass = new Mt(i.x, i.y, t), h.camera.updateProjectionMatrix()
                            }
                            if (null === h.map) {
                                const t = {
                                    minFilter: E,
                                    magFilter: E,
                                    format: z
                                };
                                h.map = new Mt(i.x, i.y, t), h.map.texture.name = l.name + ".shadowMap", h.camera.updateProjectionMatrix()
                            }
                            t.setRenderTarget(h.map), t.clear();
                            const f = h.getViewportCount();
                            for (let t = 0; t < f; t++) {
                                const e = h.getViewport(t);
                                o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), h.updateMatrices(l, t), r = h.getFrustum(), x(n, a, h.camera, l, this.type)
                            }
                            h.isPointLightShadow || 3 !== this.type || v(h, a), h.needsUpdate = !1
                        }
                        g.needsUpdate = !1, t.setRenderTarget(c, l, h)
                    }
                }

                function bs(t, e, n) {
                    const r = n.isWebGL2;
                    const i = new function() {
                            let e = !1;
                            const n = new wt;
                            let r = null;
                            const i = new wt(0, 0, 0, 0);
                            return {
                                setMask: function(n) {
                                    r === n || e || (t.colorMask(n, n, n, n), r = n)
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e, r, s, o, a) {
                                    !0 === a && (e *= o, r *= o, s *= o), n.set(e, r, s, o), !1 === i.equals(n) && (t.clearColor(e, r, s, o), i.copy(n))
                                },
                                reset: function() {
                                    e = !1, r = null, i.set(-1, 0, 0, 0)
                                }
                            }
                        },
                        s = new function() {
                            let e = !1,
                                n = null,
                                r = null,
                                i = null;
                            return {
                                setTest: function(t) {
                                    t ? k(2929) : U(2929)
                                },
                                setMask: function(r) {
                                    n === r || e || (t.depthMask(r), n = r)
                                },
                                setFunc: function(e) {
                                    if (r !== e) {
                                        if (e) switch (e) {
                                            case 0:
                                                t.depthFunc(512);
                                                break;
                                            case 1:
                                                t.depthFunc(519);
                                                break;
                                            case 2:
                                                t.depthFunc(513);
                                                break;
                                            case 3:
                                                t.depthFunc(515);
                                                break;
                                            case 4:
                                                t.depthFunc(514);
                                                break;
                                            case 5:
                                                t.depthFunc(518);
                                                break;
                                            case 6:
                                                t.depthFunc(516);
                                                break;
                                            case 7:
                                                t.depthFunc(517);
                                                break;
                                            default:
                                                t.depthFunc(515)
                                        } else t.depthFunc(515);
                                        r = e
                                    }
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e) {
                                    i !== e && (t.clearDepth(e), i = e)
                                },
                                reset: function() {
                                    e = !1, n = null, r = null, i = null
                                }
                            }
                        },
                        o = new function() {
                            let e = !1,
                                n = null,
                                r = null,
                                i = null,
                                s = null,
                                o = null,
                                a = null,
                                c = null,
                                l = null;
                            return {
                                setTest: function(t) {
                                    e || (t ? k(2960) : U(2960))
                                },
                                setMask: function(r) {
                                    n === r || e || (t.stencilMask(r), n = r)
                                },
                                setFunc: function(e, n, o) {
                                    r === e && i === n && s === o || (t.stencilFunc(e, n, o), r = e, i = n, s = o)
                                },
                                setOp: function(e, n, r) {
                                    o === e && a === n && c === r || (t.stencilOp(e, n, r), o = e, a = n, c = r)
                                },
                                setLocked: function(t) {
                                    e = t
                                },
                                setClear: function(e) {
                                    l !== e && (t.clearStencil(e), l = e)
                                },
                                reset: function() {
                                    e = !1, n = null, r = null, i = null, s = null, o = null, a = null, c = null, l = null
                                }
                            }
                        };
                    let a = {},
                        c = null,
                        l = {},
                        u = null,
                        h = !1,
                        d = null,
                        p = null,
                        f = null,
                        m = null,
                        g = null,
                        v = null,
                        y = null,
                        x = !1,
                        _ = null,
                        M = null,
                        S = null,
                        T = null,
                        E = null;
                    const A = t.getParameter(35661);
                    let L = !1,
                        R = 0;
                    const P = t.getParameter(7938); - 1 !== P.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(P)[1]), L = R >= 1) : -1 !== P.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]), L = R >= 2);
                    let C = null,
                        I = {};
                    const D = t.getParameter(3088),
                        O = t.getParameter(2978),
                        N = (new wt).fromArray(D),
                        B = (new wt).fromArray(O);

                    function z(e, n, r) {
                        const i = new Uint8Array(4),
                            s = t.createTexture();
                        t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                        for (let e = 0; e < r; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, i);
                        return s
                    }
                    const F = {};

                    function k(e) {
                        !0 !== a[e] && (t.enable(e), a[e] = !0)
                    }

                    function U(e) {
                        !1 !== a[e] && (t.disable(e), a[e] = !1)
                    }
                    F[3553] = z(3553, 3553, 1), F[34067] = z(34067, 34069, 6), i.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), k(2929), s.setFunc(3), W(!1), j(1), k(2884), V(0);
                    const H = {
                        [w]: 32774, 101: 32778, 102: 32779
                    };
                    if (r) H[103] = 32775, H[104] = 32776;
                    else {
                        const t = e.get("EXT_blend_minmax");
                        null !== t && (H[103] = t.MIN_EXT, H[104] = t.MAX_EXT)
                    }
                    const G = {
                        200: 0,
                        201: 1,
                        202: 768,
                        204: 770,
                        210: 776,
                        208: 774,
                        206: 772,
                        203: 769,
                        205: 771,
                        209: 775,
                        207: 773
                    };

                    function V(e, n, r, i, s, o, a, c) {
                        if (0 !== e) {
                            if (!1 === h && (k(3042), h = !0), 5 === e) s = s || n, o = o || r, a = a || i, n === p && s === g || (t.blendEquationSeparate(H[n], H[s]), p = n, g = s), r === f && i === m && o === v && a === y || (t.blendFuncSeparate(G[r], G[i], G[o], G[a]), f = r, m = i, v = o, y = a), d = e, x = null;
                            else if (e !== d || c !== x) {
                                if (p === w && g === w || (t.blendEquation(32774), p = w, g = w), c) switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(1, 1);
                                        break;
                                    case 3:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case 4:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                } else switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(770, 1);
                                        break;
                                    case 3:
                                        t.blendFunc(0, 769);
                                        break;
                                    case 4:
                                        t.blendFunc(0, 768);
                                        break;
                                    default:
                                        console.error("THREE.WebGLState: Invalid blending: ", e)
                                }
                                f = null, m = null, v = null, y = null, d = e, x = c
                            }
                        } else !0 === h && (U(3042), h = !1)
                    }

                    function W(e) {
                        _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), _ = e)
                    }

                    function j(e) {
                        0 !== e ? (k(2884), e !== M && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : U(2884), M = e
                    }

                    function Z(e, n, r) {
                        e ? (k(32823), T === n && E === r || (t.polygonOffset(n, r), T = n, E = r)) : U(32823)
                    }

                    function q(e) {
                        void 0 === e && (e = 33984 + A - 1), C !== e && (t.activeTexture(e), C = e)
                    }
                    return {
                        buffers: {
                            color: i,
                            depth: s,
                            stencil: o
                        },
                        enable: k,
                        disable: U,
                        bindFramebuffer: function(e, n) {
                            return null === n && null !== c && (n = c), l[e] !== n && (t.bindFramebuffer(e, n), l[e] = n, r && (36009 === e && (l[36160] = n), 36160 === e && (l[36009] = n)), !0)
                        },
                        bindXRFramebuffer: function(e) {
                            e !== c && (t.bindFramebuffer(36160, e), c = e)
                        },
                        useProgram: function(e) {
                            return u !== e && (t.useProgram(e), u = e, !0)
                        },
                        setBlending: V,
                        setMaterial: function(t, e) {
                            t.side === b ? U(2884) : k(2884);
                            let n = 1 === t.side;
                            e && (n = !n), W(n), 1 === t.blending && !1 === t.transparent ? V(0) : V(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), i.setMask(t.colorWrite);
                            const r = t.stencilWrite;
                            o.setTest(r), r && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Z(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? k(32926) : U(32926)
                        },
                        setFlipSided: W,
                        setCullFace: j,
                        setLineWidth: function(e) {
                            e !== S && (L && t.lineWidth(e), S = e)
                        },
                        setPolygonOffset: Z,
                        setScissorTest: function(t) {
                            t ? k(3089) : U(3089)
                        },
                        activeTexture: q,
                        bindTexture: function(e, n) {
                            null === C && q();
                            let r = I[C];
                            void 0 === r && (r = {
                                type: void 0,
                                texture: void 0
                            }, I[C] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || F[e]), r.type = e, r.texture = n)
                        },
                        unbindTexture: function() {
                            const e = I[C];
                            void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                        },
                        compressedTexImage2D: function() {
                            try {
                                t.compressedTexImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage2D: function() {
                            try {
                                t.texImage2D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        texImage3D: function() {
                            try {
                                t.texImage3D.apply(t, arguments)
                            } catch (t) {
                                console.error("THREE.WebGLState:", t)
                            }
                        },
                        scissor: function(e) {
                            !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e))
                        },
                        viewport: function(e) {
                            !1 === B.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), B.copy(e))
                        },
                        reset: function() {
                            t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, C = null, I = {}, c = null, l = {}, u = null, h = !1, d = null, p = null, f = null, m = null, g = null, v = null, y = null, x = !1, _ = null, M = null, S = null, T = null, E = null, N.set(0, 0, t.canvas.width, t.canvas.height), B.set(0, 0, t.canvas.width, t.canvas.height), i.reset(), s.reset(), o.reset()
                        }
                    }
                }

                function ws(t, e, n, r, i, s, o) {
                    const a = i.isWebGL2,
                        c = i.maxTextures,
                        l = i.maxCubemapSize,
                        u = i.maxTextureSize,
                        p = i.maxSamples,
                        f = new WeakMap;
                    let m, g = !1;
                    try {
                        g = void 0 !== h && null !== new h(1, 1).getContext("2d")
                    } catch (t) {}

                    function v(t, e) {
                        return g ? new h(t, e) : gt("canvas")
                    }

                    function y(t, e, n, r) {
                        let i = 1;
                        if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
                            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || void 0 !== d && t instanceof d || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                                const r = e ? ht : Math.floor,
                                    s = r(i * t.width),
                                    o = r(i * t.height);
                                void 0 === m && (m = v(s, o));
                                const a = n ? v(s, o) : m;
                                a.width = s, a.height = o;
                                return a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                            }
                            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                        }
                        return t
                    }

                    function x(t) {
                        return lt(t.width) && lt(t.height)
                    }

                    function _(t, e) {
                        return t.generateMipmaps && e && t.minFilter !== E && t.minFilter !== R
                    }

                    function b(e, n, i, s, o = 1) {
                        t.generateMipmap(e);
                        r.get(n).__maxMipLevel = Math.log2(Math.max(i, s, o))
                    }

                    function w(n, r, i, s) {
                        if (!1 === a) return r;
                        if (null !== n) {
                            if (void 0 !== t[n]) return t[n];
                            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                        }
                        let o = r;
                        return 6403 === r && (5126 === i && (o = 33326), 5131 === i && (o = 33325), 5121 === i && (o = 33321)), 6407 === r && (5126 === i && (o = 34837), 5131 === i && (o = 34843), 5121 === i && (o = 32849)), 6408 === r && (5126 === i && (o = 34836), 5131 === i && (o = 34842), 5121 === i && (o = s === Y ? 35907 : 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o
                    }

                    function I(t) {
                        return t === E || t === A || t === L ? 9728 : 9729
                    }

                    function U(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", U), G(e), e.isVideoTexture && f.delete(e), o.memory.textures--
                    }

                    function H(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", H), V(e)
                    }

                    function G(e) {
                        const n = r.get(e);
                        void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), r.remove(e))
                    }

                    function V(e) {
                        const n = e.texture,
                            i = r.get(e),
                            s = r.get(n);
                        if (e) {
                            if (void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), o.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)
                                for (let e = 0; e < 6; e++) t.deleteFramebuffer(i.__webglFramebuffer[e]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[e]);
                            else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && t.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                            if (e.isWebGLMultipleRenderTargets)
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = r.get(n[e]);
                                    i.__webglTexture && (t.deleteTexture(i.__webglTexture), o.memory.textures--), r.remove(n[e])
                                }
                            r.remove(n), r.remove(e)
                        }
                    }
                    let W = 0;

                    function j(t, e) {
                        const i = r.get(t);
                        if (t.isVideoTexture && function(t) {
                                const e = o.render.frame;
                                f.get(t) !== e && (f.set(t, e), t.update())
                            }(t), t.version > 0 && i.__version !== t.version) {
                            const n = t.image;
                            if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                            else {
                                if (!1 !== n.complete) return void Q(i, t, e);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                            }
                        }
                        n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
                    }

                    function Z(t, e) {
                        const i = r.get(t);
                        t.version > 0 && i.__version !== t.version ? $(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(34067, i.__webglTexture))
                    }
                    const q = {
                            [M]: 10497, [S]: 33071, [T]: 33648
                        },
                        X = {
                            [E]: 9728, [A]: 9984, [L]: 9986, [R]: 9729, [P]: 9985, [C]: 9987
                        };

                    function J(n, s, o) {
                        if (o ? (t.texParameteri(n, 10242, q[s.wrapS]), t.texParameteri(n, 10243, q[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, q[s.wrapR]), t.texParameteri(n, 10240, X[s.magFilter]), t.texParameteri(n, 10241, X[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === S && s.wrapT === S || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, I(s.magFilter)), t.texParameteri(n, 10241, I(s.minFilter)), s.minFilter !== E && s.minFilter !== R && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                            const o = e.get("EXT_texture_filter_anisotropic");
                            if (s.type === D && !1 === e.has("OES_texture_float_linear")) return;
                            if (!1 === a && s.type === O && !1 === e.has("OES_texture_half_float_linear")) return;
                            (s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy)
                        }
                    }

                    function K(e, n) {
                        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", U), e.__webglTexture = t.createTexture(), o.memory.textures++)
                    }

                    function Q(e, r, i) {
                        let o = 3553;
                        r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), K(e, r), n.activeTexture(33984 + i), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                        const c = function(t) {
                                return !a && (t.wrapS !== S || t.wrapT !== S || t.minFilter !== E && t.minFilter !== R)
                            }(r) && !1 === x(r.image),
                            l = y(r.image, c, !1, u),
                            h = x(l) || a,
                            d = s.convert(r.format);
                        let p, f = s.convert(r.type),
                            m = w(r.internalFormat, d, f, r.encoding);
                        J(o, r, h);
                        const g = r.mipmaps;
                        if (r.isDepthTexture) m = 6402, a ? m = r.type === D ? 36012 : 1014 === r.type ? 33190 : r.type === N ? 35056 : 33189 : r.type === D && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === F && 6402 === m && 1012 !== r.type && 1014 !== r.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = 1012, f = s.convert(r.type)), r.format === k && 6402 === m && (m = 34041, r.type !== N && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = N, f = s.convert(r.type))), n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
                        else if (r.isDataTexture)
                            if (g.length > 0 && h) {
                                for (let t = 0, e = g.length; t < e; t++) p = g[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                                r.generateMipmaps = !1, e.__maxMipLevel = g.length - 1
                            } else n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data), e.__maxMipLevel = 0;
                        else if (r.isCompressedTexture) {
                            for (let t = 0, e = g.length; t < e; t++) p = g[t], r.format !== z && r.format !== B ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                            e.__maxMipLevel = g.length - 1
                        } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0;
                        else if (r.isDataTexture3D) n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0;
                        else if (g.length > 0 && h) {
                            for (let t = 0, e = g.length; t < e; t++) p = g[t], n.texImage2D(3553, t, m, d, f, p);
                            r.generateMipmaps = !1, e.__maxMipLevel = g.length - 1
                        } else n.texImage2D(3553, 0, m, d, f, l), e.__maxMipLevel = 0;
                        _(r, h) && b(o, r, l.width, l.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
                    }

                    function $(e, r, i) {
                        if (6 !== r.image.length) return;
                        K(e, r), n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
                        const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
                            c = r.image[0] && r.image[0].isDataTexture,
                            u = [];
                        for (let t = 0; t < 6; t++) u[t] = o || c ? c ? r.image[t].image : r.image[t] : y(r.image[t], !1, !0, l);
                        const h = u[0],
                            d = x(h) || a,
                            p = s.convert(r.format),
                            f = s.convert(r.type),
                            m = w(r.internalFormat, p, f, r.encoding);
                        let g;
                        if (J(34067, r, d), o) {
                            for (let t = 0; t < 6; t++) {
                                g = u[t].mipmaps;
                                for (let e = 0; e < g.length; e++) {
                                    const i = g[e];
                                    r.format !== z && r.format !== B ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, i.width, i.height, 0, p, f, i.data)
                                }
                            }
                            e.__maxMipLevel = g.length - 1
                        } else {
                            g = r.mipmaps;
                            for (let t = 0; t < 6; t++)
                                if (c) {
                                    n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
                                    for (let e = 0; e < g.length; e++) {
                                        const r = g[e].image[t].image;
                                        n.texImage2D(34069 + t, e + 1, m, r.width, r.height, 0, p, f, r.data)
                                    }
                                } else {
                                    n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                                    for (let e = 0; e < g.length; e++) {
                                        const r = g[e];
                                        n.texImage2D(34069 + t, e + 1, m, p, f, r.image[t])
                                    }
                                }
                            e.__maxMipLevel = g.length
                        }
                        _(r, d) && b(34067, r, h.width, h.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
                    }

                    function tt(e, i, o, a, c) {
                        const l = s.convert(o.format),
                            u = s.convert(o.type),
                            h = w(o.internalFormat, l, u, o.encoding);
                        32879 === c || 35866 === c ? n.texImage3D(c, 0, h, i.width, i.height, i.depth, 0, l, u, null) : n.texImage2D(c, 0, h, i.width, i.height, 0, l, u, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, c, r.get(o).__webglTexture, 0), n.bindFramebuffer(36160, null)
                    }

                    function et(e, n, r) {
                        if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                            let i = 33189;
                            if (r) {
                                const e = n.depthTexture;
                                e && e.isDepthTexture && (e.type === D ? i = 36012 : 1014 === e.type && (i = 33190));
                                const r = rt(n);
                                t.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
                            } else t.renderbufferStorage(36161, i, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 36096, 36161, e)
                        } else if (n.depthBuffer && n.stencilBuffer) {
                            if (r) {
                                const e = rt(n);
                                t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                            } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                            t.framebufferRenderbuffer(36160, 33306, 36161, e)
                        } else {
                            const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                                i = s.convert(e.format),
                                o = s.convert(e.type),
                                a = w(e.internalFormat, i, o, e.encoding);
                            if (r) {
                                const e = rt(n);
                                t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                            } else t.renderbufferStorage(36161, a, n.width, n.height)
                        }
                        t.bindRenderbuffer(36161, null)
                    }

                    function nt(e) {
                        const i = r.get(e),
                            s = !0 === e.isWebGLCubeRenderTarget;
                        if (e.depthTexture) {
                            if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                            ! function(e, i) {
                                if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                if (n.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), j(i.depthTexture, 0);
                                const s = r.get(i.depthTexture).__webglTexture;
                                if (i.depthTexture.format === F) t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                                else {
                                    if (i.depthTexture.format !== k) throw new Error("Unknown depthTexture format");
                                    t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                                }
                            }(i.__webglFramebuffer, e)
                        } else if (s) {
                            i.__webglDepthbuffer = [];
                            for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), et(i.__webglDepthbuffer[r], e, !1)
                        } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), et(i.__webglDepthbuffer, e, !1);
                        n.bindFramebuffer(36160, null)
                    }

                    function rt(t) {
                        return a && t.isWebGLMultisampleRenderTarget ? Math.min(p, t.samples) : 0
                    }
                    let it = !1,
                        st = !1;
                    this.allocateTextureUnit = function() {
                        const t = W;
                        return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), W += 1, t
                    }, this.resetTextureUnits = function() {
                        W = 0
                    }, this.setTexture2D = j, this.setTexture2DArray = function(t, e) {
                        const i = r.get(t);
                        t.version > 0 && i.__version !== t.version ? Q(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
                    }, this.setTexture3D = function(t, e) {
                        const i = r.get(t);
                        t.version > 0 && i.__version !== t.version ? Q(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
                    }, this.setTextureCube = Z, this.setupRenderTarget = function(e) {
                        const c = e.texture,
                            l = r.get(e),
                            u = r.get(c);
                        e.addEventListener("dispose", H), !0 !== e.isWebGLMultipleRenderTargets && (u.__webglTexture = t.createTexture(), u.__version = c.version, o.memory.textures++);
                        const h = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            f = c.isDataTexture3D || c.isDataTexture2DArray,
                            m = x(e) || a;
                        if (!a || c.format !== B || c.type !== D && c.type !== O || (c.format = z, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
                            l.__webglFramebuffer = [];
                            for (let e = 0; e < 6; e++) l.__webglFramebuffer[e] = t.createFramebuffer()
                        } else if (l.__webglFramebuffer = t.createFramebuffer(), d)
                            if (i.drawBuffers) {
                                const n = e.texture;
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = r.get(n[e]);
                                    void 0 === i.__webglTexture && (i.__webglTexture = t.createTexture(), o.memory.textures++)
                                }
                            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        else if (p)
                            if (a) {
                                l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                                const r = s.convert(c.format),
                                    i = s.convert(c.type),
                                    o = w(c.internalFormat, r, i, c.encoding),
                                    a = rt(e);
                                t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), et(l.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                        if (h) {
                            n.bindTexture(34067, u.__webglTexture), J(34067, c, m);
                            for (let t = 0; t < 6; t++) tt(l.__webglFramebuffer[t], e, c, 36064, 34069 + t);
                            _(c, m) && b(34067, c, e.width, e.height), n.unbindTexture()
                        } else if (d) {
                            const t = e.texture;
                            for (let i = 0, s = t.length; i < s; i++) {
                                const s = t[i],
                                    o = r.get(s);
                                n.bindTexture(3553, o.__webglTexture), J(3553, s, m), tt(l.__webglFramebuffer, e, s, 36064 + i, 3553), _(s, m) && b(3553, s, e.width, e.height)
                            }
                            n.unbindTexture()
                        } else {
                            let t = 3553;
                            if (f)
                                if (a) {
                                    t = c.isDataTexture3D ? 32879 : 35866
                                } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                            n.bindTexture(t, u.__webglTexture), J(t, c, m), tt(l.__webglFramebuffer, e, c, 36064, t), _(c, m) && b(t, c, e.width, e.height, e.depth), n.unbindTexture()
                        }
                        e.depthBuffer && nt(e)
                    }, this.updateRenderTargetMipmap = function(t) {
                        const e = x(t) || a,
                            i = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let s = 0, o = i.length; s < o; s++) {
                            const o = i[s];
                            if (_(o, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    i = r.get(o).__webglTexture;
                                n.bindTexture(e, i), b(e, o, t.width, t.height), n.unbindTexture()
                            }
                        }
                    }, this.updateMultisampleRenderTarget = function(e) {
                        if (e.isWebGLMultisampleRenderTarget)
                            if (a) {
                                const i = e.width,
                                    s = e.height;
                                let o = 16384;
                                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                                const a = r.get(e);
                                n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, i, s, 0, 0, i, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
                            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                    }, this.safeSetTexture2D = function(t, e) {
                        t && t.isWebGLRenderTarget && (!1 === it && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), it = !0), t = t.texture), j(t, e)
                    }, this.safeSetTextureCube = function(t, e) {
                        t && t.isWebGLCubeRenderTarget && (!1 === st && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), st = !0), t = t.texture), Z(t, e)
                    }
                }

                function Ms(t, e, n) {
                    const r = n.isWebGL2;
                    return {
                        convert: function(t) {
                            let n;
                            if (t === I) return 5121;
                            if (1017 === t) return 32819;
                            if (1018 === t) return 32820;
                            if (1019 === t) return 33635;
                            if (1010 === t) return 5120;
                            if (1011 === t) return 5122;
                            if (1012 === t) return 5123;
                            if (1013 === t) return 5124;
                            if (1014 === t) return 5125;
                            if (t === D) return 5126;
                            if (t === O) return r ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                            if (1021 === t) return 6406;
                            if (t === B) return 6407;
                            if (t === z) return 6408;
                            if (1024 === t) return 6409;
                            if (1025 === t) return 6410;
                            if (t === F) return 6402;
                            if (t === k) return 34041;
                            if (1028 === t) return 6403;
                            if (1029 === t) return 36244;
                            if (1030 === t) return 33319;
                            if (1031 === t) return 33320;
                            if (1032 === t) return 36248;
                            if (1033 === t) return 36249;
                            if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                                if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                                if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                            if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                                if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                                if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            }
                            if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                            if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                                if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                                if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
                            }
                            return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === N ? r ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                        }
                    }
                }
                class Ss extends Bn {
                    constructor(t = []) {
                        super(), this.cameras = t
                    }
                }
                Ss.prototype.isArrayCamera = !0;
                class Ts extends Le {
                    constructor() {
                        super(), this.type = "Group"
                    }
                }
                Ts.prototype.isGroup = !0;
                const Es = {
                    type: "move"
                };
                class As {
                    constructor() {
                        this._targetRay = null, this._grip = null, this._hand = null
                    }
                    getHandSpace() {
                        return null === this._hand && (this._hand = new Ts, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                            pinching: !1
                        }), this._hand
                    }
                    getTargetRaySpace() {
                        return null === this._targetRay && (this._targetRay = new Ts, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Et, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Et), this._targetRay
                    }
                    getGripSpace() {
                        return null === this._grip && (this._grip = new Ts, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Et, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Et), this._grip
                    }
                    dispatchEvent(t) {
                        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                    }
                    disconnect(t) {
                        return this.dispatchEvent({
                            type: "disconnected",
                            data: t
                        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                    }
                    update(t, e, n) {
                        let r = null,
                            i = null,
                            s = null;
                        const o = this._targetRay,
                            a = this._grip,
                            c = this._hand;
                        if (t && "visible-blurred" !== e.session.visibilityState)
                            if (null !== o && (r = e.getPose(t.targetRaySpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Es))), c && t.hand) {
                                s = !0;
                                for (const r of t.hand.values()) {
                                    const t = e.getJointPose(r, n);
                                    if (void 0 === c.joints[r.jointName]) {
                                        const t = new Ts;
                                        t.matrixAutoUpdate = !1, t.visible = !1, c.joints[r.jointName] = t, c.add(t)
                                    }
                                    const i = c.joints[r.jointName];
                                    null !== t && (i.matrix.fromArray(t.transform.matrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.jointRadius = t.radius), i.visible = null !== t
                                }
                                const r = c.joints["index-finger-tip"],
                                    i = c.joints["thumb-tip"],
                                    o = r.position.distanceTo(i.position),
                                    a = .02,
                                    l = .005;
                                c.inputState.pinching && o > a + l ? (c.inputState.pinching = !1, this.dispatchEvent({
                                    type: "pinchend",
                                    handedness: t.handedness,
                                    target: this
                                })) : !c.inputState.pinching && o <= a - l && (c.inputState.pinching = !0, this.dispatchEvent({
                                    type: "pinchstart",
                                    handedness: t.handedness,
                                    target: this
                                }))
                            } else null !== a && t.gripSpace && (i = e.getPose(t.gripSpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1));
                        return null !== o && (o.visible = null !== r), null !== a && (a.visible = null !== i), null !== c && (c.visible = null !== s), this
                    }
                }
                class Ls extends $ {
                    constructor(t, e) {
                        super();
                        const n = this,
                            r = t.state;
                        let i = null,
                            s = 1,
                            o = null,
                            a = "local-floor",
                            c = null,
                            l = null,
                            u = null,
                            h = null,
                            d = null,
                            p = !1,
                            f = null,
                            m = null,
                            g = null,
                            v = null,
                            y = null,
                            x = null;
                        const _ = [],
                            b = new Map,
                            w = new Bn;
                        w.layers.enable(1), w.viewport = new wt;
                        const M = new Bn;
                        M.layers.enable(2), M.viewport = new wt;
                        const S = [w, M],
                            T = new Ss;
                        T.layers.enable(1), T.layers.enable(2);
                        let E = null,
                            A = null;

                        function L(t) {
                            const e = b.get(t.inputSource);
                            e && e.dispatchEvent({
                                type: t.type,
                                data: t.inputSource
                            })
                        }

                        function R() {
                            b.forEach((function(t, e) {
                                t.disconnect(e)
                            })), b.clear(), E = null, A = null, r.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), u && e.deleteFramebuffer(u), f && e.deleteFramebuffer(f), m && e.deleteRenderbuffer(m), g && e.deleteRenderbuffer(g), u = null, f = null, m = null, g = null, d = null, h = null, l = null, i = null, N.stop(), n.isPresenting = !1, n.dispatchEvent({
                                type: "sessionend"
                            })
                        }

                        function P(t) {
                            const e = i.inputSources;
                            for (let t = 0; t < _.length; t++) b.set(e[t], _[t]);
                            for (let e = 0; e < t.removed.length; e++) {
                                const n = t.removed[e],
                                    r = b.get(n);
                                r && (r.dispatchEvent({
                                    type: "disconnected",
                                    data: n
                                }), b.delete(n))
                            }
                            for (let e = 0; e < t.added.length; e++) {
                                const n = t.added[e],
                                    r = b.get(n);
                                r && r.dispatchEvent({
                                    type: "connected",
                                    data: n
                                })
                            }
                        }
                        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                            let e = _[t];
                            return void 0 === e && (e = new As, _[t] = e), e.getTargetRaySpace()
                        }, this.getControllerGrip = function(t) {
                            let e = _[t];
                            return void 0 === e && (e = new As, _[t] = e), e.getGripSpace()
                        }, this.getHand = function(t) {
                            let e = _[t];
                            return void 0 === e && (e = new As, _[t] = e), e.getHandSpace()
                        }, this.setFramebufferScaleFactor = function(t) {
                            s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }, this.setReferenceSpaceType = function(t) {
                            a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }, this.getReferenceSpace = function() {
                            return o
                        }, this.getBaseLayer = function() {
                            return null !== h ? h : d
                        }, this.getBinding = function() {
                            return l
                        }, this.getFrame = function() {
                            return v
                        }, this.getSession = function() {
                            return i
                        }, this.setSession = async
                        function(t) {
                            if (i = t, null !== i) {
                                i.addEventListener("select", L), i.addEventListener("selectstart", L), i.addEventListener("selectend", L), i.addEventListener("squeeze", L), i.addEventListener("squeezestart", L), i.addEventListener("squeezeend", L), i.addEventListener("end", R), i.addEventListener("inputsourceschange", P);
                                const t = e.getContextAttributes();
                                if (!0 !== t.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers) {
                                    const n = {
                                        antialias: t.antialias,
                                        alpha: t.alpha,
                                        depth: t.depth,
                                        stencil: t.stencil,
                                        framebufferScaleFactor: s
                                    };
                                    d = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                        baseLayer: d
                                    })
                                } else if (e instanceof WebGLRenderingContext) {
                                    const n = {
                                        antialias: !0,
                                        alpha: t.alpha,
                                        depth: t.depth,
                                        stencil: t.stencil,
                                        framebufferScaleFactor: s
                                    };
                                    d = new XRWebGLLayer(i, e, n), i.updateRenderState({
                                        layers: [d]
                                    })
                                } else {
                                    p = t.antialias;
                                    let n = null;
                                    t.depth && (x = 256, t.stencil && (x |= 1024), y = t.stencil ? 33306 : 36096, n = t.stencil ? 35056 : 33190);
                                    const o = {
                                        colorFormat: t.alpha ? 32856 : 32849,
                                        depthFormat: n,
                                        scaleFactor: s
                                    };
                                    l = new XRWebGLBinding(i, e), h = l.createProjectionLayer(o), u = e.createFramebuffer(), i.updateRenderState({
                                        layers: [h]
                                    }), p && (f = e.createFramebuffer(), m = e.createRenderbuffer(), e.bindRenderbuffer(36161, m), e.renderbufferStorageMultisample(36161, 4, 32856, h.textureWidth, h.textureHeight), r.bindFramebuffer(36160, f), e.framebufferRenderbuffer(36160, 36064, 36161, m), e.bindRenderbuffer(36161, null), null !== n && (g = e.createRenderbuffer(), e.bindRenderbuffer(36161, g), e.renderbufferStorageMultisample(36161, 4, n, h.textureWidth, h.textureHeight), e.framebufferRenderbuffer(36160, y, 36161, g), e.bindRenderbuffer(36161, null)), r.bindFramebuffer(36160, null))
                                }
                                o = await i.requestReferenceSpace(a), N.setContext(i), N.start(), n.isPresenting = !0, n.dispatchEvent({
                                    type: "sessionstart"
                                })
                            }
                        };
                        const C = new Et,
                            I = new Et;

                        function D(t, e) {
                            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                        }
                        this.updateCamera = function(t) {
                            if (null === i) return;
                            T.near = M.near = w.near = t.near, T.far = M.far = w.far = t.far, E === T.near && A === T.far || (i.updateRenderState({
                                depthNear: T.near,
                                depthFar: T.far
                            }), E = T.near, A = T.far);
                            const e = t.parent,
                                n = T.cameras;
                            D(T, e);
                            for (let t = 0; t < n.length; t++) D(n[t], e);
                            T.matrixWorld.decompose(T.position, T.quaternion, T.scale), t.position.copy(T.position), t.quaternion.copy(T.quaternion), t.scale.copy(T.scale), t.matrix.copy(T.matrix), t.matrixWorld.copy(T.matrixWorld);
                            const r = t.children;
                            for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                            2 === n.length ? function(t, e, n) {
                                C.setFromMatrixPosition(e.matrixWorld), I.setFromMatrixPosition(n.matrixWorld);
                                const r = C.distanceTo(I),
                                    i = e.projectionMatrix.elements,
                                    s = n.projectionMatrix.elements,
                                    o = i[14] / (i[10] - 1),
                                    a = i[14] / (i[10] + 1),
                                    c = (i[9] + 1) / i[5],
                                    l = (i[9] - 1) / i[5],
                                    u = (i[8] - 1) / i[0],
                                    h = (s[8] + 1) / s[0],
                                    d = o * u,
                                    p = o * h,
                                    f = r / (-u + h),
                                    m = f * -u;
                                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                const g = o + f,
                                    v = a + f,
                                    y = d - m,
                                    x = p + (r - m),
                                    _ = c * a / v * g,
                                    b = l * a / v * g;
                                t.projectionMatrix.makePerspective(y, x, _, b, g, v)
                            }(T, w, M) : T.projectionMatrix.copy(w.projectionMatrix)
                        }, this.getCamera = function() {
                            return T
                        }, this.getFoveation = function() {
                            return null !== h ? h.fixedFoveation : null !== d ? d.fixedFoveation : void 0
                        }, this.setFoveation = function(t) {
                            null !== h && (h.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
                        };
                        let O = null;
                        const N = new qn;
                        N.setAnimationLoop((function(t, n) {
                            if (c = n.getViewerPose(o), v = n, null !== c) {
                                const t = c.views;
                                null !== d && r.bindXRFramebuffer(d.framebuffer);
                                let n = !1;
                                t.length !== T.cameras.length && (T.cameras.length = 0, n = !0);
                                for (let i = 0; i < t.length; i++) {
                                    const s = t[i];
                                    let o = null;
                                    if (null !== d) o = d.getViewport(s);
                                    else {
                                        const t = l.getViewSubImage(h, s);
                                        r.bindXRFramebuffer(u), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, y, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), o = t.viewport
                                    }
                                    const a = S[i];
                                    a.matrix.fromArray(s.transform.matrix), a.projectionMatrix.fromArray(s.projectionMatrix), a.viewport.set(o.x, o.y, o.width, o.height), 0 === i && T.matrix.copy(a.matrix), !0 === n && T.cameras.push(a)
                                }
                                p && (r.bindXRFramebuffer(f), null !== x && e.clear(x))
                            }
                            const s = i.inputSources;
                            for (let t = 0; t < _.length; t++) {
                                const e = _[t],
                                    r = s[t];
                                e.update(r, n, o)
                            }
                            if (O && O(t, n), p) {
                                const t = h.textureWidth,
                                    n = h.textureHeight;
                                r.bindFramebuffer(36008, f), r.bindFramebuffer(36009, u), e.invalidateFramebuffer(36008, [y]), e.invalidateFramebuffer(36009, [y]), e.blitFramebuffer(0, 0, t, n, 0, 0, t, n, 16384, 9728), e.invalidateFramebuffer(36008, [36064]), r.bindFramebuffer(36008, null), r.bindFramebuffer(36009, null), r.bindFramebuffer(36160, f)
                            }
                            v = null
                        })), this.setAnimationLoop = function(t) {
                            O = t
                        }, this.dispose = function() {}
                    }
                }

                function Rs(t) {
                    function e(e, n) {
                        e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
                        const r = t.get(n).envMap;
                        if (r) {
                            e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio;
                            const i = t.get(r).__maxMipLevel;
                            void 0 !== i && (e.maxMipLevel.value = i)
                        }
                        let i, s;
                        n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? i = n.clearcoatRoughnessMap : n.specularIntensityMap ? i = n.specularIntensityMap : n.specularTintMap ? i = n.specularTintMap : n.transmissionMap ? i = n.transmissionMap : n.thicknessMap && (i = n.thicknessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                    }

                    function n(e, n) {
                        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
                        t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                    }
                    return {
                        refreshFogUniforms: function(t, e) {
                            t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                        },
                        refreshMaterialUniforms: function(t, r, i, s, o) {
                            r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function(t, e) {
                                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                            }(t, r)) : r.isMeshToonMaterial ? (e(t, r), function(t, e) {
                                e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function(t, e) {
                                t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function(t, e, r) {
                                n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenTint.value.copy(e.sheenTint).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness), e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate())), e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = r.texture, t.transmissionSamplerSize.value.set(r.width, r.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationTint.value.copy(e.attenuationTint)), t.specularIntensity.value = e.specularIntensity, t.specularTint.value.copy(e.specularTint), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularTintMap && (t.specularTintMap.value = e.specularTintMap)
                            }(t, r, o) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function(t, e) {
                                e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function(t, e) {
                                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function(t, e) {
                                e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                            }(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function(t, e) {
                                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                            }(t, r)) : r.isLineBasicMaterial ? (function(t, e) {
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                            }(t, r), r.isLineDashedMaterial && function(t, e) {
                                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                            }(t, r)) : r.isPointsMaterial ? function(t, e, n, r) {
                                let i;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? i = e.map : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                            }(t, r, i, s) : r.isSpriteMaterial ? function(t, e) {
                                let n;
                                t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                            }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                        }
                    }
                }

                function Ps(t = {}) {
                    const e = void 0 !== t.canvas ? t.canvas : function() {
                            const t = gt("canvas");
                            return t.style.display = "block", t
                        }(),
                        n = void 0 !== t.context ? t.context : null,
                        r = void 0 !== t.alpha && t.alpha,
                        i = void 0 === t.depth || t.depth,
                        s = void 0 === t.stencil || t.stencil,
                        a = void 0 !== t.antialias && t.antialias,
                        c = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                        u = void 0 !== t.powerPreference ? t.powerPreference : "default",
                        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                    let d = null,
                        p = null;
                    const f = [],
                        m = [];
                    this.domElement = e, this.debug = {
                        checkShaderErrors: !0
                    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = X, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                    const g = this;
                    let v = !1,
                        y = 0,
                        x = 0,
                        w = null,
                        M = -1,
                        T = null;
                    const A = new wt,
                        L = new wt;
                    let R = null,
                        P = e.width,
                        N = e.height,
                        B = 1,
                        F = null,
                        k = null;
                    const U = new wt(0, 0, P, N),
                        H = new wt(0, 0, P, N);
                    let G = !1;
                    const V = [],
                        W = new Zn;
                    let j = !1,
                        Z = !1,
                        q = null;
                    const Y = new re,
                        J = new Et,
                        K = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };

                    function Q() {
                        return null === w ? B : 1
                    }
                    let $, tt, et, nt, rt, it, st, ot, at, ct, lt, ut, ht, dt, pt, ft, mt, vt, yt, xt, _t, bt, Tt, At = n;

                    function Lt(t, n) {
                        for (let r = 0; r < t.length; r++) {
                            const i = t[r],
                                s = e.getContext(i, n);
                            if (null !== s) return s
                        }
                        return null
                    }
                    try {
                        const t = {
                            alpha: r,
                            depth: i,
                            stencil: s,
                            antialias: a,
                            premultipliedAlpha: c,
                            preserveDrawingBuffer: l,
                            powerPreference: u,
                            failIfMajorPerformanceCaveat: h
                        };
                        if (e.addEventListener("webglcontextlost", Ct, !1), e.addEventListener("webglcontextrestored", It, !1), null === At) {
                            const e = ["webgl2", "webgl", "experimental-webgl"];
                            if (!0 === g.isWebGL1Renderer && e.shift(), At = Lt(e, t), null === At) throw Lt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                        }
                        void 0 === At.getShaderPrecisionFormat && (At.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        })
                    } catch (t) {
                        throw console.error("THREE.WebGLRenderer: " + t.message), t
                    }

                    function Rt() {
                        $ = new Ar(At), tt = new nr(At, $, t), $.init(tt), bt = new Ms(At, $, tt), et = new bs(At, $, tt), V[0] = 1029, nt = new Pr(At), rt = new as, it = new ws(At, $, et, rt, tt, bt, nt), st = new ir(g), ot = new Er(g), at = new Xn(At, tt), Tt = new tr(At, $, at, tt), ct = new Lr(At, at, nt, Tt), lt = new Br(At, ct, at, nt), yt = new Nr(At, tt, it), ft = new rr(rt), ut = new os(g, st, ot, $, tt, Tt, ft), ht = new Rs(rt), dt = new hs(rt), pt = new vs($, tt), vt = new $n(g, st, et, lt, c), mt = new _s(g, lt, tt), xt = new er(At, $, nt, tt), _t = new Rr(At, $, nt, tt), nt.programs = ut.programs, g.capabilities = tt, g.extensions = $, g.properties = rt, g.renderLists = dt, g.shadowMap = mt, g.state = et, g.info = nt
                    }
                    Rt();
                    const Pt = new Ls(g, At);

                    function Ct(t) {
                        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = !0
                    }

                    function It() {
                        console.log("THREE.WebGLRenderer: Context Restored."), v = !1;
                        const t = nt.autoReset,
                            e = mt.enabled,
                            n = mt.autoUpdate,
                            r = mt.needsUpdate,
                            i = mt.type;
                        Rt(), nt.autoReset = t, mt.enabled = e, mt.autoUpdate = n, mt.needsUpdate = r, mt.type = i
                    }

                    function Dt(t) {
                        const e = t.target;
                        e.removeEventListener("dispose", Dt),
                            function(t) {
                                (function(t) {
                                    const e = rt.get(t).programs;
                                    void 0 !== e && e.forEach((function(t) {
                                        ut.releaseProgram(t)
                                    }))
                                })(t), rt.remove(t)
                            }(e)
                    }
                    this.xr = Pt, this.getContext = function() {
                        return At
                    }, this.getContextAttributes = function() {
                        return At.getContextAttributes()
                    }, this.forceContextLoss = function() {
                        const t = $.get("WEBGL_lose_context");
                        t && t.loseContext()
                    }, this.forceContextRestore = function() {
                        const t = $.get("WEBGL_lose_context");
                        t && t.restoreContext()
                    }, this.getPixelRatio = function() {
                        return B
                    }, this.setPixelRatio = function(t) {
                        void 0 !== t && (B = t, this.setSize(P, N, !1))
                    }, this.getSize = function(t) {
                        return t.set(P, N)
                    }, this.setSize = function(t, n, r) {
                        Pt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = t, N = n, e.width = Math.floor(t * B), e.height = Math.floor(n * B), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                    }, this.getDrawingBufferSize = function(t) {
                        return t.set(P * B, N * B).floor()
                    }, this.setDrawingBufferSize = function(t, n, r) {
                        P = t, N = n, B = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
                    }, this.getCurrentViewport = function(t) {
                        return t.copy(A)
                    }, this.getViewport = function(t) {
                        return t.copy(U)
                    }, this.setViewport = function(t, e, n, r) {
                        t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, n, r), et.viewport(A.copy(U).multiplyScalar(B).floor())
                    }, this.getScissor = function(t) {
                        return t.copy(H)
                    }, this.setScissor = function(t, e, n, r) {
                        t.isVector4 ? H.set(t.x, t.y, t.z, t.w) : H.set(t, e, n, r), et.scissor(L.copy(H).multiplyScalar(B).floor())
                    }, this.getScissorTest = function() {
                        return G
                    }, this.setScissorTest = function(t) {
                        et.setScissorTest(G = t)
                    }, this.setOpaqueSort = function(t) {
                        F = t
                    }, this.setTransparentSort = function(t) {
                        k = t
                    }, this.getClearColor = function(t) {
                        return t.copy(vt.getClearColor())
                    }, this.setClearColor = function() {
                        vt.setClearColor.apply(vt, arguments)
                    }, this.getClearAlpha = function() {
                        return vt.getClearAlpha()
                    }, this.setClearAlpha = function() {
                        vt.setClearAlpha.apply(vt, arguments)
                    }, this.clear = function(t, e, n) {
                        let r = 0;
                        (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), At.clear(r)
                    }, this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }, this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }, this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }, this.dispose = function() {
                        e.removeEventListener("webglcontextlost", Ct, !1), e.removeEventListener("webglcontextrestored", It, !1), dt.dispose(), pt.dispose(), rt.dispose(), st.dispose(), ot.dispose(), lt.dispose(), Tt.dispose(), Pt.dispose(), Pt.removeEventListener("sessionstart", Nt), Pt.removeEventListener("sessionend", Bt), q && (q.dispose(), q = null), zt.stop()
                    }, this.renderBufferImmediate = function(t, e) {
                        Tt.initAttributes();
                        const n = rt.get(t);
                        t.hasPositions && !n.position && (n.position = At.createBuffer()), t.hasNormals && !n.normal && (n.normal = At.createBuffer()), t.hasUvs && !n.uv && (n.uv = At.createBuffer()), t.hasColors && !n.color && (n.color = At.createBuffer());
                        const r = e.getAttributes();
                        t.hasPositions && (At.bindBuffer(34962, n.position), At.bufferData(34962, t.positionArray, 35048), Tt.enableAttribute(r.position.location), At.vertexAttribPointer(r.position.location, 3, 5126, !1, 0, 0)), t.hasNormals && (At.bindBuffer(34962, n.normal), At.bufferData(34962, t.normalArray, 35048), Tt.enableAttribute(r.normal.location), At.vertexAttribPointer(r.normal.location, 3, 5126, !1, 0, 0)), t.hasUvs && (At.bindBuffer(34962, n.uv), At.bufferData(34962, t.uvArray, 35048), Tt.enableAttribute(r.uv.location), At.vertexAttribPointer(r.uv.location, 2, 5126, !1, 0, 0)), t.hasColors && (At.bindBuffer(34962, n.color), At.bufferData(34962, t.colorArray, 35048), Tt.enableAttribute(r.color.location), At.vertexAttribPointer(r.color.location, 3, 5126, !1, 0, 0)), Tt.disableUnusedAttributes(), At.drawArrays(4, 0, t.count), t.count = 0
                    }, this.renderBufferDirect = function(t, e, n, r, i, s) {
                        null === e && (e = K);
                        const o = i.isMesh && i.matrixWorld.determinant() < 0,
                            a = Vt(t, e, n, r, i);
                        et.setMaterial(r, o);
                        let c = n.index;
                        const l = n.attributes.position;
                        if (null === c) {
                            if (void 0 === l || 0 === l.count) return
                        } else if (0 === c.count) return;
                        let u, h = 1;
                        !0 === r.wireframe && (c = ct.getWireframeAttribute(n), h = 2), Tt.setup(i, r, a, n, c);
                        let d = xt;
                        null !== c && (u = at.get(c), d = _t, d.setIndex(u));
                        const p = null !== c ? c.count : l.count,
                            f = n.drawRange.start * h,
                            m = n.drawRange.count * h,
                            g = null !== s ? s.start * h : 0,
                            v = null !== s ? s.count * h : 1 / 0,
                            y = Math.max(f, g),
                            x = Math.min(p, f + m, g + v) - 1,
                            _ = Math.max(0, x - y + 1);
                        if (0 !== _) {
                            if (i.isMesh) !0 === r.wireframe ? (et.setLineWidth(r.wireframeLinewidth * Q()), d.setMode(1)) : d.setMode(4);
                            else if (i.isLine) {
                                let t = r.linewidth;
                                void 0 === t && (t = 1), et.setLineWidth(t * Q()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
                            if (i.isInstancedMesh) d.renderInstances(y, _, i.count);
                            else if (n.isInstancedBufferGeometry) {
                                const t = Math.min(n.instanceCount, n._maxInstanceCount);
                                d.renderInstances(y, _, t)
                            } else d.render(y, _)
                        }
                    }, this.compile = function(t, e) {
                        p = pt.get(t), p.init(), m.push(p), t.traverseVisible((function(t) {
                            t.isLight && t.layers.test(e.layers) && (p.pushLight(t), t.castShadow && p.pushShadow(t))
                        })), p.setupLights(g.physicallyCorrectLights), t.traverse((function(e) {
                            const n = e.material;
                            if (n)
                                if (Array.isArray(n))
                                    for (let r = 0; r < n.length; r++) {
                                        Ht(n[r], t, e)
                                    } else Ht(n, t, e)
                        })), m.pop(), p = null
                    };
                    let Ot = null;

                    function Nt() {
                        zt.stop()
                    }

                    function Bt() {
                        zt.start()
                    }
                    const zt = new qn;

                    function Ft(t, e, n, r) {
                        const i = t.opaque,
                            s = t.transmissive,
                            o = t.transparent;
                        p.setupLightsView(n), s.length > 0 && function(t, e, n) {
                            if (null === q) {
                                const t = !0 === a && !0 === tt.isWebGL2;
                                q = new(t ? St : Mt)(1024, 1024, {
                                    generateMipmaps: !0,
                                    type: null !== bt.convert(O) ? O : I,
                                    minFilter: C,
                                    magFilter: E,
                                    wrapS: S,
                                    wrapT: S
                                })
                            }
                            const r = g.getRenderTarget();
                            g.setRenderTarget(q), g.clear();
                            const i = g.toneMapping;
                            g.toneMapping = 0, kt(t, e, n), g.toneMapping = i, it.updateMultisampleRenderTarget(q), it.updateRenderTargetMipmap(q), g.setRenderTarget(r)
                        }(i, e, n), r && et.viewport(A.copy(r)), i.length > 0 && kt(i, e, n), s.length > 0 && kt(s, e, n), o.length > 0 && kt(o, e, n)
                    }

                    function kt(t, e, n) {
                        const r = !0 === e.isScene ? e.overrideMaterial : null;
                        for (let i = 0, s = t.length; i < s; i++) {
                            const s = t[i],
                                o = s.object,
                                a = s.geometry,
                                c = null === r ? s.material : r,
                                l = s.group;
                            o.layers.test(n.layers) && Ut(o, e, n, a, c, l)
                        }
                    }

                    function Ut(t, e, n, r, i, s) {
                        if (t.onBeforeRender(g, e, n, r, i, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), i.onBeforeRender(g, e, n, r, t, s), t.isImmediateRenderObject) {
                            const s = Vt(n, e, r, i, t);
                            et.setMaterial(i), Tt.reset(),
                                function(t, e) {
                                    t.render((function(t) {
                                        g.renderBufferImmediate(t, e)
                                    }))
                                }(t, s)
                        } else !0 === i.transparent && i.side === b ? (i.side = 1, i.needsUpdate = !0, g.renderBufferDirect(n, e, r, i, t, s), i.side = _, i.needsUpdate = !0, g.renderBufferDirect(n, e, r, i, t, s), i.side = b) : g.renderBufferDirect(n, e, r, i, t, s);
                        t.onAfterRender(g, e, n, r, i, s)
                    }

                    function Ht(t, e, n) {
                        !0 !== e.isScene && (e = K);
                        const r = rt.get(t),
                            i = p.state.lights,
                            s = p.state.shadowsArray,
                            o = i.state.version,
                            a = ut.getParameters(t, i.state, s, e, n),
                            c = ut.getProgramCacheKey(a);
                        let l = r.programs;
                        r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = (t.isMeshStandardMaterial ? ot : st).get(t.envMap || r.environment), void 0 === l && (t.addEventListener("dispose", Dt), l = new Map, r.programs = l);
                        let u = l.get(c);
                        if (void 0 !== u) {
                            if (r.currentProgram === u && r.lightsStateVersion === o) return Gt(t, a), u
                        } else a.uniforms = ut.getUniforms(t), t.onBuild(a, g), t.onBeforeCompile(a, g), u = ut.acquireProgram(a, c), l.set(c, u), r.uniforms = a.uniforms;
                        const h = r.uniforms;
                        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (h.clippingPlanes = ft.uniform), Gt(t, a), r.needsLights = function(t) {
                            return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                        }(t), r.lightsStateVersion = o, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotShadowMatrix.value = i.state.spotShadowMatrix, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
                        const d = u.getUniforms(),
                            f = ki.seqWithValue(d.seq, h);
                        return r.currentProgram = u, r.uniformsList = f, u
                    }

                    function Gt(t, e) {
                        const n = rt.get(t);
                        n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents
                    }

                    function Vt(t, e, n, r, i) {
                        !0 !== e.isScene && (e = K), it.resetTextureUnits();
                        const s = e.fog,
                            o = r.isMeshStandardMaterial ? e.environment : null,
                            a = null === w ? g.outputEncoding : w.texture.encoding,
                            c = (r.isMeshStandardMaterial ? ot : st).get(r.envMap || o),
                            l = !0 === r.vertexColors && !!n && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                            u = !!r.normalMap && !!n && !!n.attributes.tangent,
                            h = !!n && !!n.morphAttributes.position,
                            d = !!n && !!n.morphAttributes.normal,
                            f = n && n.morphAttributes.position ? n.morphAttributes.position.length : 0,
                            m = rt.get(r),
                            v = p.state.lights;
                        if (!0 === j && (!0 === Z || t !== T)) {
                            const e = t === T && r.id === M;
                            ft.setState(r, t, e)
                        }
                        let y = !1;
                        r.version === m.__version ? m.needsLights && m.lightsStateVersion !== v.state.version || m.outputEncoding !== a || i.isInstancedMesh && !1 === m.instancing ? y = !0 : i.isInstancedMesh || !0 !== m.instancing ? i.isSkinnedMesh && !1 === m.skinning ? y = !0 : i.isSkinnedMesh || !0 !== m.skinning ? m.envMap !== c || r.fog && m.fog !== s ? y = !0 : void 0 === m.numClippingPlanes || m.numClippingPlanes === ft.numPlanes && m.numIntersection === ft.numIntersection ? (m.vertexAlphas !== l || m.vertexTangents !== u || m.morphTargets !== h || m.morphNormals !== d || !0 === tt.isWebGL2 && m.morphTargetsCount !== f) && (y = !0) : y = !0 : y = !0 : y = !0 : (y = !0, m.__version = r.version);
                        let x = m.currentProgram;
                        !0 === y && (x = Ht(r, e, i));
                        let _ = !1,
                            b = !1,
                            S = !1;
                        const E = x.getUniforms(),
                            A = m.uniforms;
                        if (et.useProgram(x.program) && (_ = !0, b = !0, S = !0), r.id !== M && (M = r.id, b = !0), _ || T !== t) {
                            if (E.setValue(At, "projectionMatrix", t.projectionMatrix), tt.logarithmicDepthBuffer && E.setValue(At, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), T !== t && (T = t, b = !0, S = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
                                const e = E.map.cameraPosition;
                                void 0 !== e && e.setValue(At, J.setFromMatrixPosition(t.matrixWorld))
                            }(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && E.setValue(At, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && E.setValue(At, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (i.isSkinnedMesh) {
                            E.setOptional(At, i, "bindMatrix"), E.setOptional(At, i, "bindMatrixInverse");
                            const t = i.skeleton;
                            t && (tt.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), E.setValue(At, "boneTexture", t.boneTexture, it), E.setValue(At, "boneTextureSize", t.boneTextureSize)) : E.setOptional(At, t, "boneMatrices"))
                        }
                        return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || yt.update(i, n, r, x), (b || m.receiveShadow !== i.receiveShadow) && (m.receiveShadow = i.receiveShadow, E.setValue(At, "receiveShadow", i.receiveShadow)), b && (E.setValue(At, "toneMappingExposure", g.toneMappingExposure), m.needsLights && function(t, e) {
                            t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.directionalLightShadows.needsUpdate = e, t.pointLights.needsUpdate = e, t.pointLightShadows.needsUpdate = e, t.spotLights.needsUpdate = e, t.spotLightShadows.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                        }(A, S), s && r.fog && ht.refreshFogUniforms(A, s), ht.refreshMaterialUniforms(A, r, B, N, q), ki.upload(At, m.uniformsList, A, it)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (ki.upload(At, m.uniformsList, A, it), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && E.setValue(At, "center", i.center), E.setValue(At, "modelViewMatrix", i.modelViewMatrix), E.setValue(At, "normalMatrix", i.normalMatrix), E.setValue(At, "modelMatrix", i.matrixWorld), x
                    }
                    zt.setAnimationLoop((function(t) {
                        Ot && Ot(t)
                    })), void 0 !== o && zt.setContext(o), this.setAnimationLoop = function(t) {
                        Ot = t, Pt.setAnimationLoop(t), null === t ? zt.stop() : zt.start()
                    }, Pt.addEventListener("sessionstart", Nt), Pt.addEventListener("sessionend", Bt), this.render = function(t, e) {
                        if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === v) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === Pt.enabled && !0 === Pt.isPresenting && (!0 === Pt.cameraAutoUpdate && Pt.updateCamera(e), e = Pt.getCamera()), !0 === t.isScene && t.onBeforeRender(g, t, e, w), p = pt.get(t, m.length), p.init(), m.push(p), Y.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), W.setFromProjectionMatrix(Y), Z = this.localClippingEnabled, j = ft.init(this.clippingPlanes, Z, e), d = dt.get(t, f.length), d.init(), f.push(d),
                            function t(e, n, r, i) {
                                if (!1 === e.visible) return;
                                if (e.layers.test(n.layers))
                                    if (e.isGroup) r = e.renderOrder;
                                    else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                                else if (e.isLight) p.pushLight(e), e.castShadow && p.pushShadow(e);
                                else if (e.isSprite) {
                                    if (!e.frustumCulled || W.intersectsSprite(e)) {
                                        i && J.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Y);
                                        const t = lt.update(e),
                                            n = e.material;
                                        n.visible && d.push(e, t, n, r, J.z, null)
                                    }
                                } else if (e.isImmediateRenderObject) i && J.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Y), d.push(e, null, e.material, r, J.z, null);
                                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== nt.render.frame && (e.skeleton.update(), e.skeleton.frame = nt.render.frame), !e.frustumCulled || W.intersectsObject(e))) {
                                    i && J.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Y);
                                    const t = lt.update(e),
                                        n = e.material;
                                    if (Array.isArray(n)) {
                                        const i = t.groups;
                                        for (let s = 0, o = i.length; s < o; s++) {
                                            const o = i[s],
                                                a = n[o.materialIndex];
                                            a && a.visible && d.push(e, t, a, r, J.z, o)
                                        }
                                    } else n.visible && d.push(e, t, n, r, J.z, null)
                                }
                                const s = e.children;
                                for (let e = 0, o = s.length; e < o; e++) t(s[e], n, r, i)
                            }(t, e, 0, g.sortObjects), d.finish(), !0 === g.sortObjects && d.sort(F, k), !0 === j && ft.beginShadows();
                        const n = p.state.shadowsArray;
                        if (mt.render(n, t, e), !0 === j && ft.endShadows(), !0 === this.info.autoReset && this.info.reset(), vt.render(d, t), p.setupLights(g.physicallyCorrectLights), e.isArrayCamera) {
                            const n = e.cameras;
                            for (let e = 0, r = n.length; e < r; e++) {
                                const r = n[e];
                                Ft(d, t, r, r.viewport)
                            }
                        } else Ft(d, t, e);
                        null !== w && (it.updateMultisampleRenderTarget(w), it.updateRenderTargetMipmap(w)), !0 === t.isScene && t.onAfterRender(g, t, e), et.buffers.depth.setTest(!0), et.buffers.depth.setMask(!0), et.buffers.color.setMask(!0), et.setPolygonOffset(!1), Tt.resetDefaultState(), M = -1, T = null, m.pop(), p = m.length > 0 ? m[m.length - 1] : null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null
                    }, this.getActiveCubeFace = function() {
                        return y
                    }, this.getActiveMipmapLevel = function() {
                        return x
                    }, this.getRenderTarget = function() {
                        return w
                    }, this.setRenderTarget = function(t, e = 0, n = 0) {
                        w = t, y = e, x = n, t && void 0 === rt.get(t).__webglFramebuffer && it.setupRenderTarget(t);
                        let r = null,
                            i = !1,
                            s = !1;
                        if (t) {
                            const n = t.texture;
                            (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                            const o = rt.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget ? (r = o[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? rt.get(t).__webglMultisampledFramebuffer : o, A.copy(t.viewport), L.copy(t.scissor), R = t.scissorTest
                        } else A.copy(U).multiplyScalar(B).floor(), L.copy(H).multiplyScalar(B).floor(), R = G;
                        if (et.bindFramebuffer(36160, r) && tt.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const n = t.texture;
                                    if (V.length !== n.length || 36064 !== V[0]) {
                                        for (let t = 0, e = n.length; t < e; t++) V[t] = 36064 + t;
                                        V.length = n.length, e = !0
                                    }
                                } else 1 === V.length && 36064 === V[0] || (V[0] = 36064, V.length = 1, e = !0);
                            else 1 === V.length && 1029 === V[0] || (V[0] = 1029, V.length = 1, e = !0);
                            e && (tt.isWebGL2 ? At.drawBuffers(V) : $.get("WEBGL_draw_buffers").drawBuffersWEBGL(V))
                        }
                        if (et.viewport(A), et.scissor(L), et.setScissorTest(R), i) {
                            const r = rt.get(t.texture);
                            At.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
                        } else if (s) {
                            const r = rt.get(t.texture),
                                i = e || 0;
                            At.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
                        }
                        M = -1
                    }, this.readRenderTargetPixels = function(t, e, n, r, i, s, o) {
                        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let a = rt.get(t).__webglFramebuffer;
                        if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                            et.bindFramebuffer(36160, a);
                            try {
                                const o = t.texture,
                                    a = o.format,
                                    c = o.type;
                                if (a !== z && bt.convert(a) !== At.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                const l = c === O && ($.has("EXT_color_buffer_half_float") || tt.isWebGL2 && $.has("EXT_color_buffer_float"));
                                if (!(c === I || bt.convert(c) === At.getParameter(35738) || c === D && (tt.isWebGL2 || $.has("OES_texture_float") || $.has("WEBGL_color_buffer_float")) || l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === At.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && At.readPixels(e, n, r, i, bt.convert(a), bt.convert(c), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                const t = null !== w ? rt.get(w).__webglFramebuffer : null;
                                et.bindFramebuffer(36160, t)
                            }
                        }
                    }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                        const r = Math.pow(2, -n),
                            i = Math.floor(e.image.width * r),
                            s = Math.floor(e.image.height * r);
                        let o = bt.convert(e.format);
                        tt.isWebGL2 && (6407 === o && (o = 32849), 6408 === o && (o = 32856)), it.setTexture2D(e, 0), At.copyTexImage2D(3553, n, o, t.x, t.y, i, s, 0), et.unbindTexture()
                    }, this.copyTextureToTexture = function(t, e, n, r = 0) {
                        const i = e.image.width,
                            s = e.image.height,
                            o = bt.convert(n.format),
                            a = bt.convert(n.type);
                        it.setTexture2D(n, 0), At.pixelStorei(37440, n.flipY), At.pixelStorei(37441, n.premultiplyAlpha), At.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? At.texSubImage2D(3553, r, t.x, t.y, i, s, o, a, e.image.data) : e.isCompressedTexture ? At.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : At.texSubImage2D(3553, r, t.x, t.y, o, a, e.image), 0 === r && n.generateMipmaps && At.generateMipmap(3553), et.unbindTexture()
                    }, this.copyTextureToTexture3D = function(t, e, n, r, i = 0) {
                        if (g.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                        const s = t.max.x - t.min.x + 1,
                            o = t.max.y - t.min.y + 1,
                            a = t.max.z - t.min.z + 1,
                            c = bt.convert(r.format),
                            l = bt.convert(r.type);
                        let u;
                        if (r.isDataTexture3D) it.setTexture3D(r, 0), u = 32879;
                        else {
                            if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                            it.setTexture2DArray(r, 0), u = 35866
                        }
                        At.pixelStorei(37440, r.flipY), At.pixelStorei(37441, r.premultiplyAlpha), At.pixelStorei(3317, r.unpackAlignment);
                        const h = At.getParameter(3314),
                            d = At.getParameter(32878),
                            p = At.getParameter(3316),
                            f = At.getParameter(3315),
                            m = At.getParameter(32877),
                            v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                        At.pixelStorei(3314, v.width), At.pixelStorei(32878, v.height), At.pixelStorei(3316, t.min.x), At.pixelStorei(3315, t.min.y), At.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? At.texSubImage3D(u, i, e.x, e.y, e.z, s, o, a, c, l, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), At.compressedTexSubImage3D(u, i, e.x, e.y, e.z, s, o, a, c, v.data)) : At.texSubImage3D(u, i, e.x, e.y, e.z, s, o, a, c, l, v), At.pixelStorei(3314, h), At.pixelStorei(32878, d), At.pixelStorei(3316, p), At.pixelStorei(3315, f), At.pixelStorei(32877, m), 0 === i && r.generateMipmaps && At.generateMipmap(u), et.unbindTexture()
                    }, this.initTexture = function(t) {
                        it.setTexture2D(t, 0), et.unbindTexture()
                    }, this.resetState = function() {
                        y = 0, x = 0, w = null, et.reset(), Tt.reset()
                    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                class Cs extends Ps {}
                Cs.prototype.isWebGL1Renderer = !0;
                class Is {
                    constructor(t, e = 25e-5) {
                        this.name = "", this.color = new Xe(t), this.density = e
                    }
                    clone() {
                        return new Is(this.color, this.density)
                    }
                    toJSON() {
                        return {
                            type: "FogExp2",
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                Is.prototype.isFogExp2 = !0;
                class Ds {
                    constructor(t, e = 1, n = 1e3) {
                        this.name = "", this.color = new Xe(t), this.near = e, this.far = n
                    }
                    clone() {
                        return new Ds(this.color, this.near, this.far)
                    }
                    toJSON() {
                        return {
                            type: "Fog",
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                Ds.prototype.isFog = !0;
                class Os extends Le {
                    constructor() {
                        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: this
                        }))
                    }
                    copy(t, e) {
                        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                    }
                }
                Os.prototype.isScene = !0;
                class Ns {
                    constructor(t, e) {
                        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = K, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0, this.uuid = st()
                    }
                    onUploadCallback() {}
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setUsage(t) {
                        return this.usage = t, this
                    }
                    copy(t) {
                        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                    }
                    copyAt(t, e, n) {
                        t *= this.stride, n *= e.stride;
                        for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
                        return this
                    }
                    set(t, e = 0) {
                        return this.array.set(t, e), this
                    }
                    clone(t) {
                        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = st()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                            n = new this.constructor(e, this.stride);
                        return n.setUsage(this.usage), n
                    }
                    onUpload(t) {
                        return this.onUploadCallback = t, this
                    }
                    toJSON(t) {
                        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = st()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                Ns.prototype.isInterleavedBuffer = !0;
                const Bs = new Et;
                class zs {
                    constructor(t, e, n, r = !1) {
                        this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(t) {
                        this.data.needsUpdate = t
                    }
                    applyMatrix4(t) {
                        for (let e = 0, n = this.data.count; e < n; e++) Bs.x = this.getX(e), Bs.y = this.getY(e), Bs.z = this.getZ(e), Bs.applyMatrix4(t), this.setXYZ(e, Bs.x, Bs.y, Bs.z);
                        return this
                    }
                    applyNormalMatrix(t) {
                        for (let e = 0, n = this.count; e < n; e++) Bs.x = this.getX(e), Bs.y = this.getY(e), Bs.z = this.getZ(e), Bs.applyNormalMatrix(t), this.setXYZ(e, Bs.x, Bs.y, Bs.z);
                        return this
                    }
                    transformDirection(t) {
                        for (let e = 0, n = this.count; e < n; e++) Bs.x = this.getX(e), Bs.y = this.getY(e), Bs.z = this.getZ(e), Bs.transformDirection(t), this.setXYZ(e, Bs.x, Bs.y, Bs.z);
                        return this
                    }
                    setX(t, e) {
                        return this.data.array[t * this.data.stride + this.offset] = e, this
                    }
                    setY(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                    }
                    setZ(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                    }
                    setW(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                    }
                    getX(t) {
                        return this.data.array[t * this.data.stride + this.offset]
                    }
                    getY(t) {
                        return this.data.array[t * this.data.stride + this.offset + 1]
                    }
                    getZ(t) {
                        return this.data.array[t * this.data.stride + this.offset + 2]
                    }
                    getW(t) {
                        return this.data.array[t * this.data.stride + this.offset + 3]
                    }
                    setXY(t, e, n) {
                        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                    }
                    setXYZ(t, e, n, r) {
                        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
                    }
                    setXYZW(t, e, n, r, i) {
                        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
                    }
                    clone(t) {
                        if (void 0 === t) {
                            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                            const t = [];
                            for (let e = 0; e < this.count; e++) {
                                const n = e * this.data.stride + this.offset;
                                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                            }
                            return new Qe(new this.array.constructor(t), this.itemSize, this.normalized)
                        }
                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new zs(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                    }
                    toJSON(t) {
                        if (void 0 === t) {
                            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                            const t = [];
                            for (let e = 0; e < this.count; e++) {
                                const n = e * this.data.stride + this.offset;
                                for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: t,
                                normalized: this.normalized
                            }
                        }
                        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                            isInterleavedBufferAttribute: !0,
                            itemSize: this.itemSize,
                            data: this.data.uuid,
                            offset: this.offset,
                            normalized: this.normalized
                        }
                    }
                }
                zs.prototype.isInterleavedBufferAttribute = !0;
                class Fs extends He {
                    constructor(t) {
                        super(), this.type = "SpriteMaterial", this.color = new Xe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                    }
                }
                let ks;
                Fs.prototype.isSpriteMaterial = !0;
                const Us = new Et,
                    Hs = new Et,
                    Gs = new Et,
                    Vs = new pt,
                    Ws = new pt,
                    js = new re,
                    Zs = new Et,
                    qs = new Et,
                    Xs = new Et,
                    Ys = new pt,
                    Js = new pt,
                    Ks = new pt;

                function Qs(t, e, n, r, i, s) {
                    Vs.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (Ws.x = s * Vs.x - i * Vs.y, Ws.y = i * Vs.x + s * Vs.y) : Ws.copy(Vs), t.copy(e), t.x += Ws.x, t.y += Ws.y, t.applyMatrix4(js)
                }(class extends Le {
                    constructor(t) {
                        if (super(), this.type = "Sprite", void 0 === ks) {
                            ks = new un;
                            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                                e = new Ns(t, 5);
                            ks.setIndex([0, 1, 2, 0, 2, 3]), ks.setAttribute("position", new zs(e, 3, 0, !1)), ks.setAttribute("uv", new zs(e, 2, 3, !1))
                        }
                        this.geometry = ks, this.material = void 0 !== t ? t : new Fs, this.center = new pt(.5, .5)
                    }
                    raycast(t, e) {
                        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Hs.setFromMatrixScale(this.matrixWorld), js.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Gs.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Hs.multiplyScalar(-Gs.z);
                        const n = this.material.rotation;
                        let r, i;
                        0 !== n && (i = Math.cos(n), r = Math.sin(n));
                        const s = this.center;
                        Qs(Zs.set(-.5, -.5, 0), Gs, s, Hs, r, i), Qs(qs.set(.5, -.5, 0), Gs, s, Hs, r, i), Qs(Xs.set(.5, .5, 0), Gs, s, Hs, r, i), Ys.set(0, 0), Js.set(1, 0), Ks.set(1, 1);
                        let o = t.ray.intersectTriangle(Zs, qs, Xs, !1, Us);
                        if (null === o && (Qs(qs.set(-.5, .5, 0), Gs, s, Hs, r, i), Js.set(0, 1), o = t.ray.intersectTriangle(Zs, Xs, qs, !1, Us), null === o)) return;
                        const a = t.ray.origin.distanceTo(Us);
                        a < t.near || a > t.far || e.push({
                            distance: a,
                            point: Us.clone(),
                            uv: ke.getUV(Us, Zs, qs, Xs, Ys, Js, Ks, new pt),
                            face: null,
                            object: this
                        })
                    }
                    copy(t) {
                        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                    }
                }).prototype.isSprite = !0;
                const $s = new Et,
                    to = new wt,
                    eo = new wt,
                    no = new Et,
                    ro = new re;
                class io extends Ln {
                    constructor(t, e) {
                        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new re, this.bindMatrixInverse = new re
                    }
                    copy(t) {
                        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                    }
                    bind(t, e) {
                        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const t = new wt,
                            e = this.geometry.attributes.skinWeight;
                        for (let n = 0, r = e.count; n < r; n++) {
                            t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                            const r = 1 / t.manhattanLength();
                            r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                        }
                    }
                    updateMatrixWorld(t) {
                        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                    }
                    boneTransform(t, e) {
                        const n = this.skeleton,
                            r = this.geometry;
                        to.fromBufferAttribute(r.attributes.skinIndex, t), eo.fromBufferAttribute(r.attributes.skinWeight, t), $s.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                        for (let t = 0; t < 4; t++) {
                            const r = eo.getComponent(t);
                            if (0 !== r) {
                                const i = to.getComponent(t);
                                ro.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]), e.addScaledVector(no.copy($s).applyMatrix4(ro), r)
                            }
                        }
                        return e.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                io.prototype.isSkinnedMesh = !0;
                class so extends Le {
                    constructor() {
                        super(), this.type = "Bone"
                    }
                }
                so.prototype.isBone = !0;
                class oo extends _t {
                    constructor(t = null, e = 1, n = 1, r, i, s, o, a, c = E, l = E, u, h) {
                        super(null, s, o, a, c, l, r, i, u, h), this.image = {
                            data: t,
                            width: e,
                            height: n
                        }, this.magFilter = c, this.minFilter = l, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                    }
                }
                oo.prototype.isDataTexture = !0;
                const ao = new re,
                    co = new re;
                class lo {
                    constructor(t = [], e = []) {
                        this.uuid = st(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                    }
                    init() {
                        const t = this.bones,
                            e = this.boneInverses;
                        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                        else if (t.length !== e.length) {
                            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                            for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new re)
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = new re;
                            this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                        }
                    }
                    pose() {
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                        }
                        for (let t = 0, e = this.bones.length; t < e; t++) {
                            const e = this.bones[t];
                            e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                        }
                    }
                    update() {
                        const t = this.bones,
                            e = this.boneInverses,
                            n = this.boneMatrices,
                            r = this.boneTexture;
                        for (let r = 0, i = t.length; r < i; r++) {
                            const i = t[r] ? t[r].matrixWorld : co;
                            ao.multiplyMatrices(i, e[r]), ao.toArray(n, 16 * r)
                        }
                        null !== r && (r.needsUpdate = !0)
                    }
                    clone() {
                        return new lo(this.bones, this.boneInverses)
                    }
                    computeBoneTexture() {
                        let t = Math.sqrt(4 * this.bones.length);
                        t = ut(t), t = Math.max(t, 4);
                        const e = new Float32Array(t * t * 4);
                        e.set(this.boneMatrices);
                        const n = new oo(e, t, t, z, D);
                        return this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
                    }
                    getBoneByName(t) {
                        for (let e = 0, n = this.bones.length; e < n; e++) {
                            const n = this.bones[e];
                            if (n.name === t) return n
                        }
                    }
                    dispose() {
                        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                    }
                    fromJSON(t, e) {
                        this.uuid = t.uuid;
                        for (let n = 0, r = t.bones.length; n < r; n++) {
                            const r = t.bones[n];
                            let i = e[r];
                            void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new so), this.bones.push(i), this.boneInverses.push((new re).fromArray(t.boneInverses[n]))
                        }
                        return this.init(), this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "Skeleton",
                                generator: "Skeleton.toJSON"
                            },
                            bones: [],
                            boneInverses: []
                        };
                        t.uuid = this.uuid;
                        const e = this.bones,
                            n = this.boneInverses;
                        for (let r = 0, i = e.length; r < i; r++) {
                            const i = e[r];
                            t.bones.push(i.uuid);
                            const s = n[r];
                            t.boneInverses.push(s.toArray())
                        }
                        return t
                    }
                }
                class uo extends Qe {
                    constructor(t, e, n, r = 1) {
                        "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r
                    }
                    copy(t) {
                        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                    }
                }
                uo.prototype.isInstancedBufferAttribute = !0;
                const ho = new re,
                    po = new re,
                    fo = [],
                    mo = new Ln;
                (class extends Ln {
                    constructor(t, e, n) {
                        super(t, e), this.instanceMatrix = new uo(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
                    }
                    copy(t) {
                        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                    }
                    getColorAt(t, e) {
                        e.fromArray(this.instanceColor.array, 3 * t)
                    }
                    getMatrixAt(t, e) {
                        e.fromArray(this.instanceMatrix.array, 16 * t)
                    }
                    raycast(t, e) {
                        const n = this.matrixWorld,
                            r = this.count;
                        if (mo.geometry = this.geometry, mo.material = this.material, void 0 !== mo.material)
                            for (let i = 0; i < r; i++) {
                                this.getMatrixAt(i, ho), po.multiplyMatrices(n, ho), mo.matrixWorld = po, mo.raycast(t, fo);
                                for (let t = 0, n = fo.length; t < n; t++) {
                                    const n = fo[t];
                                    n.instanceId = i, n.object = this, e.push(n)
                                }
                                fo.length = 0
                            }
                    }
                    setColorAt(t, e) {
                        null === this.instanceColor && (this.instanceColor = new uo(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                    }
                    setMatrixAt(t, e) {
                        e.toArray(this.instanceMatrix.array, 16 * t)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }).prototype.isInstancedMesh = !0;
                class go extends He {
                    constructor(t) {
                        super(), this.type = "LineBasicMaterial", this.color = new Xe(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
                    }
                }
                go.prototype.isLineBasicMaterial = !0;
                const vo = new Et,
                    yo = new Et,
                    xo = new re,
                    _o = new ne,
                    bo = new Xt;
                class wo extends Le {
                    constructor(t = new un, e = new go) {
                        super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t) {
                        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [0];
                                for (let t = 1, r = e.count; t < r; t++) vo.fromBufferAttribute(e, t - 1), yo.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += vo.distanceTo(yo);
                                t.setAttribute("lineDistance", new en(n, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            r = this.matrixWorld,
                            i = t.params.Line.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), bo.copy(n.boundingSphere), bo.applyMatrix4(r), bo.radius += i, !1 === t.ray.intersectsSphere(bo)) return;
                        xo.copy(r).invert(), _o.copy(t.ray).applyMatrix4(xo);
                        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o,
                            c = new Et,
                            l = new Et,
                            u = new Et,
                            h = new Et,
                            d = this.isLineSegments ? 2 : 1;
                        if (n.isBufferGeometry) {
                            const r = n.index,
                                i = n.attributes.position;
                            if (null !== r) {
                                const n = Math.max(0, s.start),
                                    o = Math.min(r.count, s.start + s.count);
                                for (let s = n, p = o - 1; s < p; s += d) {
                                    const n = r.getX(s),
                                        o = r.getX(s + 1);
                                    c.fromBufferAttribute(i, n), l.fromBufferAttribute(i, o);
                                    if (_o.distanceSqToSegment(c, l, h, u) > a) continue;
                                    h.applyMatrix4(this.matrixWorld);
                                    const d = t.ray.origin.distanceTo(h);
                                    d < t.near || d > t.far || e.push({
                                        distance: d,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: s,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else {
                                for (let n = Math.max(0, r.start), r = Math.min(i.count, r.start + r.count) - 1; n < r; n += d) {
                                    c.fromBufferAttribute(i, n), l.fromBufferAttribute(i, n + 1);
                                    if (_o.distanceSqToSegment(c, l, h, u) > a) continue;
                                    h.applyMatrix4(this.matrixWorld);
                                    const r = t.ray.origin.distanceTo(h);
                                    r < t.near || r > t.far || e.push({
                                        distance: r,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }
                wo.prototype.isLine = !0;
                const Mo = new Et,
                    So = new Et;
                class To extends wo {
                    constructor(t, e) {
                        super(t, e), this.type = "LineSegments"
                    }
                    computeLineDistances() {
                        const t = this.geometry;
                        if (t.isBufferGeometry)
                            if (null === t.index) {
                                const e = t.attributes.position,
                                    n = [];
                                for (let t = 0, r = e.count; t < r; t += 2) Mo.fromBufferAttribute(e, t), So.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Mo.distanceTo(So);
                                t.setAttribute("lineDistance", new en(n, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                        return this
                    }
                }
                To.prototype.isLineSegments = !0;
                class Eo extends wo {
                    constructor(t, e) {
                        super(t, e), this.type = "LineLoop"
                    }
                }
                Eo.prototype.isLineLoop = !0;
                class Ao extends He {
                    constructor(t) {
                        super(), this.type = "PointsMaterial", this.color = new Xe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
                    }
                }
                Ao.prototype.isPointsMaterial = !0;
                const Lo = new re,
                    Ro = new ne,
                    Po = new Xt,
                    Co = new Et;
                class Io extends Le {
                    constructor(t = new un, e = new Ao) {
                        super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                    }
                    copy(t) {
                        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
                    }
                    raycast(t, e) {
                        const n = this.geometry,
                            r = this.matrixWorld,
                            i = t.params.Points.threshold,
                            s = n.drawRange;
                        if (null === n.boundingSphere && n.computeBoundingSphere(), Po.copy(n.boundingSphere), Po.applyMatrix4(r), Po.radius += i, !1 === t.ray.intersectsSphere(Po)) return;
                        Lo.copy(r).invert(), Ro.copy(t.ray).applyMatrix4(Lo);
                        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            a = o * o;
                        if (n.isBufferGeometry) {
                            const i = n.index,
                                o = n.attributes.position;
                            if (null !== i) {
                                const n = Math.max(0, s.start),
                                    c = Math.min(i.count, s.start + s.count);
                                for (let s = n, l = c; s < l; s++) {
                                    const n = i.getX(s);
                                    Co.fromBufferAttribute(o, n), Do(Co, n, a, r, t, e, this)
                                }
                            } else {
                                const n = Math.max(0, s.start),
                                    i = Math.min(o.count, s.start + s.count);
                                for (let s = n, c = i; s < c; s++) Co.fromBufferAttribute(o, s), Do(Co, s, a, r, t, e, this)
                            }
                        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                    updateMorphTargets() {
                        const t = this.geometry;
                        if (t.isBufferGeometry) {
                            const e = t.morphAttributes,
                                n = Object.keys(e);
                            if (n.length > 0) {
                                const t = e[n[0]];
                                if (void 0 !== t) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (let e = 0, n = t.length; e < n; e++) {
                                        const n = t[e].name || String(e);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                    }
                                }
                            }
                        } else {
                            const e = t.morphTargets;
                            void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                        }
                    }
                }

                function Do(t, e, n, r, i, s, o) {
                    const a = Ro.distanceSqToPoint(t);
                    if (a < n) {
                        const n = new Et;
                        Ro.closestPointToPoint(t, n), n.applyMatrix4(r);
                        const c = i.ray.origin.distanceTo(n);
                        if (c < i.near || c > i.far) return;
                        s.push({
                            distance: c,
                            distanceToRay: Math.sqrt(a),
                            point: n,
                            index: e,
                            face: null,
                            object: o
                        })
                    }
                }
                Io.prototype.isPoints = !0;
                (class extends _t {
                    constructor(t, e, n, r, i, s, o, a, c) {
                        super(t, e, n, r, i, s, o, a, c), this.format = void 0 !== o ? o : B, this.minFilter = void 0 !== s ? s : R, this.magFilter = void 0 !== i ? i : R, this.generateMipmaps = !1;
                        const l = this;
                        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                            l.needsUpdate = !0, t.requestVideoFrameCallback(e)
                        }))
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const t = this.image;
                        !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                    }
                }).prototype.isVideoTexture = !0;
                (class extends _t {
                    constructor(t, e, n, r, i, s, o, a, c, l, u, h) {
                        super(null, s, o, a, c, l, r, i, u, h), this.image = {
                            width: e,
                            height: n
                        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                    }
                }).prototype.isCompressedTexture = !0;
                (class extends _t {
                    constructor(t, e, n, r, i, s, o, a, c) {
                        super(t, e, n, r, i, s, o, a, c), this.needsUpdate = !0
                    }
                }).prototype.isCanvasTexture = !0;
                (class extends _t {
                    constructor(t, e, n, r, i, s, o, a, c, l) {
                        if ((l = void 0 !== l ? l : F) !== F && l !== k) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === n && l === F && (n = 1012), void 0 === n && l === k && (n = N), super(null, r, i, s, o, a, l, n, c), this.image = {
                            width: t,
                            height: e
                        }, this.magFilter = void 0 !== o ? o : E, this.minFilter = void 0 !== a ? a : E, this.flipY = !1, this.generateMipmaps = !1
                    }
                }).prototype.isDepthTexture = !0, new Et, new Et, new Et, new ke;
                class Oo {
                    constructor() {
                        this.type = "Curve", this.arcLengthDivisions = 200
                    }
                    getPoint() {
                        return console.warn("THREE.Curve: .getPoint() not implemented."), null
                    }
                    getPointAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getPoint(n, e)
                    }
                    getPoints(t = 5) {
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                        return e
                    }
                    getSpacedPoints(t = 5) {
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                        return e
                    }
                    getLength() {
                        const t = this.getLengths();
                        return t[t.length - 1]
                    }
                    getLengths(t = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        const e = [];
                        let n, r = this.getPoint(0),
                            i = 0;
                        e.push(0);
                        for (let s = 1; s <= t; s++) n = this.getPoint(s / t), i += n.distanceTo(r), e.push(i), r = n;
                        return this.cacheArcLengths = e, e
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.getLengths()
                    }
                    getUtoTmapping(t, e) {
                        const n = this.getLengths();
                        let r = 0;
                        const i = n.length;
                        let s;
                        s = e || t * n[i - 1];
                        let o, a = 0,
                            c = i - 1;
                        for (; a <= c;)
                            if (r = Math.floor(a + (c - a) / 2), o = n[r] - s, o < 0) a = r + 1;
                            else {
                                if (!(o > 0)) {
                                    c = r;
                                    break
                                }
                                c = r - 1
                            }
                        if (r = c, n[r] === s) return r / (i - 1);
                        const l = n[r];
                        return (r + (s - l) / (n[r + 1] - l)) / (i - 1)
                    }
                    getTangent(t, e) {
                        const n = 1e-4;
                        let r = t - n,
                            i = t + n;
                        r < 0 && (r = 0), i > 1 && (i = 1);
                        const s = this.getPoint(r),
                            o = this.getPoint(i),
                            a = e || (s.isVector2 ? new pt : new Et);
                        return a.copy(o).sub(s).normalize(), a
                    }
                    getTangentAt(t, e) {
                        const n = this.getUtoTmapping(t);
                        return this.getTangent(n, e)
                    }
                    computeFrenetFrames(t, e) {
                        const n = new Et,
                            r = [],
                            i = [],
                            s = [],
                            o = new Et,
                            a = new re;
                        for (let e = 0; e <= t; e++) {
                            const n = e / t;
                            r[e] = this.getTangentAt(n, new Et)
                        }
                        i[0] = new Et, s[0] = new Et;
                        let c = Number.MAX_VALUE;
                        const l = Math.abs(r[0].x),
                            u = Math.abs(r[0].y),
                            h = Math.abs(r[0].z);
                        l <= c && (c = l, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), s[0].crossVectors(r[0], i[0]);
                        for (let e = 1; e <= t; e++) {
                            if (i[e] = i[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(r[e - 1], r[e]), o.length() > Number.EPSILON) {
                                o.normalize();
                                const t = Math.acos(ot(r[e - 1].dot(r[e]), -1, 1));
                                i[e].applyMatrix4(a.makeRotationAxis(o, t))
                            }
                            s[e].crossVectors(r[e], i[e])
                        }
                        if (!0 === e) {
                            let e = Math.acos(ot(i[0].dot(i[t]), -1, 1));
                            e /= t, r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e);
                            for (let n = 1; n <= t; n++) i[n].applyMatrix4(a.makeRotationAxis(r[n], e * n)), s[n].crossVectors(r[n], i[n])
                        }
                        return {
                            tangents: r,
                            normals: i,
                            binormals: s
                        }
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions, this
                    }
                    toJSON() {
                        const t = {
                            metadata: {
                                version: 4.5,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                    }
                    fromJSON(t) {
                        return this.arcLengthDivisions = t.arcLengthDivisions, this
                    }
                }
                class No extends Oo {
                    constructor(t = 0, e = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, o = !1, a = 0) {
                        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a
                    }
                    getPoint(t, e) {
                        const n = e || new pt,
                            r = 2 * Math.PI;
                        let i = this.aEndAngle - this.aStartAngle;
                        const s = Math.abs(i) < Number.EPSILON;
                        for (; i < 0;) i += r;
                        for (; i > r;) i -= r;
                        i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r);
                        const o = this.aStartAngle + t * i;
                        let a = this.aX + this.xRadius * Math.cos(o),
                            c = this.aY + this.yRadius * Math.sin(o);
                        if (0 !== this.aRotation) {
                            const t = Math.cos(this.aRotation),
                                e = Math.sin(this.aRotation),
                                n = a - this.aX,
                                r = c - this.aY;
                            a = n * t - r * e + this.aX, c = n * e + r * t + this.aY
                        }
                        return n.set(a, c)
                    }
                    copy(t) {
                        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                    }
                }
                No.prototype.isEllipseCurve = !0;
                class Bo extends No {
                    constructor(t, e, n, r, i, s) {
                        super(t, e, n, n, r, i, s), this.type = "ArcCurve"
                    }
                }

                function zo() {
                    let t = 0,
                        e = 0,
                        n = 0,
                        r = 0;

                    function i(i, s, o, a) {
                        t = i, e = o, n = -3 * i + 3 * s - 2 * o - a, r = 2 * i - 2 * s + o + a
                    }
                    return {
                        initCatmullRom: function(t, e, n, r, s) {
                            i(e, n, s * (n - t), s * (r - e))
                        },
                        initNonuniformCatmullRom: function(t, e, n, r, s, o, a) {
                            let c = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                                l = (n - e) / o - (r - e) / (o + a) + (r - n) / a;
                            c *= o, l *= o, i(e, n, c, l)
                        },
                        calc: function(i) {
                            const s = i * i;
                            return t + e * i + n * s + r * (s * i)
                        }
                    }
                }
                Bo.prototype.isArcCurve = !0;
                const Fo = new Et,
                    ko = new zo,
                    Uo = new zo,
                    Ho = new zo;
                class Go extends Oo {
                    constructor(t = [], e = !1, n = "centripetal", r = .5) {
                        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
                    }
                    getPoint(t, e = new Et) {
                        const n = e,
                            r = this.points,
                            i = r.length,
                            s = (i - (this.closed ? 0 : 1)) * t;
                        let o, a, c = Math.floor(s),
                            l = s - c;
                        this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / i) + 1) * i : 0 === l && c === i - 1 && (c = i - 2, l = 1), this.closed || c > 0 ? o = r[(c - 1) % i] : (Fo.subVectors(r[0], r[1]).add(r[0]), o = Fo);
                        const u = r[c % i],
                            h = r[(c + 1) % i];
                        if (this.closed || c + 2 < i ? a = r[(c + 2) % i] : (Fo.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = Fo), "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const t = "chordal" === this.curveType ? .5 : .25;
                            let e = Math.pow(o.distanceToSquared(u), t),
                                n = Math.pow(u.distanceToSquared(h), t),
                                r = Math.pow(h.distanceToSquared(a), t);
                            n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), ko.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, e, n, r), Uo.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, e, n, r), Ho.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, e, n, r)
                        } else "catmullrom" === this.curveType && (ko.initCatmullRom(o.x, u.x, h.x, a.x, this.tension), Uo.initCatmullRom(o.y, u.y, h.y, a.y, this.tension), Ho.initCatmullRom(o.z, u.z, h.z, a.z, this.tension));
                        return n.set(ko.calc(l), Uo.calc(l), Ho.calc(l)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new Et).fromArray(n))
                        }
                        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                    }
                }

                function Vo(t, e, n, r, i) {
                    const s = .5 * (r - e),
                        o = .5 * (i - n),
                        a = t * t;
                    return (2 * n - 2 * r + s + o) * (t * a) + (-3 * n + 3 * r - 2 * s - o) * a + s * t + n
                }

                function Wo(t, e, n, r) {
                    return function(t, e) {
                        const n = 1 - t;
                        return n * n * e
                    }(t, e) + function(t, e) {
                        return 2 * (1 - t) * t * e
                    }(t, n) + function(t, e) {
                        return t * t * e
                    }(t, r)
                }

                function jo(t, e, n, r, i) {
                    return function(t, e) {
                        const n = 1 - t;
                        return n * n * n * e
                    }(t, e) + function(t, e) {
                        const n = 1 - t;
                        return 3 * n * n * t * e
                    }(t, n) + function(t, e) {
                        return 3 * (1 - t) * t * t * e
                    }(t, r) + function(t, e) {
                        return t * t * t * e
                    }(t, i)
                }
                Go.prototype.isCatmullRomCurve3 = !0;
                class Zo extends Oo {
                    constructor(t = new pt, e = new pt, n = new pt, r = new pt) {
                        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
                    }
                    getPoint(t, e = new pt) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(jo(t, r.x, i.x, s.x, o.x), jo(t, r.y, i.y, s.y, o.y)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                    }
                }
                Zo.prototype.isCubicBezierCurve = !0;
                class qo extends Oo {
                    constructor(t = new Et, e = new Et, n = new Et, r = new Et) {
                        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
                    }
                    getPoint(t, e = new Et) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            s = this.v2,
                            o = this.v3;
                        return n.set(jo(t, r.x, i.x, s.x, o.x), jo(t, r.y, i.y, s.y, o.y), jo(t, r.z, i.z, s.z, o.z)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                    }
                }
                qo.prototype.isCubicBezierCurve3 = !0;
                class Xo extends Oo {
                    constructor(t = new pt, e = new pt) {
                        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                    }
                    getPoint(t, e = new pt) {
                        const n = e;
                        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    getTangent(t, e) {
                        const n = e || new pt;
                        return n.copy(this.v2).sub(this.v1).normalize(), n
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                Xo.prototype.isLineCurve = !0;
                class Yo extends Oo {
                    constructor(t = new pt, e = new pt, n = new pt) {
                        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                    }
                    getPoint(t, e = new pt) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            s = this.v2;
                        return n.set(Wo(t, r.x, i.x, s.x), Wo(t, r.y, i.y, s.y)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                Yo.prototype.isQuadraticBezierCurve = !0;
                class Jo extends Oo {
                    constructor(t = new Et, e = new Et, n = new Et) {
                        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                    }
                    getPoint(t, e = new Et) {
                        const n = e,
                            r = this.v0,
                            i = this.v1,
                            s = this.v2;
                        return n.set(Wo(t, r.x, i.x, s.x), Wo(t, r.y, i.y, s.y), Wo(t, r.z, i.z, s.z)), n
                    }
                    copy(t) {
                        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                }
                Jo.prototype.isQuadraticBezierCurve3 = !0;
                class Ko extends Oo {
                    constructor(t = []) {
                        super(), this.type = "SplineCurve", this.points = t
                    }
                    getPoint(t, e = new pt) {
                        const n = e,
                            r = this.points,
                            i = (r.length - 1) * t,
                            s = Math.floor(i),
                            o = i - s,
                            a = r[0 === s ? s : s - 1],
                            c = r[s],
                            l = r[s > r.length - 2 ? r.length - 1 : s + 1],
                            u = r[s > r.length - 3 ? r.length - 1 : s + 2];
                        return n.set(Vo(o, a.x, c.x, l.x, u.x), Vo(o, a.y, c.y, l.y, u.y)), n
                    }
                    copy(t) {
                        super.copy(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.points = [];
                        for (let e = 0, n = this.points.length; e < n; e++) {
                            const n = this.points[e];
                            t.points.push(n.toArray())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.points = [];
                        for (let e = 0, n = t.points.length; e < n; e++) {
                            const n = t.points[e];
                            this.points.push((new pt).fromArray(n))
                        }
                        return this
                    }
                }
                Ko.prototype.isSplineCurve = !0;
                var Qo = Object.freeze({
                    __proto__: null,
                    ArcCurve: Bo,
                    CatmullRomCurve3: Go,
                    CubicBezierCurve: Zo,
                    CubicBezierCurve3: qo,
                    EllipseCurve: No,
                    LineCurve: Xo,
                    LineCurve3: class extends Oo {
                        constructor(t = new Et, e = new Et) {
                            super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                        }
                        getPoint(t, e = new Et) {
                            const n = e;
                            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                        }
                        getPointAt(t, e) {
                            return this.getPoint(t, e)
                        }
                        copy(t) {
                            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                        }
                        toJSON() {
                            const t = super.toJSON();
                            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                        }
                        fromJSON(t) {
                            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                        }
                    },
                    QuadraticBezierCurve: Yo,
                    QuadraticBezierCurve3: Jo,
                    SplineCurve: Ko
                });
                class $o extends Oo {
                    constructor() {
                        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                    }
                    add(t) {
                        this.curves.push(t)
                    }
                    closePath() {
                        const t = this.curves[0].getPoint(0),
                            e = this.curves[this.curves.length - 1].getPoint(1);
                        t.equals(e) || this.curves.push(new Xo(e, t))
                    }
                    getPoint(t, e) {
                        const n = t * this.getLength(),
                            r = this.getCurveLengths();
                        let i = 0;
                        for (; i < r.length;) {
                            if (r[i] >= n) {
                                const t = r[i] - n,
                                    s = this.curves[i],
                                    o = s.getLength(),
                                    a = 0 === o ? 0 : 1 - t / o;
                                return s.getPointAt(a, e)
                            }
                            i++
                        }
                        return null
                    }
                    getLength() {
                        const t = this.getCurveLengths();
                        return t[t.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                        const t = [];
                        let e = 0;
                        for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
                        return this.cacheLengths = t, t
                    }
                    getSpacedPoints(t = 40) {
                        const e = [];
                        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                        return this.autoClose && e.push(e[0]), e
                    }
                    getPoints(t = 12) {
                        const e = [];
                        let n;
                        for (let r = 0, i = this.curves; r < i.length; r++) {
                            const s = i[r],
                                o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                                a = s.getPoints(o);
                            for (let t = 0; t < a.length; t++) {
                                const r = a[t];
                                n && n.equals(r) || (e.push(r), n = r)
                            }
                        }
                        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                    }
                    copy(t) {
                        super.copy(t), this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push(n.clone())
                        }
                        return this.autoClose = t.autoClose, this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.autoClose = this.autoClose, t.curves = [];
                        for (let e = 0, n = this.curves.length; e < n; e++) {
                            const n = this.curves[e];
                            t.curves.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                        for (let e = 0, n = t.curves.length; e < n; e++) {
                            const n = t.curves[e];
                            this.curves.push((new Qo[n.type]).fromJSON(n))
                        }
                        return this
                    }
                }
                class ta extends $o {
                    constructor(t) {
                        super(), this.type = "Path", this.currentPoint = new pt, t && this.setFromPoints(t)
                    }
                    setFromPoints(t) {
                        this.moveTo(t[0].x, t[0].y);
                        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                        return this
                    }
                    moveTo(t, e) {
                        return this.currentPoint.set(t, e), this
                    }
                    lineTo(t, e) {
                        const n = new Xo(this.currentPoint.clone(), new pt(t, e));
                        return this.curves.push(n), this.currentPoint.set(t, e), this
                    }
                    quadraticCurveTo(t, e, n, r) {
                        const i = new Yo(this.currentPoint.clone(), new pt(t, e), new pt(n, r));
                        return this.curves.push(i), this.currentPoint.set(n, r), this
                    }
                    bezierCurveTo(t, e, n, r, i, s) {
                        const o = new Zo(this.currentPoint.clone(), new pt(t, e), new pt(n, r), new pt(i, s));
                        return this.curves.push(o), this.currentPoint.set(i, s), this
                    }
                    splineThru(t) {
                        const e = [this.currentPoint.clone()].concat(t),
                            n = new Ko(e);
                        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                    }
                    arc(t, e, n, r, i, s) {
                        const o = this.currentPoint.x,
                            a = this.currentPoint.y;
                        return this.absarc(t + o, e + a, n, r, i, s), this
                    }
                    absarc(t, e, n, r, i, s) {
                        return this.absellipse(t, e, n, n, r, i, s), this
                    }
                    ellipse(t, e, n, r, i, s, o, a) {
                        const c = this.currentPoint.x,
                            l = this.currentPoint.y;
                        return this.absellipse(t + c, e + l, n, r, i, s, o, a), this
                    }
                    absellipse(t, e, n, r, i, s, o, a) {
                        const c = new No(t, e, n, r, i, s, o, a);
                        if (this.curves.length > 0) {
                            const t = c.getPoint(0);
                            t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                        }
                        this.curves.push(c);
                        const l = c.getPoint(1);
                        return this.currentPoint.copy(l), this
                    }
                    copy(t) {
                        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.currentPoint = this.currentPoint.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                    }
                }
                class ea extends ta {
                    constructor(t) {
                        super(t), this.uuid = st(), this.type = "Shape", this.holes = []
                    }
                    getPointsHoles(t) {
                        const e = [];
                        for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
                        return e
                    }
                    extractPoints(t) {
                        return {
                            shape: this.getPoints(t),
                            holes: this.getPointsHoles(t)
                        }
                    }
                    copy(t) {
                        super.copy(t), this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push(n.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        t.uuid = this.uuid, t.holes = [];
                        for (let e = 0, n = this.holes.length; e < n; e++) {
                            const n = this.holes[e];
                            t.holes.push(n.toJSON())
                        }
                        return t
                    }
                    fromJSON(t) {
                        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                        for (let e = 0, n = t.holes.length; e < n; e++) {
                            const n = t.holes[e];
                            this.holes.push((new ta).fromJSON(n))
                        }
                        return this
                    }
                }
                const na = function(t, e, n = 2) {
                    const r = e && e.length,
                        i = r ? e[0] * n : t.length;
                    let s = ra(t, 0, i, n, !0);
                    const o = [];
                    if (!s || s.next === s.prev) return o;
                    let a, c, l, u, h, d, p;
                    if (r && (s = function(t, e, n, r) {
                            const i = [];
                            let s, o, a, c, l;
                            for (s = 0, o = e.length; s < o; s++) a = e[s] * r, c = s < o - 1 ? e[s + 1] * r : t.length, l = ra(t, a, c, r, !1), l === l.next && (l.steiner = !0), i.push(fa(l));
                            for (i.sort(ua), s = 0; s < i.length; s++) ha(i[s], n), n = ia(n, n.next);
                            return n
                        }(t, e, s, n)), t.length > 80 * n) {
                        a = l = t[0], c = u = t[1];
                        for (let e = n; e < i; e += n) h = t[e], d = t[e + 1], h < a && (a = h), d < c && (c = d), h > l && (l = h), d > u && (u = d);
                        p = Math.max(l - a, u - c), p = 0 !== p ? 1 / p : 0
                    }
                    return sa(s, o, n, a, c, p), o
                };

                function ra(t, e, n, r, i) {
                    let s, o;
                    if (i === function(t, e, n, r) {
                            let i = 0;
                            for (let s = e, o = n - r; s < n; s += r) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
                            return i
                        }(t, e, n, r) > 0)
                        for (s = e; s < n; s += r) o = Sa(s, t[s], t[s + 1], o);
                    else
                        for (s = n - r; s >= e; s -= r) o = Sa(s, t[s], t[s + 1], o);
                    return o && ya(o, o.next) && (Ta(o), o = o.next), o
                }

                function ia(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    let n, r = t;
                    do {
                        if (n = !1, r.steiner || !ya(r, r.next) && 0 !== va(r.prev, r, r.next)) r = r.next;
                        else {
                            if (Ta(r), r = e = r.prev, r === r.next) break;
                            n = !0
                        }
                    } while (n || r !== e);
                    return e
                }

                function sa(t, e, n, r, i, s, o) {
                    if (!t) return;
                    !o && s && function(t, e, n, r) {
                        let i = t;
                        do {
                            null === i.z && (i.z = pa(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                        } while (i !== t);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function(t) {
                                let e, n, r, i, s, o, a, c, l = 1;
                                do {
                                    for (n = t, t = null, s = null, o = 0; n;) {
                                        for (o++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ, r); e++);
                                        for (c = l; a > 0 || c > 0 && r;) 0 !== a && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, c--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
                                        n = r
                                    }
                                    s.nextZ = null, l *= 2
                                } while (o > 1)
                            }(i)
                    }(t, r, i, s);
                    let a, c, l = t;
                    for (; t.prev !== t.next;)
                        if (a = t.prev, c = t.next, s ? aa(t, r, i, s) : oa(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), Ta(t), t = c.next, l = c.next;
                        else if ((t = c) === l) {
                        o ? 1 === o ? sa(t = ca(ia(t), e, n), e, n, r, i, s, 2) : 2 === o && la(t, e, n, r, i, s) : sa(ia(t), e, n, r, i, s, 1);
                        break
                    }
                }

                function oa(t) {
                    const e = t.prev,
                        n = t,
                        r = t.next;
                    if (va(e, n, r) >= 0) return !1;
                    let i = t.next.next;
                    for (; i !== t.prev;) {
                        if (ma(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && va(i.prev, i, i.next) >= 0) return !1;
                        i = i.next
                    }
                    return !0
                }

                function aa(t, e, n, r) {
                    const i = t.prev,
                        s = t,
                        o = t.next;
                    if (va(i, s, o) >= 0) return !1;
                    const a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
                        c = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
                        l = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
                        u = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
                        h = pa(a, c, e, n, r),
                        d = pa(l, u, e, n, r);
                    let p = t.prevZ,
                        f = t.nextZ;
                    for (; p && p.z >= h && f && f.z <= d;) {
                        if (p !== t.prev && p !== t.next && ma(i.x, i.y, s.x, s.y, o.x, o.y, p.x, p.y) && va(p.prev, p, p.next) >= 0) return !1;
                        if (p = p.prevZ, f !== t.prev && f !== t.next && ma(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && va(f.prev, f, f.next) >= 0) return !1;
                        f = f.nextZ
                    }
                    for (; p && p.z >= h;) {
                        if (p !== t.prev && p !== t.next && ma(i.x, i.y, s.x, s.y, o.x, o.y, p.x, p.y) && va(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    for (; f && f.z <= d;) {
                        if (f !== t.prev && f !== t.next && ma(i.x, i.y, s.x, s.y, o.x, o.y, f.x, f.y) && va(f.prev, f, f.next) >= 0) return !1;
                        f = f.nextZ
                    }
                    return !0
                }

                function ca(t, e, n) {
                    let r = t;
                    do {
                        const i = r.prev,
                            s = r.next.next;
                        !ya(i, s) && xa(i, r, r.next, s) && wa(i, s) && wa(s, i) && (e.push(i.i / n), e.push(r.i / n), e.push(s.i / n), Ta(r), Ta(r.next), r = t = s), r = r.next
                    } while (r !== t);
                    return ia(r)
                }

                function la(t, e, n, r, i, s) {
                    let o = t;
                    do {
                        let t = o.next.next;
                        for (; t !== o.prev;) {
                            if (o.i !== t.i && ga(o, t)) {
                                let a = Ma(o, t);
                                return o = ia(o, o.next), a = ia(a, a.next), sa(o, e, n, r, i, s), void sa(a, e, n, r, i, s)
                            }
                            t = t.next
                        }
                        o = o.next
                    } while (o !== t)
                }

                function ua(t, e) {
                    return t.x - e.x
                }

                function ha(t, e) {
                    if (e = function(t, e) {
                            let n = e;
                            const r = t.x,
                                i = t.y;
                            let s, o = -1 / 0;
                            do {
                                if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
                                    const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                    if (t <= r && t > o) {
                                        if (o = t, t === r) {
                                            if (i === n.y) return n;
                                            if (i === n.next.y) return n.next
                                        }
                                        s = n.x < n.next.x ? n : n.next
                                    }
                                }
                                n = n.next
                            } while (n !== e);
                            if (!s) return null;
                            if (r === o) return s;
                            const a = s,
                                c = s.x,
                                l = s.y;
                            let u, h = 1 / 0;
                            n = s;
                            do {
                                r >= n.x && n.x >= c && r !== n.x && ma(i < l ? r : o, i, c, l, i < l ? o : r, i, n.x, n.y) && (u = Math.abs(i - n.y) / (r - n.x), wa(n, t) && (u < h || u === h && (n.x > s.x || n.x === s.x && da(s, n))) && (s = n, h = u)), n = n.next
                            }
                            while (n !== a);
                            return s
                        }(t, e)) {
                        const n = Ma(e, t);
                        ia(e, e.next), ia(n, n.next)
                    }
                }

                function da(t, e) {
                    return va(t.prev, t, e.prev) < 0 && va(e.next, t, t.next) < 0
                }

                function pa(t, e, n, r, i) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }

                function fa(t) {
                    let e = t,
                        n = t;
                    do {
                        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                    } while (e !== t);
                    return n
                }

                function ma(t, e, n, r, i, s, o, a) {
                    return (i - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (r - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (i - o) * (r - a) >= 0
                }

                function ga(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                        let n = t;
                        do {
                            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && xa(n, n.next, t, e)) return !0;
                            n = n.next
                        } while (n !== t);
                        return !1
                    }(t, e) && (wa(t, e) && wa(e, t) && function(t, e) {
                        let n = t,
                            r = !1;
                        const i = (t.x + e.x) / 2,
                            s = (t.y + e.y) / 2;
                        do {
                            n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                        } while (n !== t);
                        return r
                    }(t, e) && (va(t.prev, t, e.prev) || va(t, e.prev, e)) || ya(t, e) && va(t.prev, t, t.next) > 0 && va(e.prev, e, e.next) > 0)
                }

                function va(t, e, n) {
                    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
                }

                function ya(t, e) {
                    return t.x === e.x && t.y === e.y
                }

                function xa(t, e, n, r) {
                    const i = ba(va(t, e, n)),
                        s = ba(va(t, e, r)),
                        o = ba(va(n, r, t)),
                        a = ba(va(n, r, e));
                    return i !== s && o !== a || !(0 !== i || !_a(t, n, e)) || !(0 !== s || !_a(t, r, e)) || !(0 !== o || !_a(n, t, r)) || !(0 !== a || !_a(n, e, r))
                }

                function _a(t, e, n) {
                    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
                }

                function ba(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }

                function wa(t, e) {
                    return va(t.prev, t, t.next) < 0 ? va(t, e, t.next) >= 0 && va(t, t.prev, e) >= 0 : va(t, e, t.prev) < 0 || va(t, t.next, e) < 0
                }

                function Ma(t, e) {
                    const n = new Ea(t.i, t.x, t.y),
                        r = new Ea(e.i, e.x, e.y),
                        i = t.next,
                        s = e.prev;
                    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
                }

                function Sa(t, e, n, r) {
                    const i = new Ea(t, e, n);
                    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
                }

                function Ta(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }

                function Ea(t, e, n) {
                    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }
                class Aa {
                    static area(t) {
                        const e = t.length;
                        let n = 0;
                        for (let r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
                        return .5 * n
                    }
                    static isClockWise(t) {
                        return Aa.area(t) < 0
                    }
                    static triangulateShape(t, e) {
                        const n = [],
                            r = [],
                            i = [];
                        La(t), Ra(n, t);
                        let s = t.length;
                        e.forEach(La);
                        for (let t = 0; t < e.length; t++) r.push(s), s += e[t].length, Ra(n, e[t]);
                        const o = na(n, r);
                        for (let t = 0; t < o.length; t += 3) i.push(o.slice(t, t + 3));
                        return i
                    }
                }

                function La(t) {
                    const e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function Ra(t, e) {
                    for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
                }
                class Pa extends un {
                    constructor(t = new ea([new pt(.5, .5), new pt(-.5, .5), new pt(-.5, -.5), new pt(.5, -.5)]), e = {}) {
                        super(), this.type = "ExtrudeGeometry", this.parameters = {
                            shapes: t,
                            options: e
                        }, t = Array.isArray(t) ? t : [t];
                        const n = this,
                            r = [],
                            i = [];
                        for (let e = 0, n = t.length; e < n; e++) {
                            s(t[e])
                        }

                        function s(t) {
                            const s = [],
                                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                                a = void 0 !== e.steps ? e.steps : 1;
                            let c = void 0 !== e.depth ? e.depth : 1,
                                l = void 0 === e.bevelEnabled || e.bevelEnabled,
                                u = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
                                h = void 0 !== e.bevelSize ? e.bevelSize : u - .1,
                                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                            const f = e.extrudePath,
                                m = void 0 !== e.UVGenerator ? e.UVGenerator : Ca;
                            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                            let g, v, y, x, _, b = !1;
                            f && (g = f.getSpacedPoints(a), b = !0, l = !1, v = f.computeFrenetFrames(a, !1), y = new Et, x = new Et, _ = new Et), l || (p = 0, u = 0, h = 0, d = 0);
                            const w = t.extractPoints(o);
                            let M = w.shape;
                            const S = w.holes;
                            if (!Aa.isClockWise(M)) {
                                M = M.reverse();
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    Aa.isClockWise(e) && (S[t] = e.reverse())
                                }
                            }
                            const T = Aa.triangulateShape(M, S),
                                E = M;
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                M = M.concat(e)
                            }

                            function A(t, e, n) {
                                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                            }
                            const L = M.length,
                                R = T.length;

                            function P(t, e, n) {
                                let r, i, s;
                                const o = t.x - e.x,
                                    a = t.y - e.y,
                                    c = n.x - t.x,
                                    l = n.y - t.y,
                                    u = o * o + a * a,
                                    h = o * l - a * c;
                                if (Math.abs(h) > Number.EPSILON) {
                                    const h = Math.sqrt(u),
                                        d = Math.sqrt(c * c + l * l),
                                        p = e.x - a / h,
                                        f = e.y + o / h,
                                        m = ((n.x - l / d - p) * l - (n.y + c / d - f) * c) / (o * l - a * c);
                                    r = p + o * m - t.x, i = f + a * m - t.y;
                                    const g = r * r + i * i;
                                    if (g <= 2) return new pt(r, i);
                                    s = Math.sqrt(g / 2)
                                } else {
                                    let t = !1;
                                    o > Number.EPSILON ? c > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0), t ? (r = -a, i = o, s = Math.sqrt(u)) : (r = o, i = a, s = Math.sqrt(u / 2))
                                }
                                return new pt(r / s, i / s)
                            }
                            const C = [];
                            for (let t = 0, e = E.length, n = e - 1, r = t + 1; t < e; t++, n++, r++) n === e && (n = 0), r === e && (r = 0), C[t] = P(E[t], E[n], E[r]);
                            const I = [];
                            let D, O = C.concat();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                D = [];
                                for (let t = 0, n = e.length, r = n - 1, i = t + 1; t < n; t++, r++, i++) r === n && (r = 0), i === n && (i = 0), D[t] = P(e[t], e[r], e[i]);
                                I.push(D), O = O.concat(D)
                            }
                            for (let t = 0; t < p; t++) {
                                const e = t / p,
                                    n = u * Math.cos(e * Math.PI / 2),
                                    r = h * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], C[t], r);
                                    z(e.x, e.y, -n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = A(e[t], D[t], r);
                                        z(i.x, i.y, -n)
                                    }
                                }
                            }
                            const N = h + d;
                            for (let t = 0; t < L; t++) {
                                const e = l ? A(M[t], O[t], N) : M[t];
                                b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), z(_.x, _.y, _.z)) : z(e.x, e.y, 0)
                            }
                            for (let t = 1; t <= a; t++)
                                for (let e = 0; e < L; e++) {
                                    const n = l ? A(M[e], O[e], N) : M[e];
                                    b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), z(_.x, _.y, _.z)) : z(n.x, n.y, c / a * t)
                                }
                            for (let t = p - 1; t >= 0; t--) {
                                const e = t / p,
                                    n = u * Math.cos(e * Math.PI / 2),
                                    r = h * Math.sin(e * Math.PI / 2) + d;
                                for (let t = 0, e = E.length; t < e; t++) {
                                    const e = A(E[t], C[t], r);
                                    z(e.x, e.y, c + n)
                                }
                                for (let t = 0, e = S.length; t < e; t++) {
                                    const e = S[t];
                                    D = I[t];
                                    for (let t = 0, i = e.length; t < i; t++) {
                                        const i = A(e[t], D[t], r);
                                        b ? z(i.x, i.y + g[a - 1].y, g[a - 1].x + n) : z(i.x, i.y, c + n)
                                    }
                                }
                            }

                            function B(t, e) {
                                let n = t.length;
                                for (; --n >= 0;) {
                                    const r = n;
                                    let i = n - 1;
                                    i < 0 && (i = t.length - 1);
                                    for (let t = 0, n = a + 2 * p; t < n; t++) {
                                        const n = L * t,
                                            s = L * (t + 1);
                                        k(e + r + n, e + i + n, e + i + s, e + r + s)
                                    }
                                }
                            }

                            function z(t, e, n) {
                                s.push(t), s.push(e), s.push(n)
                            }

                            function F(t, e, i) {
                                U(t), U(e), U(i);
                                const s = r.length / 3,
                                    o = m.generateTopUV(n, r, s - 3, s - 2, s - 1);
                                H(o[0]), H(o[1]), H(o[2])
                            }

                            function k(t, e, i, s) {
                                U(t), U(e), U(s), U(e), U(i), U(s);
                                const o = r.length / 3,
                                    a = m.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
                                H(a[0]), H(a[1]), H(a[3]), H(a[1]), H(a[2]), H(a[3])
                            }

                            function U(t) {
                                r.push(s[3 * t + 0]), r.push(s[3 * t + 1]), r.push(s[3 * t + 2])
                            }

                            function H(t) {
                                    i.push(t.x), i.push(t.y)
                                }(function() {
                                    const t = r.length / 3;
                                    if (l) {
                                        let t = 0,
                                            e = L * t;
                                        for (let t = 0; t < R; t++) {
                                            const n = T[t];
                                            F(n[2] + e, n[1] + e, n[0] + e)
                                        }
                                        t = a + 2 * p, e = L * t;
                                        for (let t = 0; t < R; t++) {
                                            const n = T[t];
                                            F(n[0] + e, n[1] + e, n[2] + e)
                                        }
                                    } else {
                                        for (let t = 0; t < R; t++) {
                                            const e = T[t];
                                            F(e[2], e[1], e[0])
                                        }
                                        for (let t = 0; t < R; t++) {
                                            const e = T[t];
                                            F(e[0] + L * a, e[1] + L * a, e[2] + L * a)
                                        }
                                    }
                                    n.addGroup(t, r.length / 3 - t, 0)
                                })(),
                                function() {
                                    const t = r.length / 3;
                                    let e = 0;
                                    B(E, e), e += E.length;
                                    for (let t = 0, n = S.length; t < n; t++) {
                                        const n = S[t];
                                        B(n, e), e += n.length
                                    }
                                    n.addGroup(t, r.length / 3 - t, 1)
                                }()
                        }
                        this.setAttribute("position", new en(r, 3)), this.setAttribute("uv", new en(i, 2)), this.computeVertexNormals()
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e, n) {
                            if (n.shapes = [], Array.isArray(t))
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = t[e];
                                    n.shapes.push(r.uuid)
                                } else n.shapes.push(t.uuid);
                            return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
                        }(this.parameters.shapes, this.parameters.options, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let r = 0, i = t.shapes.length; r < i; r++) {
                            const i = e[t.shapes[r]];
                            n.push(i)
                        }
                        const r = t.options.extrudePath;
                        return void 0 !== r && (t.options.extrudePath = (new Qo[r.type]).fromJSON(r)), new Pa(n, t.options)
                    }
                }
                const Ca = {
                    generateTopUV: function(t, e, n, r, i) {
                        const s = e[3 * n],
                            o = e[3 * n + 1],
                            a = e[3 * r],
                            c = e[3 * r + 1],
                            l = e[3 * i],
                            u = e[3 * i + 1];
                        return [new pt(s, o), new pt(a, c), new pt(l, u)]
                    },
                    generateSideWallUV: function(t, e, n, r, i, s) {
                        const o = e[3 * n],
                            a = e[3 * n + 1],
                            c = e[3 * n + 2],
                            l = e[3 * r],
                            u = e[3 * r + 1],
                            h = e[3 * r + 2],
                            d = e[3 * i],
                            p = e[3 * i + 1],
                            f = e[3 * i + 2],
                            m = e[3 * s],
                            g = e[3 * s + 1],
                            v = e[3 * s + 2];
                        return Math.abs(a - u) < Math.abs(o - l) ? [new pt(o, 1 - c), new pt(l, 1 - h), new pt(d, 1 - f), new pt(m, 1 - v)] : [new pt(a, 1 - c), new pt(u, 1 - h), new pt(p, 1 - f), new pt(g, 1 - v)]
                    }
                };
                class Ia extends un {
                    constructor(t = new ea([new pt(0, .5), new pt(-.5, -.5), new pt(.5, -.5)]), e = 12) {
                        super(), this.type = "ShapeGeometry", this.parameters = {
                            shapes: t,
                            curveSegments: e
                        };
                        const n = [],
                            r = [],
                            i = [],
                            s = [];
                        let o = 0,
                            a = 0;
                        if (!1 === Array.isArray(t)) c(t);
                        else
                            for (let e = 0; e < t.length; e++) c(t[e]), this.addGroup(o, a, e), o += a, a = 0;

                        function c(t) {
                            const o = r.length / 3,
                                c = t.extractPoints(e);
                            let l = c.shape;
                            const u = c.holes;
                            !1 === Aa.isClockWise(l) && (l = l.reverse());
                            for (let t = 0, e = u.length; t < e; t++) {
                                const e = u[t];
                                !0 === Aa.isClockWise(e) && (u[t] = e.reverse())
                            }
                            const h = Aa.triangulateShape(l, u);
                            for (let t = 0, e = u.length; t < e; t++) {
                                const e = u[t];
                                l = l.concat(e)
                            }
                            for (let t = 0, e = l.length; t < e; t++) {
                                const e = l[t];
                                r.push(e.x, e.y, 0), i.push(0, 0, 1), s.push(e.x, e.y)
                            }
                            for (let t = 0, e = h.length; t < e; t++) {
                                const e = h[t],
                                    r = e[0] + o,
                                    i = e[1] + o,
                                    s = e[2] + o;
                                n.push(r, i, s), a += 3
                            }
                        }
                        this.setIndex(n), this.setAttribute("position", new en(r, 3)), this.setAttribute("normal", new en(i, 3)), this.setAttribute("uv", new en(s, 2))
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return function(t, e) {
                            if (e.shapes = [], Array.isArray(t))
                                for (let n = 0, r = t.length; n < r; n++) {
                                    const r = t[n];
                                    e.shapes.push(r.uuid)
                                } else e.shapes.push(t.uuid);
                            return e
                        }(this.parameters.shapes, t)
                    }
                    static fromJSON(t, e) {
                        const n = [];
                        for (let r = 0, i = t.shapes.length; r < i; r++) {
                            const i = e[t.shapes[r]];
                            n.push(i)
                        }
                        return new Ia(n, t.curveSegments)
                    }
                }(class extends He {
                    constructor(t) {
                        super(), this.type = "ShadowMaterial", this.color = new Xe(0), this.transparent = !0, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this
                    }
                }).prototype.isShadowMaterial = !0;
                class Da extends He {
                    constructor(t) {
                        super(), this.defines = {
                            STANDARD: ""
                        }, this.type = "MeshStandardMaterial", this.color = new Xe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = J, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            STANDARD: ""
                        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                    }
                }
                Da.prototype.isMeshStandardMaterial = !0;
                class Oa extends Da {
                    constructor(t) {
                        super(), this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new pt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {get: function() {
                                return ot(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function(t) {
                                this.ior = (1 + .4 * t) / (1 - .4 * t)
                            }
                        }), this.sheenTint = new Xe(0), this.sheenRoughness = 1, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new Xe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new Xe(1, 1, 1), this.specularTintMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(t) {
                        this._sheen > 0 != t > 0 && this.version++, this._sheen = t
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(t) {
                        this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(t) {
                        this._transmission > 0 != t > 0 && this.version++, this._transmission = t
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenTint.copy(t.sheenTint), this.sheenRoughness = t.sheenRoughness, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationTint.copy(t.attenuationTint), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularTint.copy(t.specularTint), this.specularTintMap = t.specularTintMap, this
                    }
                }
                Oa.prototype.isMeshPhysicalMaterial = !0;
                (class extends He {
                    constructor(t) {
                        super(), this.type = "MeshPhongMaterial", this.color = new Xe(16777215), this.specular = new Xe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = J, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this
                    }
                }).prototype.isMeshPhongMaterial = !0;
                (class extends He {
                    constructor(t) {
                        super(), this.defines = {
                            TOON: ""
                        }, this.type = "MeshToonMaterial", this.color = new Xe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = J, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                    }
                }).prototype.isMeshToonMaterial = !0;
                (class extends He {
                    constructor(t) {
                        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = J, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
                    }
                }).prototype.isMeshNormalMaterial = !0;
                (class extends He {
                    constructor(t) {
                        super(), this.type = "MeshLambertMaterial", this.color = new Xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this
                    }
                }).prototype.isMeshLambertMaterial = !0;
                (class extends He {
                    constructor(t) {
                        super(), this.defines = {
                            MATCAP: ""
                        }, this.type = "MeshMatcapMaterial", this.color = new Xe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = J, this.normalScale = new pt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.defines = {
                            MATCAP: ""
                        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this
                    }
                }).prototype.isMeshMatcapMaterial = !0;
                (class extends go {
                    constructor(t) {
                        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                    }
                }).prototype.isLineDashedMaterial = !0;
                const Na = {
                    arraySlice: function(t, e, n) {
                        return Na.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                    },
                    convertArray: function(t, e, n) {
                        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        const e = t.length,
                            n = new Array(e);
                        for (let t = 0; t !== e; ++t) n[t] = t;
                        return n.sort((function(e, n) {
                            return t[e] - t[n]
                        })), n
                    },
                    sortedArray: function(t, e, n) {
                        const r = t.length,
                            i = new t.constructor(r);
                        for (let s = 0, o = 0; o !== r; ++s) {
                            const r = n[s] * e;
                            for (let n = 0; n !== e; ++n) i[o++] = t[r + n]
                        }
                        return i
                    },
                    flattenJSON: function(t, e, n, r) {
                        let i = 1,
                            s = t[0];
                        for (; void 0 !== s && void 0 === s[r];) s = t[i++];
                        if (void 0 === s) return;
                        let o = s[r];
                        if (void 0 !== o)
                            if (Array.isArray(o))
                                do {
                                    o = s[r], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[i++]
                                } while (void 0 !== s);
                            else if (void 0 !== o.toArray)
                            do {
                                o = s[r], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[i++]
                            } while (void 0 !== s);
                        else
                            do {
                                o = s[r], void 0 !== o && (e.push(s.time), n.push(o)), s = t[i++]
                            } while (void 0 !== s)
                    },
                    subclip: function(t, e, n, r, i = 30) {
                        const s = t.clone();
                        s.name = e;
                        const o = [];
                        for (let t = 0; t < s.tracks.length; ++t) {
                            const e = s.tracks[t],
                                a = e.getValueSize(),
                                c = [],
                                l = [];
                            for (let t = 0; t < e.times.length; ++t) {
                                const s = e.times[t] * i;
                                if (!(s < n || s >= r)) {
                                    c.push(e.times[t]);
                                    for (let n = 0; n < a; ++n) l.push(e.values[t * a + n])
                                }
                            }
                            0 !== c.length && (e.times = Na.convertArray(c, e.times.constructor), e.values = Na.convertArray(l, e.values.constructor), o.push(e))
                        }
                        s.tracks = o;
                        let a = 1 / 0;
                        for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                        for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
                        return s.resetDuration(), s
                    },
                    makeClipAdditive: function(t, e = 0, n = t, r = 30) {
                        r <= 0 && (r = 30);
                        const i = n.tracks.length,
                            s = e / r;
                        for (let e = 0; e < i; ++e) {
                            const r = n.tracks[e],
                                i = r.ValueTypeName;
                            if ("bool" === i || "string" === i) continue;
                            const o = t.tracks.find((function(t) {
                                return t.name === r.name && t.ValueTypeName === i
                            }));
                            if (void 0 === o) continue;
                            let a = 0;
                            const c = r.getValueSize();
                            r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = c / 3);
                            let l = 0;
                            const u = o.getValueSize();
                            o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = u / 3);
                            const h = r.times.length - 1;
                            let d;
                            if (s <= r.times[0]) {
                                const t = a,
                                    e = c - a;
                                d = Na.arraySlice(r.values, t, e)
                            } else if (s >= r.times[h]) {
                                const t = h * c + a,
                                    e = t + c - a;
                                d = Na.arraySlice(r.values, t, e)
                            } else {
                                const t = r.createInterpolant(),
                                    e = a,
                                    n = c - a;
                                t.evaluate(s), d = Na.arraySlice(t.resultBuffer, e, n)
                            }
                            if ("quaternion" === i) {
                                (new Tt).fromArray(d).normalize().conjugate().toArray(d)
                            }
                            const p = o.times.length;
                            for (let t = 0; t < p; ++t) {
                                const e = t * u + l;
                                if ("quaternion" === i) Tt.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                                else {
                                    const t = u - 2 * l;
                                    for (let n = 0; n < t; ++n) o.values[e + n] -= d[n]
                                }
                            }
                        }
                        return t.blendMode = 2501, t
                    }
                };
                class Ba {
                    constructor(t, e, n, r) {
                        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                    }
                    evaluate(t) {
                        const e = this.parameterPositions;
                        let n = this._cachedIndex,
                            r = e[n],
                            i = e[n - 1];
                        t: {
                            e: {
                                let s;
                                n: {
                                    r: if (!(t < r)) {
                                        for (let s = n + 2;;) {
                                            if (void 0 === r) {
                                                if (t < i) break r;
                                                return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                                            }
                                            if (n === s) break;
                                            if (i = r, r = e[++n], t < r) break e
                                        }
                                        s = e.length;
                                        break n
                                    }if (t >= i) break t; {
                                        const o = e[1];
                                        t < o && (n = 2, i = o);
                                        for (let s = n - 2;;) {
                                            if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                            if (n === s) break;
                                            if (r = i, i = e[--n - 1], t >= i) break e
                                        }
                                        s = n, n = 0
                                    }
                                }
                                for (; n < s;) {
                                    const r = n + s >>> 1;
                                    t < e[r] ? s = r : n = r + 1
                                }
                                if (r = e[n], i = e[n - 1], void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t)
                            }
                            this._cachedIndex = n,
                            this.intervalChanged_(n, i, r)
                        }
                        return this.interpolate_(n, i, t, r)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            r = this.valueSize,
                            i = t * r;
                        for (let t = 0; t !== r; ++t) e[t] = n[i + t];
                        return e
                    }
                    interpolate_() {
                        throw new Error("call to abstract method")
                    }
                    intervalChanged_() {}
                }
                Ba.prototype.beforeStart_ = Ba.prototype.copySampleValue_, Ba.prototype.afterEnd_ = Ba.prototype.copySampleValue_;
                class za extends Ba {
                    constructor(t, e, n, r) {
                        super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                            endingStart: W,
                            endingEnd: W
                        }
                    }
                    intervalChanged_(t, e, n) {
                        const r = this.parameterPositions;
                        let i = t - 2,
                            s = t + 1,
                            o = r[i],
                            a = r[s];
                        if (void 0 === o) switch (this.getSettings_().endingStart) {
                            case j:
                                i = t, o = 2 * e - n;
                                break;
                            case 2402:
                                i = r.length - 2, o = e + r[i] - r[i + 1];
                                break;
                            default:
                                i = t, o = n
                        }
                        if (void 0 === a) switch (this.getSettings_().endingEnd) {
                            case j:
                                s = t, a = 2 * n - e;
                                break;
                            case 2402:
                                s = 1, a = n + r[1] - r[0];
                                break;
                            default:
                                s = t - 1, a = e
                        }
                        const c = .5 * (n - e),
                            l = this.valueSize;
                        this._weightPrev = c / (e - o), this._weightNext = c / (a - n), this._offsetPrev = i * l, this._offsetNext = s * l
                    }
                    interpolate_(t, e, n, r) {
                        const i = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            c = a - o,
                            l = this._offsetPrev,
                            u = this._offsetNext,
                            h = this._weightPrev,
                            d = this._weightNext,
                            p = (n - e) / (r - e),
                            f = p * p,
                            m = f * p,
                            g = -h * m + 2 * h * f - h * p,
                            v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
                            y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                            x = d * m - d * f;
                        for (let t = 0; t !== o; ++t) i[t] = g * s[l + t] + v * s[c + t] + y * s[a + t] + x * s[u + t];
                        return i
                    }
                }
                class Fa extends Ba {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    interpolate_(t, e, n, r) {
                        const i = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = t * o,
                            c = a - o,
                            l = (n - e) / (r - e),
                            u = 1 - l;
                        for (let t = 0; t !== o; ++t) i[t] = s[c + t] * u + s[a + t] * l;
                        return i
                    }
                }
                class ka extends Ba {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    interpolate_(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }
                class Ua {
                    constructor(t, e, n, r) {
                        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = Na.convertArray(e, this.TimeBufferType), this.values = Na.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
                    }
                    static toJSON(t) {
                        const e = t.constructor;
                        let n;
                        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                        else {
                            n = {
                                name: t.name,
                                times: Na.convertArray(t.times, Array),
                                values: Na.convertArray(t.values, Array)
                            };
                            const e = t.getInterpolation();
                            e !== t.DefaultInterpolation && (n.interpolation = e)
                        }
                        return n.type = t.ValueTypeName, n
                    }
                    InterpolantFactoryMethodDiscrete(t) {
                        return new ka(this.times, this.values, this.getValueSize(), t)
                    }
                    InterpolantFactoryMethodLinear(t) {
                        return new Fa(this.times, this.values, this.getValueSize(), t)
                    }
                    InterpolantFactoryMethodSmooth(t) {
                        return new za(this.times, this.values, this.getValueSize(), t)
                    }
                    setInterpolation(t) {
                        let e;
                        switch (t) {
                            case G:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case V:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case 2302:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(e);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", e), this
                        }
                        return this.createInterpolant = e, this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return G;
                            case this.InterpolantFactoryMethodLinear:
                                return V;
                            case this.InterpolantFactoryMethodSmooth:
                                return 2302
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(t) {
                        if (0 !== t) {
                            const e = this.times;
                            for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
                        }
                        return this
                    }
                    scale(t) {
                        if (1 !== t) {
                            const e = this.times;
                            for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
                        }
                        return this
                    }
                    trim(t, e) {
                        const n = this.times,
                            r = n.length;
                        let i = 0,
                            s = r - 1;
                        for (; i !== r && n[i] < t;) ++i;
                        for (; - 1 !== s && n[s] > e;) --s;
                        if (++s, 0 !== i || s !== r) {
                            i >= s && (s = Math.max(s, 1), i = s - 1);
                            const t = this.getValueSize();
                            this.times = Na.arraySlice(n, i, s), this.values = Na.arraySlice(this.values, i * t, s * t)
                        }
                        return this
                    }
                    validate() {
                        let t = !0;
                        const e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        const n = this.times,
                            r = this.values,
                            i = n.length;
                        0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        let s = null;
                        for (let e = 0; e !== i; e++) {
                            const r = n[e];
                            if ("number" == typeof r && isNaN(r)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, r), t = !1;
                                break
                            }
                            if (null !== s && s > r) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, e, r, s), t = !1;
                                break
                            }
                            s = r
                        }
                        if (void 0 !== r && Na.isTypedArray(r))
                            for (let e = 0, n = r.length; e !== n; ++e) {
                                const n = r[e];
                                if (isNaN(n)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                    break
                                }
                            }
                        return t
                    }
                    optimize() {
                        const t = Na.arraySlice(this.times),
                            e = Na.arraySlice(this.values),
                            n = this.getValueSize(),
                            r = 2302 === this.getInterpolation(),
                            i = t.length - 1;
                        let s = 1;
                        for (let o = 1; o < i; ++o) {
                            let i = !1;
                            const a = t[o];
                            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                                if (r) i = !0;
                                else {
                                    const t = o * n,
                                        r = t - n,
                                        s = t + n;
                                    for (let o = 0; o !== n; ++o) {
                                        const n = e[t + o];
                                        if (n !== e[r + o] || n !== e[s + o]) {
                                            i = !0;
                                            break
                                        }
                                    }
                                }
                            if (i) {
                                if (o !== s) {
                                    t[s] = t[o];
                                    const r = o * n,
                                        i = s * n;
                                    for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
                                }++s
                            }
                        }
                        if (i > 0) {
                            t[s] = t[i];
                            for (let t = i * n, r = s * n, o = 0; o !== n; ++o) e[r + o] = e[t + o];
                            ++s
                        }
                        return s !== t.length ? (this.times = Na.arraySlice(t, 0, s), this.values = Na.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                    }
                    clone() {
                        const t = Na.arraySlice(this.times, 0),
                            e = Na.arraySlice(this.values, 0),
                            n = new(0, this.constructor)(this.name, t, e);
                        return n.createInterpolant = this.createInterpolant, n
                    }
                }
                Ua.prototype.TimeBufferType = Float32Array, Ua.prototype.ValueBufferType = Float32Array, Ua.prototype.DefaultInterpolation = V;
                class Ha extends Ua {}
                Ha.prototype.ValueTypeName = "bool", Ha.prototype.ValueBufferType = Array, Ha.prototype.DefaultInterpolation = G, Ha.prototype.InterpolantFactoryMethodLinear = void 0, Ha.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Ga extends Ua {}
                Ga.prototype.ValueTypeName = "color";
                class Va extends Ua {}
                Va.prototype.ValueTypeName = "number";
                class Wa extends Ba {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    interpolate_(t, e, n, r) {
                        const i = this.resultBuffer,
                            s = this.sampleValues,
                            o = this.valueSize,
                            a = (n - e) / (r - e);
                        let c = t * o;
                        for (let t = c + o; c !== t; c += 4) Tt.slerpFlat(i, 0, s, c - o, s, c, a);
                        return i
                    }
                }
                class ja extends Ua {
                    InterpolantFactoryMethodLinear(t) {
                        return new Wa(this.times, this.values, this.getValueSize(), t)
                    }
                }
                ja.prototype.ValueTypeName = "quaternion", ja.prototype.DefaultInterpolation = V, ja.prototype.InterpolantFactoryMethodSmooth = void 0;
                class Za extends Ua {}
                Za.prototype.ValueTypeName = "string", Za.prototype.ValueBufferType = Array, Za.prototype.DefaultInterpolation = G, Za.prototype.InterpolantFactoryMethodLinear = void 0, Za.prototype.InterpolantFactoryMethodSmooth = void 0;
                class qa extends Ua {}
                qa.prototype.ValueTypeName = "vector";
                class Xa {
                    constructor(t, e = -1, n, r = 2500) {
                        this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = st(), this.duration < 0 && this.resetDuration()
                    }
                    static parse(t) {
                        const e = [],
                            n = t.tracks,
                            r = 1 / (t.fps || 1);
                        for (let t = 0, i = n.length; t !== i; ++t) e.push(Ya(n[t]).scale(r));
                        const i = new this(t.name, t.duration, e, t.blendMode);
                        return i.uuid = t.uuid, i
                    }
                    static toJSON(t) {
                        const e = [],
                            n = t.tracks,
                            r = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid,
                                blendMode: t.blendMode
                            };
                        for (let t = 0, r = n.length; t !== r; ++t) e.push(Ua.toJSON(n[t]));
                        return r
                    }
                    static CreateFromMorphTargetSequence(t, e, n, r) {
                        const i = e.length,
                            s = [];
                        for (let t = 0; t < i; t++) {
                            let o = [],
                                a = [];
                            o.push((t + i - 1) % i, t, (t + 1) % i), a.push(0, 1, 0);
                            const c = Na.getKeyframeOrder(o);
                            o = Na.sortedArray(o, 1, c), a = Na.sortedArray(a, 1, c), r || 0 !== o[0] || (o.push(i), a.push(a[0])), s.push(new Va(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                        }
                        return new this(t, -1, s)
                    }
                    static findByName(t, e) {
                        let n = t;
                        if (!Array.isArray(t)) {
                            const e = t;
                            n = e.geometry && e.geometry.animations || e.animations
                        }
                        for (let t = 0; t < n.length; t++)
                            if (n[t].name === e) return n[t];
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(t, e, n) {
                        const r = {},
                            i = /^([\w-]*?)([\d]+)$/;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e],
                                s = n.name.match(i);
                            if (s && s.length > 1) {
                                const t = s[1];
                                let e = r[t];
                                e || (r[t] = e = []), e.push(n)
                            }
                        }
                        const s = [];
                        for (const t in r) s.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
                        return s
                    }
                    static parseAnimation(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        const n = function(t, e, n, r, i) {
                                if (0 !== n.length) {
                                    const s = [],
                                        o = [];
                                    Na.flattenJSON(n, s, o, r), 0 !== s.length && i.push(new t(e, s, o))
                                }
                            },
                            r = [],
                            i = t.name || "default",
                            s = t.fps || 30,
                            o = t.blendMode;
                        let a = t.length || -1;
                        const c = t.hierarchy || [];
                        for (let t = 0; t < c.length; t++) {
                            const i = c[t].keys;
                            if (i && 0 !== i.length)
                                if (i[0].morphTargets) {
                                    const t = {};
                                    let e;
                                    for (e = 0; e < i.length; e++)
                                        if (i[e].morphTargets)
                                            for (let n = 0; n < i[e].morphTargets.length; n++) t[i[e].morphTargets[n]] = -1;
                                    for (const n in t) {
                                        const t = [],
                                            s = [];
                                        for (let r = 0; r !== i[e].morphTargets.length; ++r) {
                                            const r = i[e];
                                            t.push(r.time), s.push(r.morphTarget === n ? 1 : 0)
                                        }
                                        r.push(new Va(".morphTargetInfluence[" + n + "]", t, s))
                                    }
                                    a = t.length * (s || 1)
                                } else {
                                    const s = ".bones[" + e[t].name + "]";
                                    n(qa, s + ".position", i, "pos", r), n(ja, s + ".quaternion", i, "rot", r), n(qa, s + ".scale", i, "scl", r)
                                }
                        }
                        if (0 === r.length) return null;
                        return new this(i, a, r, o)
                    }
                    resetDuration() {
                        let t = 0;
                        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                            const n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    }
                    trim() {
                        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    }
                    validate() {
                        let t = !0;
                        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    }
                    optimize() {
                        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    }
                    clone() {
                        const t = [];
                        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                        return new this.constructor(this.name, this.duration, t, this.blendMode)
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }

                function Ya(t) {
                    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                    const e = function(t) {
                        switch (t.toLowerCase()) {
                            case "scalar":
                            case "double":
                            case "float":
                            case "number":
                            case "integer":
                                return Va;
                            case "vector":
                            case "vector2":
                            case "vector3":
                            case "vector4":
                                return qa;
                            case "color":
                                return Ga;
                            case "quaternion":
                                return ja;
                            case "bool":
                            case "boolean":
                                return Ha;
                            case "string":
                                return Za
                        }
                        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                    }(t.type);
                    if (void 0 === t.times) {
                        const e = [],
                            n = [];
                        Na.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                    }
                    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
                }
                const Ja = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        !1 !== this.enabled && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (!1 !== this.enabled) return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                const Ka = new class {
                    constructor(t, e, n) {
                        const r = this;
                        let i, s = !1,
                            o = 0,
                            a = 0;
                        const c = [];
                        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                            a++, !1 === s && void 0 !== r.onStart && r.onStart(t, o, a), s = !0
                        }, this.itemEnd = function(t) {
                            o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (s = !1, void 0 !== r.onLoad && r.onLoad())
                        }, this.itemError = function(t) {
                            void 0 !== r.onError && r.onError(t)
                        }, this.resolveURL = function(t) {
                            return i ? i(t) : t
                        }, this.setURLModifier = function(t) {
                            return i = t, this
                        }, this.addHandler = function(t, e) {
                            return c.push(t, e), this
                        }, this.removeHandler = function(t) {
                            const e = c.indexOf(t);
                            return -1 !== e && c.splice(e, 2), this
                        }, this.getHandler = function(t) {
                            for (let e = 0, n = c.length; e < n; e += 2) {
                                const n = c[e],
                                    r = c[e + 1];
                                if (n.global && (n.lastIndex = 0), n.test(t)) return r
                            }
                            return null
                        }
                    }
                };
                class Qa {
                    constructor(t) {
                        this.manager = void 0 !== t ? t : Ka, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(t, e) {
                        const n = this;
                        return new Promise((function(r, i) {
                            n.load(t, r, e, i)
                        }))
                    }
                    parse() {}
                    setCrossOrigin(t) {
                        return this.crossOrigin = t, this
                    }
                    setWithCredentials(t) {
                        return this.withCredentials = t, this
                    }
                    setPath(t) {
                        return this.path = t, this
                    }
                    setResourcePath(t) {
                        return this.resourcePath = t, this
                    }
                    setRequestHeader(t) {
                        return this.requestHeader = t, this
                    }
                }
                const $a = {};
                class tc extends Qa {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const o = this,
                            a = Ja.get(t);
                        if (void 0 !== a) return o.manager.itemStart(t), setTimeout((function() {
                            e && e(a), o.manager.itemEnd(t)
                        }), 0), a;
                        if (void 0 !== $a[t]) return void $a[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: r
                        });
                        const l = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        let h;
                        if (l) {
                            const n = l[1],
                                a = !!l[2];
                            let u = l[3];
                            u = decodeURIComponent(u), a && (u = i(u));
                            try {
                                let r;
                                const i = (this.responseType || "").toLowerCase();
                                switch (i) {
                                    case "arraybuffer":
                                    case "blob":
                                        const t = new Uint8Array(u.length);
                                        for (let e = 0; e < u.length; e++) t[e] = u.charCodeAt(e);
                                        r = "blob" === i ? new s([t.buffer], {
                                            type: n
                                        }) : t.buffer;
                                        break;
                                    case "document":
                                        const e = new c;
                                        r = e.parseFromString(u, n);
                                        break;
                                    case "json":
                                        r = JSON.parse(u);
                                        break;
                                    default:
                                        r = u
                                }
                                setTimeout((function() {
                                    e && e(r), o.manager.itemEnd(t)
                                }), 0)
                            } catch (e) {
                                setTimeout((function() {
                                    r && r(e), o.manager.itemError(t), o.manager.itemEnd(t)
                                }), 0)
                            }
                        } else {
                            $a[t] = [], $a[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: r
                            }), h = new u, h.open("GET", t, !0), h.addEventListener("load", (function(e) {
                                const n = this.response,
                                    r = $a[t];
                                if (delete $a[t], 200 === this.status || 0 === this.status) {
                                    0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ja.add(t, n);
                                    for (let t = 0, e = r.length; t < e; t++) {
                                        const e = r[t];
                                        e.onLoad && e.onLoad(n)
                                    }
                                    o.manager.itemEnd(t)
                                } else {
                                    for (let t = 0, n = r.length; t < n; t++) {
                                        const n = r[t];
                                        n.onError && n.onError(e)
                                    }
                                    o.manager.itemError(t), o.manager.itemEnd(t)
                                }
                            }), !1), h.addEventListener("progress", (function(e) {
                                const n = $a[t];
                                for (let t = 0, r = n.length; t < r; t++) {
                                    const r = n[t];
                                    r.onProgress && r.onProgress(e)
                                }
                            }), !1), h.addEventListener("error", (function(e) {
                                const n = $a[t];
                                delete $a[t];
                                for (let t = 0, r = n.length; t < r; t++) {
                                    const r = n[t];
                                    r.onError && r.onError(e)
                                }
                                o.manager.itemError(t), o.manager.itemEnd(t)
                            }), !1), h.addEventListener("abort", (function(e) {
                                const n = $a[t];
                                delete $a[t];
                                for (let t = 0, r = n.length; t < r; t++) {
                                    const r = n[t];
                                    r.onError && r.onError(e)
                                }
                                o.manager.itemError(t), o.manager.itemEnd(t)
                            }), !1), void 0 !== this.responseType && (h.responseType = this.responseType), void 0 !== this.withCredentials && (h.withCredentials = this.withCredentials), h.overrideMimeType && h.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                            for (const t in this.requestHeader) h.setRequestHeader(t, this.requestHeader[t]);
                            h.send(null)
                        }
                        return o.manager.itemStart(t), h
                    }
                    setResponseType(t) {
                        return this.responseType = t, this
                    }
                    setMimeType(t) {
                        return this.mimeType = t, this
                    }
                }
                class ec extends Qa {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const i = this,
                            s = Ja.get(t);
                        if (void 0 !== s) return i.manager.itemStart(t), setTimeout((function() {
                            e && e(s), i.manager.itemEnd(t)
                        }), 0), s;
                        const o = gt("img");

                        function a() {
                            o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1), Ja.add(t, this), e && e(this), i.manager.itemEnd(t)
                        }

                        function c(e) {
                            o.removeEventListener("load", a, !1), o.removeEventListener("error", c, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                        }
                        return o.addEventListener("load", a, !1), o.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o
                    }
                }
                class nc extends Qa {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = new Fn,
                            s = new ec(this.manager);
                        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                        let o = 0;

                        function a(n) {
                            s.load(t[n], (function(t) {
                                i.images[n] = t, o++, 6 === o && (i.needsUpdate = !0, e && e(i))
                            }), void 0, r)
                        }
                        for (let e = 0; e < t.length; ++e) a(e);
                        return i
                    }
                }
                class rc extends Qa {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = new _t,
                            s = new ec(this.manager);
                        return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(t) {
                            i.image = t, i.needsUpdate = !0, void 0 !== e && e(i)
                        }), n, r), i
                    }
                }
                class ic extends Le {
                    constructor(t, e = 1) {
                        super(), this.type = "Light", this.color = new Xe(t), this.intensity = e
                    }
                    dispose() {}
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                    }
                }
                ic.prototype.isLight = !0;
                class sc extends ic {
                    constructor(t, e, n) {
                        super(t, n), this.type = "HemisphereLight", this.position.copy(Le.DefaultUp), this.updateMatrix(), this.groundColor = new Xe(e)
                    }
                    copy(t) {
                        return ic.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                    }
                }
                sc.prototype.isHemisphereLight = !0;
                const oc = new re,
                    ac = new Et,
                    cc = new Et;
                class lc {
                    constructor(t) {
                        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new pt(512, 512), this.map = null, this.mapPass = null, this.matrix = new re, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Zn, this._frameExtents = new pt(1, 1), this._viewportCount = 1, this._viewports = [new wt(0, 0, 1, 1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = this.matrix;
                        ac.setFromMatrixPosition(t.matrixWorld), e.position.copy(ac), cc.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(cc), e.updateMatrixWorld(), oc.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(oc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                    }
                    getViewport(t) {
                        return this._viewports[t]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                    }
                    copy(t) {
                        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    toJSON() {
                        const t = {};
                        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                    }
                }
                class uc extends lc {
                    constructor() {
                        super(new Bn(50, 1, .5, 500)), this.focus = 1
                    }
                    updateMatrices(t) {
                        const e = this.camera,
                            n = 2 * nt * t.angle * this.focus,
                            r = this.mapSize.width / this.mapSize.height,
                            i = t.distance || e.far;
                        n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t)
                    }
                    copy(t) {
                        return super.copy(t), this.focus = t.focus, this
                    }
                }
                uc.prototype.isSpotLightShadow = !0;
                class hc extends ic {
                    constructor(t, e, n = 0, r = Math.PI / 3, i = 0, s = 1) {
                        super(t, e), this.type = "SpotLight", this.position.copy(Le.DefaultUp), this.updateMatrix(), this.target = new Le, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new uc
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                    }
                }
                hc.prototype.isSpotLight = !0;
                const dc = new re,
                    pc = new Et,
                    fc = new Et;
                class mc extends lc {
                    constructor() {
                        super(new Bn(90, 1, .5, 500)), this._frameExtents = new pt(4, 2), this._viewportCount = 6, this._viewports = [new wt(2, 1, 1, 1), new wt(0, 1, 1, 1), new wt(3, 1, 1, 1), new wt(1, 1, 1, 1), new wt(3, 0, 1, 1), new wt(1, 0, 1, 1)], this._cubeDirections = [new Et(1, 0, 0), new Et(-1, 0, 0), new Et(0, 0, 1), new Et(0, 0, -1), new Et(0, 1, 0), new Et(0, -1, 0)], this._cubeUps = [new Et(0, 1, 0), new Et(0, 1, 0), new Et(0, 1, 0), new Et(0, 1, 0), new Et(0, 0, 1), new Et(0, 0, -1)]
                    }
                    updateMatrices(t, e = 0) {
                        const n = this.camera,
                            r = this.matrix,
                            i = t.distance || n.far;
                        i !== n.far && (n.far = i, n.updateProjectionMatrix()), pc.setFromMatrixPosition(t.matrixWorld), n.position.copy(pc), fc.copy(n.position), fc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(fc), n.updateMatrixWorld(), r.makeTranslation(-pc.x, -pc.y, -pc.z), dc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dc)
                    }
                }
                mc.prototype.isPointLightShadow = !0;
                class gc extends ic {
                    constructor(t, e, n = 0, r = 1) {
                        super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new mc
                    }
                    get power() {
                        return 4 * this.intensity * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                    }
                }
                gc.prototype.isPointLight = !0;
                class vc extends lc {
                    constructor() {
                        super(new sr(-5, 5, 5, -5, .5, 500))
                    }
                }
                vc.prototype.isDirectionalLightShadow = !0;
                class yc extends ic {
                    constructor(t, e) {
                        super(t, e), this.type = "DirectionalLight", this.position.copy(Le.DefaultUp), this.updateMatrix(), this.target = new Le, this.shadow = new vc
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(t) {
                        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                    }
                }
                yc.prototype.isDirectionalLight = !0;
                (class extends ic {
                    constructor(t, e) {
                        super(t, e), this.type = "AmbientLight"
                    }
                }).prototype.isAmbientLight = !0;
                (class extends ic {
                    constructor(t, e, n = 10, r = 10) {
                        super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(t) {
                        this.intensity = t / (this.width * this.height * Math.PI)
                    }
                    copy(t) {
                        return super.copy(t), this.width = t.width, this.height = t.height, this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.width = this.width, e.object.height = this.height, e
                    }
                }).prototype.isRectAreaLight = !0;
                class xc {
                    constructor() {
                        this.coefficients = [];
                        for (let t = 0; t < 9; t++) this.coefficients.push(new Et)
                    }
                    set(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                        return this
                    }
                    zero() {
                        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                        return this
                    }
                    getAt(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * r), e.addScaledVector(s[2], .488603 * i), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * r * 1.092548), e.addScaledVector(s[5], r * i * 1.092548), e.addScaledVector(s[6], .315392 * (3 * i * i - 1)), e.addScaledVector(s[7], n * i * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - r * r)), e
                    }
                    getIrradianceAt(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z,
                            s = this.coefficients;
                        return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * r), e.addScaledVector(s[2], 1.023328 * i), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * r), e.addScaledVector(s[5], .858086 * r * i), e.addScaledVector(s[6], .743125 * i * i - .247708), e.addScaledVector(s[7], .858086 * n * i), e.addScaledVector(s[8], .429043 * (n * n - r * r)), e
                    }
                    add(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                        return this
                    }
                    addScaledSH(t, e) {
                        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                        return this
                    }
                    scale(t) {
                        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                        return this
                    }
                    lerp(t, e) {
                        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                        return this
                    }
                    equals(t) {
                        for (let e = 0; e < 9; e++)
                            if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                        return !0
                    }
                    copy(t) {
                        return this.set(t.coefficients)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    fromArray(t, e = 0) {
                        const n = this.coefficients;
                        for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
                        return this
                    }
                    toArray(t = [], e = 0) {
                        const n = this.coefficients;
                        for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
                        return t
                    }
                    static getBasisAt(t, e) {
                        const n = t.x,
                            r = t.y,
                            i = t.z;
                        e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
                    }
                }
                xc.prototype.isSphericalHarmonics3 = !0;
                class _c extends ic {
                    constructor(t = new xc, e = 1) {
                        super(void 0, e), this.sh = t
                    }
                    copy(t) {
                        return super.copy(t), this.sh.copy(t.sh), this
                    }
                    fromJSON(t) {
                        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.object.sh = this.sh.toArray(), e
                    }
                }
                _c.prototype.isLightProbe = !0;
                class bc {
                    static decodeText(t) {
                        if (void 0 !== l) return (new l).decode(t);
                        let e = "";
                        for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                        try {
                            return decodeURIComponent(escape(e))
                        } catch (t) {
                            return e
                        }
                    }
                    static extractUrlBase(t) {
                        const e = t.lastIndexOf("/");
                        return -1 === e ? "./" : t.substr(0, e + 1)
                    }
                }(class extends un {
                    constructor() {
                        super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                    }
                    copy(t) {
                        return super.copy(t), this.instanceCount = t.instanceCount, this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    toJSON() {
                        const t = super.toJSON(this);
                        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                    }
                }).prototype.isInstancedBufferGeometry = !0;
                class wc extends Qa {
                    constructor(t) {
                        super(t), void 0 === p && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                            premultiplyAlpha: "none"
                        }
                    }
                    setOptions(t) {
                        return this.options = t, this
                    }
                    load(t, e, n, r) {
                        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                        const i = this,
                            s = Ja.get(t);
                        if (void 0 !== s) return i.manager.itemStart(t), setTimeout((function() {
                            e && e(s), i.manager.itemEnd(t)
                        }), 0), s;
                        const o = {};
                        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function(t) {
                            return t.blob()
                        })).then((function(t) {
                            return p(t, Object.assign(i.options, {
                                colorSpaceConversion: "none"
                            }))
                        })).then((function(n) {
                            Ja.add(t, n), e && e(n), i.manager.itemEnd(t)
                        })).catch((function(e) {
                            r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                        })), i.manager.itemStart(t)
                    }
                }
                let Mc;
                wc.prototype.isImageBitmapLoader = !0;
                const Sc = function() {
                    return void 0 === Mc && (Mc = new(o.AudioContext || o.webkitAudioContext)), Mc
                };
                class Tc extends Qa {
                    constructor(t) {
                        super(t)
                    }
                    load(t, e, n, r) {
                        const i = this,
                            s = new tc(this.manager);
                        s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                            try {
                                const t = n.slice(0);
                                Sc().decodeAudioData(t, (function(t) {
                                    e(t)
                                }))
                            } catch (e) {
                                r ? r(e) : console.error(e), i.manager.itemError(t)
                            }
                        }), n, r)
                    }
                }(class extends _c {
                    constructor(t, e, n = 1) {
                        super(void 0, n);
                        const r = (new Xe).set(t),
                            i = (new Xe).set(e),
                            s = new Et(r.r, r.g, r.b),
                            o = new Et(i.r, i.g, i.b),
                            a = Math.sqrt(Math.PI),
                            c = a * Math.sqrt(.75);
                        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(c)
                    }
                }).prototype.isHemisphereLightProbe = !0;
                (class extends _c {
                    constructor(t, e = 1) {
                        super(void 0, e);
                        const n = (new Xe).set(t);
                        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                    }
                }).prototype.isAmbientLightProbe = !0;
                class Ec {
                    constructor(t = !0) {
                        this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                    }
                    start() {
                        this.startTime = Ac(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                    }
                    stop() {
                        this.getElapsedTime(), this.running = !1, this.autoStart = !1
                    }
                    getElapsedTime() {
                        return this.getDelta(), this.elapsedTime
                    }
                    getDelta() {
                        let t = 0;
                        if (this.autoStart && !this.running) return this.start(), 0;
                        if (this.running) {
                            const e = Ac();
                            t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                        }
                        return t
                    }
                }

                function Ac() {
                    return ("undefined" == typeof performance ? Date : performance).now()
                }
                class Lc {
                    constructor(t, e, n) {
                        let r, i, s;
                        switch (this.binding = t, this.valueSize = n, e) {
                            case "quaternion":
                                r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                                break;
                            case "string":
                            case "bool":
                                r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                                break;
                            default:
                                r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                        }
                        this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                    }
                    accumulate(t, e) {
                        const n = this.buffer,
                            r = this.valueSize,
                            i = t * r + r;
                        let s = this.cumulativeWeight;
                        if (0 === s) {
                            for (let t = 0; t !== r; ++t) n[i + t] = n[t];
                            s = e
                        } else {
                            s += e;
                            const t = e / s;
                            this._mixBufferRegion(n, i, 0, t, r)
                        }
                        this.cumulativeWeight = s
                    }
                    accumulateAdditive(t) {
                        const e = this.buffer,
                            n = this.valueSize,
                            r = n * this._addIndex;
                        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
                    }
                    apply(t) {
                        const e = this.valueSize,
                            n = this.buffer,
                            r = t * e + e,
                            i = this.cumulativeWeight,
                            s = this.cumulativeWeightAdditive,
                            o = this.binding;
                        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
                            const t = e * this._origIndex;
                            this._mixBufferRegion(n, r, t, 1 - i, e)
                        }
                        s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
                        for (let t = e, i = e + e; t !== i; ++t)
                            if (n[t] !== n[t + e]) {
                                o.setValue(n, r);
                                break
                            }
                    }
                    saveOriginalState() {
                        const t = this.binding,
                            e = this.buffer,
                            n = this.valueSize,
                            r = n * this._origIndex;
                        t.getValue(e, r);
                        for (let t = n, i = r; t !== i; ++t) e[t] = e[r + t % n];
                        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    }
                    _setAdditiveIdentityNumeric() {
                        const t = this._addIndex * this.valueSize,
                            e = t + this.valueSize;
                        for (let n = t; n < e; n++) this.buffer[n] = 0
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const t = this._origIndex * this.valueSize,
                            e = this._addIndex * this.valueSize;
                        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                    }
                    _select(t, e, n, r, i) {
                        if (r >= .5)
                            for (let r = 0; r !== i; ++r) t[e + r] = t[n + r]
                    }
                    _slerp(t, e, n, r) {
                        Tt.slerpFlat(t, e, t, e, t, n, r)
                    }
                    _slerpAdditive(t, e, n, r, i) {
                        const s = this._workIndex * i;
                        Tt.multiplyQuaternionsFlat(t, s, t, e, t, n), Tt.slerpFlat(t, e, t, e, t, s, r)
                    }
                    _lerp(t, e, n, r, i) {
                        const s = 1 - r;
                        for (let o = 0; o !== i; ++o) {
                            const i = e + o;
                            t[i] = t[i] * s + t[n + o] * r
                        }
                    }
                    _lerpAdditive(t, e, n, r, i) {
                        for (let s = 0; s !== i; ++s) {
                            const i = e + s;
                            t[i] = t[i] + t[n + s] * r
                        }
                    }
                }
                const Rc = "\\[\\]\\.:\\/",
                    Pc = new RegExp("[" + Rc + "]", "g"),
                    Cc = "[^" + Rc + "]",
                    Ic = "[^" + Rc.replace("\\.", "") + "]",
                    Dc = /((?:WC+[\/:])*)/.source.replace("WC", Cc),
                    Oc = /(WCOD+)?/.source.replace("WCOD", Ic),
                    Nc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Cc),
                    Bc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Cc),
                    zc = new RegExp("^" + Dc + Oc + Nc + Bc + "$"),
                    Fc = ["material", "materials", "bones"];
                class kc {
                    constructor(t, e, n) {
                        this.path = e, this.parsedPath = n || kc.parseTrackName(e), this.node = kc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                    static create(t, e, n) {
                        return t && t.isAnimationObjectGroup ? new kc.Composite(t, e, n) : new kc(t, e, n)
                    }
                    static sanitizeNodeName(t) {
                        return t.replace(/\s/g, "_").replace(Pc, "")
                    }
                    static parseTrackName(t) {
                        const e = zc.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        const n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6]
                            },
                            r = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== r && -1 !== r) {
                            const t = n.nodeName.substring(r + 1); - 1 !== Fc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                    static findNode(t, e) {
                        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            const n = t.skeleton.getBoneByName(e);
                            if (void 0 !== n) return n
                        }
                        if (t.children) {
                            const n = function(t) {
                                    for (let r = 0; r < t.length; r++) {
                                        const i = t[r];
                                        if (i.name === e || i.uuid === e) return i;
                                        const s = n(i.children);
                                        if (s) return s
                                    }
                                    return null
                                },
                                r = n(t.children);
                            if (r) return r
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(t, e) {
                        t[e] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
                    }
                    _getValue_arrayElement(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }
                    _setValue_direct(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }
                    _setValue_direct_setNeedsUpdate(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
                    }
                    _setValue_array_setNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                        const n = this.resolvedProperty;
                        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }
                    _setValue_arrayElement_setNeedsUpdate(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }
                    _setValue_fromArray_setNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(t, e) {
                        this.bind(), this.getValue(t, e)
                    }
                    _setValue_unbound(t, e) {
                        this.bind(), this.setValue(t, e)
                    }
                    bind() {
                        let t = this.node;
                        const e = this.parsedPath,
                            n = e.objectName,
                            r = e.propertyName;
                        let i = e.propertyIndex;
                        if (t || (t = kc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                        if (n) {
                            let r = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (let e = 0; e < t.length; e++)
                                        if (t[e].name === r) {
                                            r = e;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== r) {
                                if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[r]
                            }
                        }
                        const s = t[r];
                        if (void 0 === s) {
                            const n = e.nodeName;
                            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
                        }
                        let o = this.Versioning.None;
                        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                        let a = this.BindingType.Direct;
                        if (void 0 !== i) {
                            if ("morphTargetInfluences" === r) {
                                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
                            }
                            a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                    }
                    unbind() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }
                kc.Composite = class {
                    constructor(t, e, n) {
                        const r = n || kc.parseTrackName(e);
                        this._targetGroup = t, this._bindings = t.subscribe_(e, r)
                    }
                    getValue(t, e) {
                        this.bind();
                        const n = this._targetGroup.nCachedObjects_,
                            r = this._bindings[n];
                        void 0 !== r && r.getValue(t, e)
                    }
                    setValue(t, e) {
                        const n = this._bindings;
                        for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
                    }
                    bind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                    }
                    unbind() {
                        const t = this._bindings;
                        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                    }
                }, kc.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                }, kc.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                }, kc.prototype.GetterByBindingType = [kc.prototype._getValue_direct, kc.prototype._getValue_array, kc.prototype._getValue_arrayElement, kc.prototype._getValue_toArray], kc.prototype.SetterByBindingTypeAndVersioning = [
                    [kc.prototype._setValue_direct, kc.prototype._setValue_direct_setNeedsUpdate, kc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [kc.prototype._setValue_array, kc.prototype._setValue_array_setNeedsUpdate, kc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [kc.prototype._setValue_arrayElement, kc.prototype._setValue_arrayElement_setNeedsUpdate, kc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [kc.prototype._setValue_fromArray, kc.prototype._setValue_fromArray_setNeedsUpdate, kc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
                ];
                (class {
                    constructor() {
                        this.uuid = st(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                        const t = {};
                        this._indicesByUUID = t;
                        for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                        const e = this;
                        this.stats = {
                            objects: {get total() {
                                    return e._objects.length
                                },
                                get inUse() {
                                    return this.total - e.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return e._bindings.length
                            }
                        }
                    }
                    add() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._paths,
                            r = this._parsedPaths,
                            i = this._bindings,
                            s = i.length;
                        let o, a = t.length,
                            c = this.nCachedObjects_;
                        for (let l = 0, u = arguments.length; l !== u; ++l) {
                            const u = arguments[l],
                                h = u.uuid;
                            let d = e[h];
                            if (void 0 === d) {
                                d = a++, e[h] = d, t.push(u);
                                for (let t = 0, e = s; t !== e; ++t) i[t].push(new kc(u, n[t], r[t]))
                            } else if (d < c) {
                                o = t[d];
                                const a = --c,
                                    l = t[a];
                                e[l.uuid] = d, t[d] = l, e[h] = a, t[a] = u;
                                for (let t = 0, e = s; t !== e; ++t) {
                                    const e = i[t],
                                        s = e[a];
                                    let o = e[d];
                                    e[d] = s, void 0 === o && (o = new kc(u, n[t], r[t])), e[a] = o
                                }
                            } else t[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = c
                    }
                    remove() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            r = n.length;
                        let i = this.nCachedObjects_;
                        for (let s = 0, o = arguments.length; s !== o; ++s) {
                            const o = arguments[s],
                                a = o.uuid,
                                c = e[a];
                            if (void 0 !== c && c >= i) {
                                const s = i++,
                                    l = t[s];
                                e[l.uuid] = c, t[c] = l, e[a] = s, t[s] = o;
                                for (let t = 0, e = r; t !== e; ++t) {
                                    const e = n[t],
                                        r = e[s],
                                        i = e[c];
                                    e[c] = r, e[s] = i
                                }
                            }
                        }
                        this.nCachedObjects_ = i
                    }
                    uncache() {
                        const t = this._objects,
                            e = this._indicesByUUID,
                            n = this._bindings,
                            r = n.length;
                        let i = this.nCachedObjects_,
                            s = t.length;
                        for (let o = 0, a = arguments.length; o !== a; ++o) {
                            const a = arguments[o].uuid,
                                c = e[a];
                            if (void 0 !== c)
                                if (delete e[a], c < i) {
                                    const o = --i,
                                        a = t[o],
                                        l = --s,
                                        u = t[l];
                                    e[a.uuid] = c, t[c] = a, e[u.uuid] = o, t[o] = u, t.pop();
                                    for (let t = 0, e = r; t !== e; ++t) {
                                        const e = n[t],
                                            r = e[o],
                                            i = e[l];
                                        e[c] = r, e[o] = i, e.pop()
                                    }
                                } else {
                                    const i = --s,
                                        o = t[i];
                                    i > 0 && (e[o.uuid] = c), t[c] = o, t.pop();
                                    for (let t = 0, e = r; t !== e; ++t) {
                                        const e = n[t];
                                        e[c] = e[i], e.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = i
                    }
                    subscribe_(t, e) {
                        const n = this._bindingsIndicesByPath;
                        let r = n[t];
                        const i = this._bindings;
                        if (void 0 !== r) return i[r];
                        const s = this._paths,
                            o = this._parsedPaths,
                            a = this._objects,
                            c = a.length,
                            l = this.nCachedObjects_,
                            u = new Array(c);
                        r = i.length, n[t] = r, s.push(t), o.push(e), i.push(u);
                        for (let n = l, r = a.length; n !== r; ++n) {
                            const r = a[n];
                            u[n] = new kc(r, t, e)
                        }
                        return u
                    }
                    unsubscribe_(t) {
                        const e = this._bindingsIndicesByPath,
                            n = e[t];
                        if (void 0 !== n) {
                            const r = this._paths,
                                i = this._parsedPaths,
                                s = this._bindings,
                                o = s.length - 1,
                                a = s[o];
                            e[t[o]] = n, s[n] = a, s.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop()
                        }
                    }
                }).prototype.isAnimationObjectGroup = !0;
                class Uc {
                    constructor(t, e, n = null, r = e.blendMode) {
                        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
                        const i = e.tracks,
                            s = i.length,
                            o = new Array(s),
                            a = {
                                endingStart: W,
                                endingEnd: W
                            };
                        for (let t = 0; t !== s; ++t) {
                            const e = i[t].createInterpolant(null);
                            o[t] = e, e.settings = a
                        }
                        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = H, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        return this._mixer._activateAction(this), this
                    }
                    stop() {
                        return this._mixer._deactivateAction(this), this.reset()
                    }
                    reset() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(t) {
                        return this._startTime = t, this
                    }
                    setLoop(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    }
                    setEffectiveWeight(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(t) {
                        return this._scheduleFading(t, 0, 1)
                    }
                    fadeOut(t) {
                        return this._scheduleFading(t, 1, 0)
                    }
                    crossFadeFrom(t, e, n) {
                        if (t.fadeOut(e), this.fadeIn(e), n) {
                            const n = this._clip.duration,
                                r = t._clip.duration,
                                i = r / n,
                                s = n / r;
                            t.warp(1, i, e), this.warp(s, 1, e)
                        }
                        return this
                    }
                    crossFadeTo(t, e, n) {
                        return t.crossFadeFrom(this, e, n)
                    }
                    stopFading() {
                        const t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    }
                    setEffectiveTimeScale(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    }
                    syncWith(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    }
                    halt(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    }
                    warp(t, e, n) {
                        const r = this._mixer,
                            i = r.time,
                            s = this.timeScale;
                        let o = this._timeScaleInterpolant;
                        null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        const a = o.parameterPositions,
                            c = o.sampleValues;
                        return a[0] = i, a[1] = i + n, c[0] = t / s, c[1] = e / s, this
                    }
                    stopWarping() {
                        const t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(t, e, n, r) {
                        if (!this.enabled) return void this._updateWeight(t);
                        const i = this._startTime;
                        if (null !== i) {
                            const r = (t - i) * n;
                            if (r < 0 || 0 === n) return;
                            this._startTime = null, e = n * r
                        }
                        e *= this._updateTimeScale(t);
                        const s = this._updateTime(e),
                            o = this._updateWeight(t);
                        if (o > 0) {
                            const t = this._interpolants,
                                e = this._propertyBindings;
                            switch (this.blendMode) {
                                case 2501:
                                    for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                                    break;
                                case 2500:
                                default:
                                    for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulate(r, o)
                            }
                        }
                    }
                    _updateWeight(t) {
                        let e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            const n = this._weightInterpolant;
                            if (null !== n) {
                                const r = n.evaluate(t)[0];
                                e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    }
                    _updateTimeScale(t) {
                        let e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            const n = this._timeScaleInterpolant;
                            if (null !== n) {
                                e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                            }
                        }
                        return this._effectiveTimeScale = e, e
                    }
                    _updateTime(t) {
                        const e = this._clip.duration,
                            n = this.loop;
                        let r = this.time + t,
                            i = this._loopCount;
                        const s = 2202 === n;
                        if (0 === t) return -1 === i ? r : s && 1 == (1 & i) ? e - r : r;
                        if (n === U) {
                            -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (r >= e) r = e;
                                else {
                                    if (!(r < 0)) {
                                        this.time = r;
                                        break t
                                    }
                                    r = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= e || r < 0) {
                                const n = Math.floor(r / e);
                                r -= e * n, i += Math.abs(n);
                                const o = this.repetitions - i;
                                if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === o) {
                                        const e = t < 0;
                                        this._setEndings(e, !e, s)
                                    } else this._setEndings(!1, !1, s);
                                    this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: n
                                    })
                                }
                            } else this.time = r;
                            if (s && 1 == (1 & i)) return e - r
                        }
                        return r
                    }
                    _setEndings(t, e, n) {
                        const r = this._interpolantSettings;
                        n ? (r.endingStart = j, r.endingEnd = j) : (r.endingStart = t ? this.zeroSlopeAtStart ? j : W : 2402, r.endingEnd = e ? this.zeroSlopeAtEnd ? j : W : 2402)
                    }
                    _scheduleFading(t, e, n) {
                        const r = this._mixer,
                            i = r.time;
                        let s = this._weightInterpolant;
                        null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
                        const o = s.parameterPositions,
                            a = s.sampleValues;
                        return o[0] = i, a[0] = e, o[1] = i + t, a[1] = n, this
                    }
                }
                class Hc extends $ {
                    constructor(t) {
                        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                    }
                    _bindAction(t, e) {
                        const n = t._localRoot || this._root,
                            r = t._clip.tracks,
                            i = r.length,
                            s = t._propertyBindings,
                            o = t._interpolants,
                            a = n.uuid,
                            c = this._bindingsByRootAndName;
                        let l = c[a];
                        void 0 === l && (l = {}, c[a] = l);
                        for (let t = 0; t !== i; ++t) {
                            const i = r[t],
                                c = i.name;
                            let u = l[c];
                            if (void 0 !== u) s[t] = u;
                            else {
                                if (u = s[t], void 0 !== u) {
                                    null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, c));
                                    continue
                                }
                                const r = e && e._propertyBindings[t].binding.parsedPath;
                                u = new Lc(kc.create(n, c, r), i.ValueTypeName, i.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, c), s[t] = u
                            }
                            o[t].resultBuffer = u.buffer
                        }
                    }
                    _activateAction(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                const e = (t._localRoot || this._root).uuid,
                                    n = t._clip.uuid,
                                    r = this._actionsByClip[n];
                                this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                            }
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    }
                    _deactivateAction(t) {
                        if (this._isActiveAction(t)) {
                            const e = t._propertyBindings;
                            for (let t = 0, n = e.length; t !== n; ++t) {
                                const n = e[t];
                                0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                            }
                            this._takeBackAction(t)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        const t = this;
                        this.stats = {
                            actions: {get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(t) {
                        const e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    }
                    _addInactiveAction(t, e, n) {
                        const r = this._actions,
                            i = this._actionsByClip;
                        let s = i[e];
                        if (void 0 === s) s = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, i[e] = s;
                        else {
                            const e = s.knownActions;
                            t._byClipCacheIndex = e.length, e.push(t)
                        }
                        t._cacheIndex = r.length, r.push(t), s.actionByRoot[n] = t
                    }
                    _removeInactiveAction(t) {
                        const e = this._actions,
                            n = e[e.length - 1],
                            r = t._cacheIndex;
                        n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                        const i = t._clip.uuid,
                            s = this._actionsByClip,
                            o = s[i],
                            a = o.knownActions,
                            c = a[a.length - 1],
                            l = t._byClipCacheIndex;
                        c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null;
                        delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[i], this._removeInactiveBindingsForAction(t)
                    }
                    _removeInactiveBindingsForAction(t) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.referenceCount && this._removeInactiveBinding(n)
                        }
                    }
                    _lendAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            r = this._nActiveActions++,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _takeBackAction(t) {
                        const e = this._actions,
                            n = t._cacheIndex,
                            r = --this._nActiveActions,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _addInactiveBinding(t, e, n) {
                        const r = this._bindingsByRootAndName,
                            i = this._bindings;
                        let s = r[e];
                        void 0 === s && (s = {}, r[e] = s), s[n] = t, t._cacheIndex = i.length, i.push(t)
                    }
                    _removeInactiveBinding(t) {
                        const e = this._bindings,
                            n = t.binding,
                            r = n.rootNode.uuid,
                            i = n.path,
                            s = this._bindingsByRootAndName,
                            o = s[r],
                            a = e[e.length - 1],
                            c = t._cacheIndex;
                        a._cacheIndex = c, e[c] = a, e.pop(), delete o[i], 0 === Object.keys(o).length && delete s[r]
                    }
                    _lendBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            r = this._nActiveBindings++,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _takeBackBinding(t) {
                        const e = this._bindings,
                            n = t._cacheIndex,
                            r = --this._nActiveBindings,
                            i = e[r];
                        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                    }
                    _lendControlInterpolant() {
                        const t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++;
                        let n = t[e];
                        return void 0 === n && (n = new Fa(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                    }
                    _takeBackControlInterpolant(t) {
                        const e = this._controlInterpolants,
                            n = t.__cacheIndex,
                            r = --this._nActiveControlInterpolants,
                            i = e[r];
                        t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
                    }
                    clipAction(t, e, n) {
                        const r = e || this._root,
                            i = r.uuid;
                        let s = "string" == typeof t ? Xa.findByName(r, t) : t;
                        const o = null !== s ? s.uuid : t,
                            a = this._actionsByClip[o];
                        let c = null;
                        if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== a) {
                            const t = a.actionByRoot[i];
                            if (void 0 !== t && t.blendMode === n) return t;
                            c = a.knownActions[0], null === s && (s = c._clip)
                        }
                        if (null === s) return null;
                        const l = new Uc(this, s, e, n);
                        return this._bindAction(l, c), this._addInactiveAction(l, o, i), l
                    }
                    existingAction(t, e) {
                        const n = e || this._root,
                            r = n.uuid,
                            i = "string" == typeof t ? Xa.findByName(n, t) : t,
                            s = i ? i.uuid : t,
                            o = this._actionsByClip[s];
                        return void 0 !== o && o.actionByRoot[r] || null
                    }
                    stopAllAction() {
                        const t = this._actions;
                        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                        return this
                    }
                    update(t) {
                        t *= this.timeScale;
                        const e = this._actions,
                            n = this._nActiveActions,
                            r = this.time += t,
                            i = Math.sign(t),
                            s = this._accuIndex ^= 1;
                        for (let o = 0; o !== n; ++o) {
                            e[o]._update(r, t, i, s)
                        }
                        const o = this._bindings,
                            a = this._nActiveBindings;
                        for (let t = 0; t !== a; ++t) o[t].apply(s);
                        return this
                    }
                    setTime(t) {
                        this.time = 0;
                        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                        return this.update(t)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(t) {
                        const e = this._actions,
                            n = t.uuid,
                            r = this._actionsByClip,
                            i = r[n];
                        if (void 0 !== i) {
                            const t = i.knownActions;
                            for (let n = 0, r = t.length; n !== r; ++n) {
                                const r = t[n];
                                this._deactivateAction(r);
                                const i = r._cacheIndex,
                                    s = e[e.length - 1];
                                r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, e[i] = s, e.pop(), this._removeInactiveBindingsForAction(r)
                            }
                            delete r[n]
                        }
                    }
                    uncacheRoot(t) {
                        const e = t.uuid,
                            n = this._actionsByClip;
                        for (const t in n) {
                            const r = n[t].actionByRoot[e];
                            void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                        }
                        const r = this._bindingsByRootAndName[e];
                        if (void 0 !== r)
                            for (const t in r) {
                                const e = r[t];
                                e.restoreOriginalState(), this._removeInactiveBinding(e)
                            }
                    }
                    uncacheAction(t, e) {
                        const n = this.existingAction(t, e);
                        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                }
                Hc.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
                class Gc {
                    constructor(t) {
                        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                    }
                    clone() {
                        return new Gc(void 0 === this.value.clone ? this.value : this.value.clone())
                    }
                }(class extends Ns {
                    constructor(t, e, n = 1) {
                        super(t, e), this.meshPerAttribute = n
                    }
                    copy(t) {
                        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                    clone(t) {
                        const e = super.clone(t);
                        return e.meshPerAttribute = this.meshPerAttribute, e
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                    }
                }).prototype.isInstancedInterleavedBuffer = !0;
                (class {
                    constructor(t, e, n, r, i) {
                        this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
                    }
                    set needsUpdate(t) {
                        !0 === t && this.version++
                    }
                    setBuffer(t) {
                        return this.buffer = t, this
                    }
                    setType(t, e) {
                        return this.type = t, this.elementSize = e, this
                    }
                    setItemSize(t) {
                        return this.itemSize = t, this
                    }
                    setCount(t) {
                        return this.count = t, this
                    }
                }).prototype.isGLBufferAttribute = !0;
                class Vc {
                    constructor(t, e, n = 0, r = 1 / 0) {
                        this.ray = new ne(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new fe, this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(t, e) {
                        this.ray.set(t, e)
                    }
                    setFromCamera(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                    }
                    intersectObject(t, e = !0, n = []) {
                        return jc(t, this, n, e), n.sort(Wc), n
                    }
                    intersectObjects(t, e = !0, n = []) {
                        for (let r = 0, i = t.length; r < i; r++) jc(t[r], this, n, e);
                        return n.sort(Wc), n
                    }
                }

                function Wc(t, e) {
                    return t.distance - e.distance
                }

                function jc(t, e, n, r) {
                    if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) {
                        const r = t.children;
                        for (let t = 0, i = r.length; t < i; t++) jc(r[t], e, n, !0)
                    }
                }
                class Zc {
                    constructor(t = 1, e = 0, n = 0) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    }
                    set(t, e, n) {
                        return this.radius = t, this.phi = e, this.theta = n, this
                    }
                    copy(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    }
                    makeSafe() {
                        const t = 1e-6;
                        return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
                    }
                    setFromVector3(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    }
                    setFromCartesianCoords(t, e, n) {
                        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(ot(e / this.radius, -1, 1))), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }
                const qc = new pt;
                class Xc {
                    constructor(t = new pt(1 / 0, 1 / 0), e = new pt(-1 / 0, -1 / 0)) {
                        this.min = t, this.max = e
                    }
                    set(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    }
                    setFromPoints(t) {
                        this.makeEmpty();
                        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                        return this
                    }
                    setFromCenterAndSize(t, e) {
                        const n = qc.copy(e).multiplyScalar(.5);
                        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                    copy(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    }
                    makeEmpty() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    }
                    isEmpty() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    }
                    getCenter(t) {
                        return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    }
                    getSize(t) {
                        return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    }
                    expandByPoint(t) {
                        return this.min.min(t), this.max.max(t), this
                    }
                    expandByVector(t) {
                        return this.min.sub(t), this.max.add(t), this
                    }
                    expandByScalar(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    }
                    containsPoint(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    }
                    containsBox(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    }
                    getParameter(t, e) {
                        return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    }
                    clampPoint(t, e) {
                        return e.copy(t).clamp(this.min, this.max)
                    }
                    distanceToPoint(t) {
                        return qc.copy(t).clamp(this.min, this.max).sub(t).length()
                    }
                    intersect(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    }
                    union(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    }
                    translate(t) {
                        return this.min.add(t), this.max.add(t), this
                    }
                    equals(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }
                Xc.prototype.isBox2 = !0;
                const Yc = new Et,
                    Jc = new Et;
                (class extends Le {
                    constructor(t) {
                        super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
                    }
                }).prototype.isImmediateRenderObject = !0;
                const Kc = new Et,
                    Qc = new re,
                    $c = new re;
                class tl extends To {
                    constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
                        n = new Xe(n), r = new Xe(r);
                        const i = e / 2,
                            s = t / e,
                            o = t / 2,
                            a = [],
                            c = [];
                        for (let t = 0, l = 0, u = -o; t <= e; t++, u += s) {
                            a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
                            const e = t === i ? n : r;
                            e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3
                        }
                        const l = new un;
                        l.setAttribute("position", new en(a, 3)), l.setAttribute("color", new en(c, 3));
                        super(l, new go({
                            vertexColors: !0,
                            toneMapped: !1
                        })), this.type = "GridHelper"
                    }
                }
                class el extends To {
                    constructor(t, e = 16776960) {
                        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                            r = new un;
                        r.setIndex(new Qe(n, 1)), r.setAttribute("position", new en([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new go({
                            color: e,
                            toneMapped: !1
                        })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(t) {
                        const e = this.box;
                        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
                    }
                }
                const nl = new Float32Array(1);
                new Int32Array(nl.buffer), Oo.create = function(t, e) {
                    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Oo.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
                }, ta.prototype.fromPoints = function(t) {
                    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }, tl.prototype.setColors = function() {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                }, class extends To {
                    constructor(t) {
                        const e = function t(e) {
                                const n = [];
                                e && e.isBone && n.push(e);
                                for (let r = 0; r < e.children.length; r++) n.push.apply(n, t(e.children[r]));
                                return n
                            }(t),
                            n = new un,
                            r = [],
                            i = [],
                            s = new Xe(0, 0, 1),
                            o = new Xe(0, 1, 0);
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            n.parent && n.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(o.r, o.g, o.b))
                        }
                        n.setAttribute("position", new en(r, 3)), n.setAttribute("color", new en(i, 3));
                        super(n, new go({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(t) {
                        const e = this.bones,
                            n = this.geometry,
                            r = n.getAttribute("position");
                        $c.copy(this.root.matrixWorld).invert();
                        for (let t = 0, n = 0; t < e.length; t++) {
                            const i = e[t];
                            i.parent && i.parent.isBone && (Qc.multiplyMatrices($c, i.matrixWorld), Kc.setFromMatrixPosition(Qc), r.setXYZ(n, Kc.x, Kc.y, Kc.z), Qc.multiplyMatrices($c, i.parent.matrixWorld), Kc.setFromMatrixPosition(Qc), r.setXYZ(n + 1, Kc.x, Kc.y, Kc.z), n += 2)
                        }
                        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                    }
                }.prototype.update = function() {
                    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
                }, Qa.prototype.extractUrlBase = function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), bc.extractUrlBase(t)
                }, Qa.Handlers = {
                    add: function() {
                        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                    },
                    get: function() {
                        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                    }
                }, Xc.prototype.center = function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, Xc.prototype.empty = function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, Xc.prototype.isIntersectionBox = function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                }, Xc.prototype.size = function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }, Rt.prototype.center = function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, Rt.prototype.empty = function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, Rt.prototype.isIntersectionBox = function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                }, Rt.prototype.isIntersectionSphere = function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }, Rt.prototype.size = function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }, Xt.prototype.empty = function() {
                    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                }, Zn.prototype.setFromMatrix = function(t) {
                    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
                }, class {
                    constructor(t = new Et, e = new Et) {
                        this.start = t, this.end = e
                    }
                    set(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    }
                    copy(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    }
                    getCenter(t) {
                        return t.addVectors(this.start, this.end).multiplyScalar(.5)
                    }
                    delta(t) {
                        return t.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(t, e) {
                        return this.delta(e).multiplyScalar(t).add(this.start)
                    }
                    closestPointToPointParameter(t, e) {
                        Yc.subVectors(t, this.start), Jc.subVectors(this.end, this.start);
                        const n = Jc.dot(Jc);
                        let r = Jc.dot(Yc) / n;
                        return e && (r = ot(r, 0, 1)), r
                    }
                    closestPointToPoint(t, e, n) {
                        const r = this.closestPointToPointParameter(t, e);
                        return this.delta(n).multiplyScalar(r).add(this.start)
                    }
                    applyMatrix4(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    }
                    equals(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                    clone() {
                        return (new this.constructor).copy(this)
                    }
                }.prototype.center = function(t) {
                    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                }, ft.prototype.flattenToArrayOffset = function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                }, ft.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                }, ft.prototype.multiplyVector3Array = function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                }, ft.prototype.applyToBufferAttribute = function(t) {
                    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                }, ft.prototype.applyToVector3Array = function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }, ft.prototype.getInverse = function(t) {
                    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
                }, re.prototype.extractPosition = function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                }, re.prototype.flattenToArrayOffset = function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                }, re.prototype.getPosition = function() {
                    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Et).setFromMatrixColumn(this, 3)
                }, re.prototype.setRotationFromQuaternion = function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                }, re.prototype.multiplyToArray = function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                }, re.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, re.prototype.multiplyVector4 = function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, re.prototype.multiplyVector3Array = function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                }, re.prototype.rotateAxis = function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                }, re.prototype.crossVector = function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, re.prototype.translate = function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                }, re.prototype.rotateX = function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                }, re.prototype.rotateY = function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                }, re.prototype.rotateZ = function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                }, re.prototype.rotateByAxis = function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                }, re.prototype.applyToBufferAttribute = function(t) {
                    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                }, re.prototype.applyToVector3Array = function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                }, re.prototype.makeFrustum = function(t, e, n, r, i, s) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, s)
                }, re.prototype.getInverse = function(t) {
                    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
                }, Vn.prototype.isIntersectionLine = function(t) {
                    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
                }, Tt.prototype.multiplyVector3 = function(t) {
                    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
                }, Tt.prototype.inverse = function() {
                    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
                }, ne.prototype.isIntersectionBox = function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                }, ne.prototype.isIntersectionPlane = function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                }, ne.prototype.isIntersectionSphere = function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }, ke.prototype.area = function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                }, ke.prototype.barycoordFromPoint = function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                }, ke.prototype.midpoint = function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                }, ke.prototypenormal = function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                }, ke.prototype.plane = function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }, ke.barycoordFromPoint = function(t, e, n, r, i) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ke.getBarycoord(t, e, n, r, i)
                }, ke.normal = function(t, e, n, r) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ke.getNormal(t, e, n, r)
                }, ea.prototype.extractAllPoints = function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                }, ea.prototype.extrude = function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pa(this, t)
                }, ea.prototype.makeGeometry = function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ia(this, t)
                }, pt.prototype.fromAttribute = function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                }, pt.prototype.distanceToManhattan = function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                }, pt.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, Et.prototype.setEulerFromRotationMatrix = function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                }, Et.prototype.setEulerFromQuaternion = function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                }, Et.prototype.getPositionFromMatrix = function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                }, Et.prototype.getScaleFromMatrix = function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                }, Et.prototype.getColumnFromMatrix = function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                }, Et.prototype.applyProjection = function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                }, Et.prototype.fromAttribute = function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                }, Et.prototype.distanceToManhattan = function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                }, Et.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, wt.prototype.fromAttribute = function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                }, wt.prototype.lengthManhattan = function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }, Le.prototype.getChildByName = function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                }, Le.prototype.renderDepth = function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                }, Le.prototype.translate = function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                }, Le.prototype.getWorldRotation = function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }, Le.prototype.applyMatrix = function(t) {
                    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }, Object.defineProperties(Le.prototype, {
                    eulerOrder: {get: function() {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                        },
                        set: function(t) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                        }
                    },
                    useQuaternion: {get: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }), Ln.prototype.setDrawMode = function() {
                    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                }, Object.defineProperties(Ln.prototype, {
                    drawMode: {get: function() {
                            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                        },
                        set: function() {
                            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                        }
                    }
                }), io.prototype.initBones = function() {
                    console.error("THREE.SkinnedMesh: initBones() has been removed.")
                }, Bn.prototype.setLens = function(t, e) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
                }, Object.defineProperties(ic.prototype, {
                    onlyShadow: {set: function() {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                        }
                    },
                    shadowCameraLeft: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                        }
                    },
                    shadowCameraRight: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                        }
                    },
                    shadowCameraTop: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                        }
                    },
                    shadowCameraBottom: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                        }
                    },
                    shadowCameraNear: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                        }
                    },
                    shadowCameraFar: {set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                        }
                    },
                    shadowCameraVisible: {set: function() {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {set: function(t) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                        }
                    },
                    shadowDarkness: {set: function() {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {set: function(t) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                        }
                    },
                    shadowMapHeight: {set: function(t) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                        }
                    }
                }), Object.defineProperties(Qe.prototype, {
                    length: {get: function() {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                        }
                    },
                    dynamic: {get: function() {
                            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Q
                        },
                        set: function() {
                            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Q)
                        }
                    }
                }), Qe.prototype.setDynamic = function(t) {
                    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Q : K), this
                }, Qe.prototype.copyIndicesArray = function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }, Qe.prototype.setArray = function() {
                    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }, un.prototype.addIndex = function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                }, un.prototype.addAttribute = function(t, e) {
                    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Qe(arguments[1], arguments[2])))
                }, un.prototype.addDrawCall = function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                }, un.prototype.clearDrawCalls = function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                }, un.prototype.computeOffsets = function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }, un.prototype.removeAttribute = function(t) {
                    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
                }, un.prototype.applyMatrix = function(t) {
                    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
                }, Object.defineProperties(un.prototype, {
                    drawcalls: {get: function() {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                        }
                    },
                    offsets: {get: function() {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                        }
                    }
                }), Ns.prototype.setDynamic = function(t) {
                    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Q : K), this
                }, Ns.prototype.setArray = function() {
                    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
                }, Pa.prototype.getArrays = function() {
                    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
                }, Pa.prototype.addShapeList = function() {
                    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
                }, Pa.prototype.addShape = function() {
                    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
                }, Os.prototype.dispose = function() {
                    console.error("THREE.Scene: .dispose() has been removed.")
                }, Gc.prototype.onUpdate = function() {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }, Object.defineProperties(He.prototype, {
                    wrapAround: {get: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .wrapAround has been removed.")
                        }
                    },
                    overdraw: {get: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        },
                        set: function() {
                            console.warn("THREE.Material: .overdraw has been removed.")
                        }
                    },
                    wrapRGB: {get: function() {
                            return console.warn("THREE.Material: .wrapRGB has been removed."), new Xe
                        }
                    },
                    shading: {get: function() {
                            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                        },
                        set: function(t) {
                            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                        }
                    },
                    stencilMask: {get: function() {
                            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                        },
                        set: function(t) {
                            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                        }
                    },
                    vertexTangents: {get: function() {
                            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                        },
                        set: function() {
                            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                        }
                    }
                }), Object.defineProperties(On.prototype, {
                    derivatives: {get: function() {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                        },
                        set: function(t) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                        }
                    }
                }), Ps.prototype.clearTarget = function(t, e, n, r) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
                }, Ps.prototype.animate = function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                }, Ps.prototype.getCurrentRenderTarget = function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                }, Ps.prototype.getMaxAnisotropy = function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                }, Ps.prototype.getPrecision = function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                }, Ps.prototype.resetGLState = function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                }, Ps.prototype.supportsFloatTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                }, Ps.prototype.supportsHalfFloatTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                }, Ps.prototype.supportsStandardDerivatives = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                }, Ps.prototype.supportsCompressedTextureS3TC = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                }, Ps.prototype.supportsCompressedTexturePVRTC = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                }, Ps.prototype.supportsBlendMinMax = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                }, Ps.prototype.supportsVertexTextures = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                }, Ps.prototype.supportsInstancedArrays = function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                }, Ps.prototype.enableScissorTest = function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                }, Ps.prototype.initMaterial = function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                }, Ps.prototype.addPrePlugin = function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                }, Ps.prototype.addPostPlugin = function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                }, Ps.prototype.updateShadowMap = function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                }, Ps.prototype.setFaceCulling = function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }, Ps.prototype.allocTextureUnit = function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                }, Ps.prototype.setTexture = function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                }, Ps.prototype.setTexture2D = function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                }, Ps.prototype.setTextureCube = function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                }, Ps.prototype.getActiveMipMapLevel = function() {
                    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
                }, Object.defineProperties(Ps.prototype, {
                    shadowMapEnabled: {get: function() {
                            return this.shadowMap.enabled
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                        }
                    },
                    shadowMapType: {get: function() {
                            return this.shadowMap.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                        }
                    },
                    shadowMapCullFace: {get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    context: {get: function() {
                            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                        }
                    },
                    vr: {get: function() {
                            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                        }
                    },
                    gammaInput: {get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                        }
                    },
                    gammaOutput: {get: function() {
                            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Y : X
                        }
                    },
                    toneMappingWhitePoint: {get: function() {
                            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                        }
                    }
                }), Object.defineProperties(_s.prototype, {
                    cullFace: {get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderReverseSided: {get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                        }
                    },
                    renderSingleSided: {get: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        },
                        set: function() {
                            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                        }
                    }
                }), Object.defineProperties(Mt.prototype, {
                    wrapS: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                        }
                    },
                    wrapT: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                        }
                    },
                    magFilter: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                        }
                    },
                    minFilter: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                        }
                    },
                    anisotropy: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                        }
                    },
                    offset: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                        }
                    },
                    repeat: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                        }
                    },
                    format: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                        }
                    },
                    type: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                        }
                    },
                    generateMipmaps: {get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                        }
                    }
                }), class extends Le {
                    constructor(t) {
                        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                    }
                    setMediaElementSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                    }
                    setMediaStreamSource(t) {
                        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                    }
                    setBuffer(t) {
                        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                    }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else this.source.connect(this.getOutput());
                        return this._connected = !0, this
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else this.source.disconnect(this.getOutput());
                        return this._connected = !1, this
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(t) {
                        return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                    }
                    setDetune(t) {
                        if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(t) {
                        return this.setFilters(t ? [t] : [])
                    }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1
                    }
                    getLoop() {
                        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                    }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    }
                    setLoopStart(t) {
                        return this.loopStart = t, this
                    }
                    setLoopEnd(t) {
                        return this.loopEnd = t, this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                    }
                }.prototype.load = function(t) {
                    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                    const e = this;
                    return (new Tc).load(t, (function(t) {
                        e.setBuffer(t)
                    })), this
                }, class {
                    constructor(t, e = 2048) {
                        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        return this.analyser.getByteFrequencyData(this.data), this.data
                    }
                    getAverageFrequency() {
                        let t = 0;
                        const e = this.getFrequencyData();
                        for (let n = 0; n < e.length; n++) t += e[n];
                        return t / e.length
                    }
                }.prototype.getData = function() {
                    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
                }, zn.prototype.updateCubeMap = function(t, e) {
                    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
                }, zn.prototype.clear = function(t, e, n, r) {
                    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
                }, yt.crossOrigin = void 0, yt.loadTexture = function(t, e, n, r) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    const i = new rc;
                    i.setCrossOrigin(this.crossOrigin);
                    const s = i.load(t, n, void 0, r);
                    return e && (s.mapping = e), s
                }, yt.loadTextureCube = function(t, e, n, r) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    const i = new nc;
                    i.setCrossOrigin(this.crossOrigin);
                    const s = i.load(t, n, void 0, r);
                    return e && (s.mapping = e), s
                }, yt.loadCompressedTexture = function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                }, yt.loadCompressedTextureCube = function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                    detail: {
                        revision: "133"
                    }
                })), void 0 !== o && (o.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : o.__THREE__ = "133")
            },
            6646: function(t, e, n) {
                "use strict";
                n.d(e, {
                    _: function() {
                        return s
                    }
                });
                var r = n(1646);
                const i = new WeakMap;
                class s extends r.aNw {
                    constructor(t) {
                        super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                            position: "POSITION",
                            normal: "NORMAL",
                            color: "COLOR",
                            uv: "TEX_COORD"
                        }, this.defaultAttributeTypes = {
                            position: "Float32Array",
                            normal: "Float32Array",
                            color: "Float32Array",
                            uv: "Float32Array"
                        }
                    }
                    setDecoderPath(t) {
                        return this.decoderPath = t, this
                    }
                    setDecoderConfig(t) {
                        return this.decoderConfig = t, this
                    }
                    setWorkerLimit(t) {
                        return this.workerLimit = t, this
                    }
                    load(t, e, n, i) {
                        const s = new r.hH6(this.manager);
                        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, t => {
                            const n = {
                                attributeIDs: this.defaultAttributeIDs,
                                attributeTypes: this.defaultAttributeTypes,
                                useUniqueIDs: !1
                            };
                            this.decodeGeometry(t, n).then(e).catch(i)
                        }, n, i)
                    }
                    decodeDracoFile(t, e, n, r) {
                        const i = {
                            attributeIDs: n || this.defaultAttributeIDs,
                            attributeTypes: r || this.defaultAttributeTypes,
                            useUniqueIDs: !!n
                        };
                        this.decodeGeometry(t, i).then(e)
                    }
                    decodeGeometry(t, e) {
                        for (const t in e.attributeTypes) {
                            const n = e.attributeTypes[t];
                            void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name)
                        }
                        const n = JSON.stringify(e);
                        if (i.has(t)) {
                            const e = i.get(t);
                            if (e.key === n) return e.promise;
                            if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                        }
                        let r;
                        const s = this.workerNextTaskID++,
                            o = t.byteLength,
                            a = this._getWorker(s, o).then(n => (r = n, new Promise((n, i) => {
                                r._callbacks[s] = {
                                    resolve: n,
                                    reject: i
                                }, r.postMessage({
                                    type: "decode",
                                    id: s,
                                    taskConfig: e,
                                    buffer: t
                                }, [t])
                            }))).then(t => this._createGeometry(t.geometry));
                        return a.catch(() => !0).then(() => {
                            r && s && this._releaseTask(r, s)
                        }), i.set(t, {
                            key: n,
                            promise: a
                        }), a
                    }
                    _createGeometry(t) {
                        const e = new r.u9r;
                        t.index && e.setIndex(new r.TlE(t.index.array, 1));
                        for (let n = 0; n < t.attributes.length; n++) {
                            const i = t.attributes[n],
                                s = i.name,
                                o = i.array,
                                a = i.itemSize;
                            e.setAttribute(s, new r.TlE(o, a))
                        }
                        return e
                    }
                    _loadLibrary(t, e) {
                        const n = new r.hH6(this.manager);
                        return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise((e, r) => {
                            n.load(t, e, void 0, r)
                        })
                    }
                    preload() {
                        return this._initDecoder(), this
                    }
                    _initDecoder() {
                        if (this.decoderPending) return this.decoderPending;
                        const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                            e = [];
                        return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then(e => {
                            const n = e[0];
                            t || (this.decoderConfig.wasmBinary = e[1]);
                            const i = o.toString(),
                                s = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                            this.workerSourceURL = r.lh0.createObjectURL(new r.yFI([s]))
                        }), this.decoderPending
                    }
                    _getWorker(t, e) {
                        return this._initDecoder().then(() => {
                            if (this.workerPool.length < this.workerLimit) {
                                const t = new Worker(this.workerSourceURL);
                                t._callbacks = {}, t._taskCosts = {}, t._taskLoad = 0, t.postMessage({
                                    type: "init",
                                    decoderConfig: this.decoderConfig
                                }), t.onmessage = function(e) {
                                    const n = e.data;
                                    switch (n.type) {
                                        case "decode":
                                            t._callbacks[n.id].resolve(n);
                                            break;
                                        case "error":
                                            t._callbacks[n.id].reject(n);
                                            break;
                                        default:
                                            console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                                    }
                                }, this.workerPool.push(t)
                            } else this.workerPool.sort((function(t, e) {
                                return t._taskLoad > e._taskLoad ? -1 : 1
                            }));
                            const n = this.workerPool[this.workerPool.length - 1];
                            return n._taskCosts[t] = e, n._taskLoad += e, n
                        })
                    }
                    _releaseTask(t, e) {
                        t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e]
                    }
                    debug() {
                        console.log("Task load: ", this.workerPool.map(t => t._taskLoad))
                    }
                    dispose() {
                        for (let t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate();
                        return this.workerPool.length = 0, this
                    }
                }

                function o() {
                    let t, e;

                    function n(t, e, n, i) {
                        const s = i.attributeIDs,
                            o = i.attributeTypes;
                        let a, c;
                        const l = e.GetEncodedGeometryType(n);
                        if (l === t.TRIANGULAR_MESH) a = new t.Mesh, c = e.DecodeBufferToMesh(n, a);
                        else {
                            if (l !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                            a = new t.PointCloud, c = e.DecodeBufferToPointCloud(n, a)
                        }
                        if (!c.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + c.error_msg());
                        const u = {
                            index: null,
                            attributes: []
                        };
                        for (const n in s) {
                            const c = self[o[n]];
                            let l, h;
                            if (i.useUniqueIDs) h = s[n], l = e.GetAttributeByUniqueId(a, h);
                            else {
                                if (h = e.GetAttributeId(a, t[s[n]]), -1 === h) continue;
                                l = e.GetAttribute(a, h)
                            }
                            u.attributes.push(r(t, e, a, n, c, l))
                        }
                        return l === t.TRIANGULAR_MESH && (u.index = function(t, e, n) {
                            const r = 3 * n.num_faces(),
                                i = 4 * r,
                                s = t._malloc(i);
                            e.GetTrianglesUInt32Array(n, i, s);
                            const o = new Uint32Array(t.HEAPF32.buffer, s, r).slice();
                            return t._free(s), {
                                array: o,
                                itemSize: 1
                            }
                        }(t, e, a)), t.destroy(a), u
                    }

                    function r(t, e, n, r, i, s) {
                        const o = s.num_components(),
                            a = n.num_points() * o,
                            c = a * i.BYTES_PER_ELEMENT,
                            l = function(t, e) {
                                switch (e) {
                                    case Float32Array:
                                        return t.DT_FLOAT32;
                                    case Int8Array:
                                        return t.DT_INT8;
                                    case Int16Array:
                                        return t.DT_INT16;
                                    case Int32Array:
                                        return t.DT_INT32;
                                    case Uint8Array:
                                        return t.DT_UINT8;
                                    case Uint16Array:
                                        return t.DT_UINT16;
                                    case Uint32Array:
                                        return t.DT_UINT32
                                }
                            }(t, i),
                            u = t._malloc(c);
                        e.GetAttributeDataArrayForAllPoints(n, s, l, c, u);
                        const h = new i(t.HEAPF32.buffer, u, a).slice();
                        return t._free(u), {
                            name: r,
                            array: h,
                            itemSize: o
                        }
                    }
                    onmessage = function(r) {
                        const i = r.data;
                        switch (i.type) {
                            case "init":
                                t = i.decoderConfig, e = new Promise((function(e) {
                                    t.onModuleLoaded = function(t) {
                                        e({
                                            draco: t
                                        })
                                    }, DracoDecoderModule(t)
                                }));
                                break;
                            case "decode":
                                const r = i.buffer,
                                    s = i.taskConfig;
                                e.then(t => {
                                    const e = t.draco,
                                        o = new e.Decoder,
                                        a = new e.DecoderBuffer;
                                    a.Init(new Int8Array(r), r.byteLength);
                                    try {
                                        const t = n(e, o, a, s),
                                            r = t.attributes.map(t => t.array.buffer);
                                        t.index && r.push(t.index.array.buffer), self.postMessage({
                                            type: "decode",
                                            id: i.id,
                                            geometry: t
                                        }, r)
                                    } catch (t) {
                                        console.error(t), self.postMessage({
                                            type: "error",
                                            id: i.id,
                                            error: t.message
                                        })
                                    } finally {
                                        e.destroy(a), e.destroy(o)
                                    }
                                })
                        }
                    }
                }
            },
            6702: function(t, e, n) {
                "use strict";
                n.d(e, {
                    E: function() {
                        return s
                    }
                });
                var r = n(1646),
                    i = n(2180).navigator;
                class s extends r.aNw {
                    constructor(t) {
                        super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) {
                            return new u(t)
                        })), this.register((function(t) {
                            return new m(t)
                        })), this.register((function(t) {
                            return new g(t)
                        })), this.register((function(t) {
                            return new h(t)
                        })), this.register((function(t) {
                            return new d(t)
                        })), this.register((function(t) {
                            return new p(t)
                        })), this.register((function(t) {
                            return new f(t)
                        })), this.register((function(t) {
                            return new c(t)
                        })), this.register((function(t) {
                            return new v(t)
                        }))
                    }
                    load(t, e, n, i) {
                        const s = this;
                        let o;
                        o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : r.Zp0.extractUrlBase(t), this.manager.itemStart(t);
                        const a = function(e) {
                                i ? i(e) : console.error(e), s.manager.itemError(t), s.manager.itemEnd(t)
                            },
                            c = new r.hH6(this.manager);
                        c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(t, (function(n) {
                            try {
                                s.parse(n, o, (function(n) {
                                    e(n), s.manager.itemEnd(t)
                                }), a)
                            } catch (t) {
                                a(t)
                            }
                        }), n, a)
                    }
                    setDRACOLoader(t) {
                        return this.dracoLoader = t, this
                    }
                    setDDSLoader() {
                        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                    }
                    setKTX2Loader(t) {
                        return this.ktx2Loader = t, this
                    }
                    setMeshoptDecoder(t) {
                        return this.meshoptDecoder = t, this
                    }
                    register(t) {
                        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
                    }
                    unregister(t) {
                        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
                    }
                    parse(t, e, n, i) {
                        let s;
                        const o = {},
                            c = {};
                        if ("string" == typeof t) s = t;
                        else {
                            if (r.Zp0.decodeText(new Uint8Array(t, 0, 4)) === y) {
                                try {
                                    o[a.KHR_BINARY_GLTF] = new b(t)
                                } catch (t) {
                                    return void(i && i(t))
                                }
                                s = o[a.KHR_BINARY_GLTF].content
                            } else s = r.Zp0.decodeText(new Uint8Array(t))
                        }
                        const u = JSON.parse(s);
                        if (void 0 === u.asset || u.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                        const h = new et(u, {
                            path: e || this.resourcePath || "",
                            crossOrigin: this.crossOrigin,
                            requestHeader: this.requestHeader,
                            manager: this.manager,
                            ktx2Loader: this.ktx2Loader,
                            meshoptDecoder: this.meshoptDecoder
                        });
                        h.fileLoader.setRequestHeader(this.requestHeader);
                        for (let t = 0; t < this.pluginCallbacks.length; t++) {
                            const e = this.pluginCallbacks[t](h);
                            c[e.name] = e, o[e.name] = !0
                        }
                        if (u.extensionsUsed)
                            for (let t = 0; t < u.extensionsUsed.length; ++t) {
                                const e = u.extensionsUsed[t],
                                    n = u.extensionsRequired || [];
                                switch (e) {
                                    case a.KHR_MATERIALS_UNLIT:
                                        o[e] = new l;
                                        break;
                                    case a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                        o[e] = new T;
                                        break;
                                    case a.KHR_DRACO_MESH_COMPRESSION:
                                        o[e] = new w(u, this.dracoLoader);
                                        break;
                                    case a.KHR_TEXTURE_TRANSFORM:
                                        o[e] = new M;
                                        break;
                                    case a.KHR_MESH_QUANTIZATION:
                                        o[e] = new E;
                                        break;
                                    default:
                                        n.indexOf(e) >= 0 && void 0 === c[e] && console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".')
                                }
                            }
                        h.setExtensions(o), h.setPlugins(c), h.parse(n, i)
                    }
                }

                function o() {
                    let t = {};
                    return {get: function(e) {
                            return t[e]
                        },
                        add: function(e, n) {
                            t[e] = n
                        },
                        remove: function(e) {
                            delete t[e]
                        },
                        removeAll: function() {
                            t = {}
                        }
                    }
                }
                const a = {
                    KHR_BINARY_GLTF: "KHR_binary_glTF",
                    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                    KHR_MATERIALS_IOR: "KHR_materials_ior",
                    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                    EXT_TEXTURE_WEBP: "EXT_texture_webp",
                    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
                };
                class c {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_LIGHTS_PUNCTUAL, this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }
                    _markDefs() {
                        const t = this.parser,
                            e = this.parser.json.nodes || [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n];
                            r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light)
                        }
                    }
                    _loadLight(t) {
                        const e = this.parser,
                            n = "light:" + t;
                        let i = e.cache.get(n);
                        if (i) return i;
                        const s = e.json,
                            o = ((s.extensions && s.extensions[this.name] || {}).lights || [])[t];
                        let a;
                        const c = new r.Ilk(16777215);
                        void 0 !== o.color && c.fromArray(o.color);
                        const l = void 0 !== o.range ? o.range : 0;
                        switch (o.type) {
                            case "directional":
                                a = new r.Ox3(c), a.target.position.set(0, 0, -1), a.add(a.target);
                                break;
                            case "point":
                                a = new r.cek(c), a.distance = l;
                                break;
                            case "spot":
                                a = new r.PMe(c), a.distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, a.angle = o.spot.outerConeAngle, a.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target);
                                break;
                            default:
                                throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                        }
                        return a.position.set(0, 0, 0), a.decay = 2, void 0 !== o.intensity && (a.intensity = o.intensity), a.name = e.createUniqueName(o.name || "light_" + t), i = Promise.resolve(a), e.cache.add(n, i), i
                    }
                    createNodeAttachment(t) {
                        const e = this,
                            n = this.parser,
                            r = n.json.nodes[t],
                            i = (r.extensions && r.extensions[this.name] || {}).light;
                        return void 0 === i ? null : this._loadLight(i).then((function(t) {
                            return n._getNodeRef(e.cache, i, t)
                        }))
                    }
                }
                class l {
                    constructor() {
                        this.name = a.KHR_MATERIALS_UNLIT
                    }
                    getMaterialType() {
                        return r.vBJ
                    }
                    extendParams(t, e, n) {
                        const i = [];
                        t.color = new r.Ilk(1, 1, 1), t.opacity = 1;
                        const s = e.pbrMetallicRoughness;
                        if (s) {
                            if (Array.isArray(s.baseColorFactor)) {
                                const e = s.baseColorFactor;
                                t.color.fromArray(e), t.opacity = e[3]
                            }
                            void 0 !== s.baseColorTexture && i.push(n.assignTexture(t, "map", s.baseColorTexture))
                        }
                        return Promise.all(i)
                    }
                }
                class u {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_MATERIALS_CLEARCOAT
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? r.EJi : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const s = [],
                            o = i.extensions[this.name];
                        if (void 0 !== o.clearcoatFactor && (e.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && s.push(n.assignTexture(e, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (e.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && s.push(n.assignTexture(e, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (s.push(n.assignTexture(e, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                            const t = o.clearcoatNormalTexture.scale;
                            e.clearcoatNormalScale = new r.FM8(t, t)
                        }
                        return Promise.all(s)
                    }
                }
                class h {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_MATERIALS_TRANSMISSION
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? r.EJi : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            r = n.json.materials[t];
                        if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                        const i = [],
                            s = r.extensions[this.name];
                        return void 0 !== s.transmissionFactor && (e.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && i.push(n.assignTexture(e, "transmissionMap", s.transmissionTexture)), Promise.all(i)
                    }
                }
                class d {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_MATERIALS_VOLUME
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? r.EJi : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const s = [],
                            o = i.extensions[this.name];
                        e.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && s.push(n.assignTexture(e, "thicknessMap", o.thicknessTexture)), e.attenuationDistance = o.attenuationDistance || 0;
                        const a = o.attenuationColor || [1, 1, 1];
                        return e.attenuationTint = new r.Ilk(a[0], a[1], a[2]), Promise.all(s)
                    }
                }
                class p {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_MATERIALS_IOR
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? r.EJi : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser.json.materials[t];
                        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                        const r = n.extensions[this.name];
                        return e.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
                    }
                }
                class f {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_MATERIALS_SPECULAR
                    }
                    getMaterialType(t) {
                        const e = this.parser.json.materials[t];
                        return e.extensions && e.extensions[this.name] ? r.EJi : null
                    }
                    extendMaterialParams(t, e) {
                        const n = this.parser,
                            i = n.json.materials[t];
                        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                        const s = [],
                            o = i.extensions[this.name];
                        e.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && s.push(n.assignTexture(e, "specularIntensityMap", o.specularTexture));
                        const a = o.specularColorFactor || [1, 1, 1];
                        return e.specularTint = new r.Ilk(a[0], a[1], a[2]), void 0 !== o.specularColorTexture && s.push(n.assignTexture(e, "specularTintMap", o.specularColorTexture).then((function(t) {
                            t.encoding = r.knz
                        }))), Promise.all(s)
                    }
                }
                class m {
                    constructor(t) {
                        this.parser = t, this.name = a.KHR_TEXTURE_BASISU
                    }
                    loadTexture(t) {
                        const e = this.parser,
                            n = e.json,
                            r = n.textures[t];
                        if (!r.extensions || !r.extensions[this.name]) return null;
                        const i = r.extensions[this.name],
                            s = n.images[i.source],
                            o = e.options.ktx2Loader;
                        if (!o) {
                            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                            return null
                        }
                        return e.loadTextureImage(t, s, o)
                    }
                }
                class g {
                    constructor(t) {
                        this.parser = t, this.name = a.EXT_TEXTURE_WEBP, this.isSupported = null
                    }
                    loadTexture(t) {
                        const e = this.name,
                            n = this.parser,
                            r = n.json,
                            i = r.textures[t];
                        if (!i.extensions || !i.extensions[e]) return null;
                        const s = i.extensions[e],
                            o = r.images[s.source];
                        let a = n.textureLoader;
                        if (o.uri) {
                            const t = n.options.manager.getHandler(o.uri);
                            null !== t && (a = t)
                        }
                        return this.detectSupport().then((function(i) {
                            if (i) return n.loadTextureImage(t, o, a);
                            if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                            return n.loadTexture(t)
                        }))
                    }
                    detectSupport() {
                        return this.isSupported || (this.isSupported = new Promise((function(t) {
                            const e = new Image;
                            e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
                                t(1 === e.height)
                            }
                        }))), this.isSupported
                    }
                }
                class v {
                    constructor(t) {
                        this.name = a.EXT_MESHOPT_COMPRESSION, this.parser = t
                    }
                    loadBufferView(t) {
                        const e = this.parser.json,
                            n = e.bufferViews[t];
                        if (n.extensions && n.extensions[this.name]) {
                            const t = n.extensions[this.name],
                                r = this.parser.getDependency("buffer", t.buffer),
                                i = this.parser.options.meshoptDecoder;
                            if (!i || !i.supported) {
                                if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                return null
                            }
                            return Promise.all([r, i.ready]).then((function(e) {
                                const n = t.byteOffset || 0,
                                    r = t.byteLength || 0,
                                    s = t.count,
                                    o = t.byteStride,
                                    a = new ArrayBuffer(s * o),
                                    c = new Uint8Array(e[0], n, r);
                                return i.decodeGltfBuffer(new Uint8Array(a), s, o, c, t.mode, t.filter), a
                            }))
                        }
                        return null
                    }
                }
                const y = "glTF",
                    x = 1313821514,
                    _ = 5130562;
                class b {
                    constructor(t) {
                        this.name = a.KHR_BINARY_GLTF, this.content = null, this.body = null;
                        const e = new DataView(t, 0, 12);
                        if (this.header = {
                                magic: r.Zp0.decodeText(new Uint8Array(t.slice(0, 4))),
                                version: e.getUint32(4, !0),
                                length: e.getUint32(8, !0)
                            }, this.header.magic !== y) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                        const n = this.header.length - 12,
                            i = new DataView(t, 12);
                        let s = 0;
                        for (; s < n;) {
                            const e = i.getUint32(s, !0);
                            s += 4;
                            const n = i.getUint32(s, !0);
                            if (s += 4, n === x) {
                                const n = new Uint8Array(t, 12 + s, e);
                                this.content = r.Zp0.decodeText(n)
                            } else if (n === _) {
                                const n = 12 + s;
                                this.body = t.slice(n, n + e)
                            }
                            s += e
                        }
                        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                    }
                }
                class w {
                    constructor(t, e) {
                        if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = a.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
                    }
                    decodePrimitive(t, e) {
                        const n = this.json,
                            r = this.dracoLoader,
                            i = t.extensions[this.name].bufferView,
                            s = t.extensions[this.name].attributes,
                            o = {},
                            a = {},
                            c = {};
                        for (const t in s) {
                            const e = H[t] || t.toLowerCase();
                            o[e] = s[t]
                        }
                        for (const e in t.attributes) {
                            const r = H[e] || e.toLowerCase();
                            if (void 0 !== s[e]) {
                                const i = n.accessors[t.attributes[e]],
                                    s = z[i.componentType];
                                c[r] = s, a[r] = !0 === i.normalized
                            }
                        }
                        return e.getDependency("bufferView", i).then((function(t) {
                            return new Promise((function(e) {
                                r.decodeDracoFile(t, (function(t) {
                                    for (const e in t.attributes) {
                                        const n = t.attributes[e],
                                            r = a[e];
                                        void 0 !== r && (n.normalized = r)
                                    }
                                    e(t)
                                }), o, c)
                            }))
                        }))
                    }
                }
                class M {
                    constructor() {
                        this.name = a.KHR_TEXTURE_TRANSFORM
                    }
                    extendTexture(t, e) {
                        return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
                    }
                }
                class S extends r.Wid {
                    constructor(t) {
                        super(), this.isGLTFSpecularGlossinessMaterial = !0;
                        const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                            n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                            i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                            s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                            o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                            a = {
                                specular: {
                                    value: (new r.Ilk).setHex(16777215)
                                },
                                glossiness: {
                                    value: 1
                                },
                                specularMap: {
                                    value: null
                                },
                                glossinessMap: {
                                    value: null
                                }
                            };
                        this._extraUniforms = a, this.onBeforeCompile = function(t) {
                            for (const e in a) t.uniforms[e] = a[e];
                            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", o)
                        }, Object.defineProperties(this, {
                            specular: {get: function() {
                                    return a.specular.value
                                },
                                set: function(t) {
                                    a.specular.value = t
                                }
                            },
                            specularMap: {get: function() {
                                    return a.specularMap.value
                                },
                                set: function(t) {
                                    a.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                                }
                            },
                            glossiness: {get: function() {
                                    return a.glossiness.value
                                },
                                set: function(t) {
                                    a.glossiness.value = t
                                }
                            },
                            glossinessMap: {get: function() {
                                    return a.glossinessMap.value
                                },
                                set: function(t) {
                                    a.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                                }
                            }
                        }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
                    }
                    copy(t) {
                        return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                    }
                }
                class T {
                    constructor() {
                        this.name = a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
                    }
                    getMaterialType() {
                        return S
                    }
                    extendParams(t, e, n) {
                        const i = e.extensions[this.name];
                        t.color = new r.Ilk(1, 1, 1), t.opacity = 1;
                        const s = [];
                        if (Array.isArray(i.diffuseFactor)) {
                            const e = i.diffuseFactor;
                            t.color.fromArray(e), t.opacity = e[3]
                        }
                        if (void 0 !== i.diffuseTexture && s.push(n.assignTexture(t, "map", i.diffuseTexture)), t.emissive = new r.Ilk(0, 0, 0), t.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, t.specular = new r.Ilk(1, 1, 1), Array.isArray(i.specularFactor) && t.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                            const e = i.specularGlossinessTexture;
                            s.push(n.assignTexture(t, "glossinessMap", e)), s.push(n.assignTexture(t, "specularMap", e))
                        }
                        return Promise.all(s)
                    }
                    createMaterial(t) {
                        const e = new S(t);
                        return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = r.IOt, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e
                    }
                }
                class E {
                    constructor() {
                        this.name = a.KHR_MESH_QUANTIZATION
                    }
                }
                class A extends r._C8 {
                    constructor(t, e, n, r) {
                        super(t, e, n, r)
                    }
                    copySampleValue_(t) {
                        const e = this.resultBuffer,
                            n = this.sampleValues,
                            r = this.valueSize,
                            i = t * r * 3 + r;
                        for (let t = 0; t !== r; t++) e[t] = n[i + t];
                        return e
                    }
                }
                A.prototype.beforeStart_ = A.prototype.copySampleValue_, A.prototype.afterEnd_ = A.prototype.copySampleValue_, A.prototype.interpolate_ = function(t, e, n, r) {
                    const i = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = 2 * o,
                        c = 3 * o,
                        l = r - e,
                        u = (n - e) / l,
                        h = u * u,
                        d = h * u,
                        p = t * c,
                        f = p - c,
                        m = -2 * d + 3 * h,
                        g = d - h,
                        v = 1 - m,
                        y = g - h + u;
                    for (let t = 0; t !== o; t++) {
                        const e = s[f + t + o],
                            n = s[f + t + a] * l,
                            r = s[p + t + o],
                            c = s[p + t] * l;
                        i[t] = v * e + y * n + m * r + g * c
                    }
                    return i
                };
                const L = new r._fP;
                class R extends A {
                    interpolate_(t, e, n, r) {
                        const i = super.interpolate_(t, e, n, r);
                        return L.fromArray(i).normalize().toArray(i), i
                    }
                }
                const P = 0,
                    C = 1,
                    I = 2,
                    D = 3,
                    O = 4,
                    N = 5,
                    B = 6,
                    z = {
                        5120: Int8Array,
                        5121: Uint8Array,
                        5122: Int16Array,
                        5123: Uint16Array,
                        5125: Uint32Array,
                        5126: Float32Array
                    },
                    F = {
                        9728: r.TyD,
                        9729: r.wem,
                        9984: r.YLQ,
                        9985: r.qyh,
                        9986: r.aH4,
                        9987: r.D1R
                    },
                    k = {
                        33071: r.uWy,
                        33648: r.OoA,
                        10497: r.rpg
                    },
                    U = {
                        SCALAR: 1,
                        VEC2: 2,
                        VEC3: 3,
                        VEC4: 4,
                        MAT2: 4,
                        MAT3: 9,
                        MAT4: 16
                    },
                    H = {
                        POSITION: "position",
                        NORMAL: "normal",
                        TANGENT: "tangent",
                        TEXCOORD_0: "uv",
                        TEXCOORD_1: "uv2",
                        COLOR_0: "color",
                        WEIGHTS_0: "skinWeight",
                        JOINTS_0: "skinIndex"
                    },
                    G = {
                        scale: "scale",
                        translation: "position",
                        rotation: "quaternion",
                        weights: "morphTargetInfluences"
                    },
                    V = {
                        CUBICSPLINE: void 0,
                        LINEAR: r.NMF,
                        STEP: r.Syv
                    },
                    W = "OPAQUE",
                    j = "MASK",
                    Z = "BLEND";

                function q(t, e) {
                    return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t)
                }

                function X(t) {
                    return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new r.Wid({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: r.Wl3
                    })), t.DefaultMaterial
                }

                function Y(t, e, n) {
                    for (const r in n.extensions) void 0 === t[r] && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[r] = n.extensions[r])
                }

                function J(t, e) {
                    void 0 !== e.extras && ("object" == typeof e.extras ? Object.assign(t.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
                }

                function K(t, e) {
                    if (t.updateMorphTargets(), void 0 !== e.weights)
                        for (let n = 0, r = e.weights.length; n < r; n++) t.morphTargetInfluences[n] = e.weights[n];
                    if (e.extras && Array.isArray(e.extras.targetNames)) {
                        const n = e.extras.targetNames;
                        if (t.morphTargetInfluences.length === n.length) {
                            t.morphTargetDictionary = {};
                            for (let e = 0, r = n.length; e < r; e++) t.morphTargetDictionary[n[e]] = e
                        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                    }
                }

                function Q(t) {
                    const e = t.extensions && t.extensions[a.KHR_DRACO_MESH_COMPRESSION];
                    let n;
                    return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + $(e.attributes) : t.indices + ":" + $(t.attributes) + ":" + t.mode, n
                }

                function $(t) {
                    let e = "";
                    const n = Object.keys(t).sort();
                    for (let r = 0, i = n.length; r < i; r++) e += n[r] + ":" + t[n[r]] + ";";
                    return e
                }

                function tt(t) {
                    switch (t) {
                        case Int8Array:
                            return 1 / 127;
                        case Uint8Array:
                            return 1 / 255;
                        case Int16Array:
                            return 1 / 32767;
                        case Uint16Array:
                            return 1 / 65535;
                        default:
                            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                    }
                }
                class et {
                    constructor(t = {}, e = {}) {
                        this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new o, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                            refs: {},
                            uses: {}
                        }, this.cameraCache = {
                            refs: {},
                            uses: {}
                        }, this.lightCache = {
                            refs: {},
                            uses: {}
                        }, this.textureCache = {}, this.nodeNamesUsed = {}, void 0 !== r.M15 && !1 === /Firefox/.test(i.userAgent) ? this.textureLoader = new r.QRU(this.options.manager) : this.textureLoader = new r.dpR(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new r.hH6(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                    }
                    setExtensions(t) {
                        this.extensions = t
                    }
                    setPlugins(t) {
                        this.plugins = t
                    }
                    parse(t, e) {
                        const n = this,
                            r = this.json,
                            i = this.extensions;
                        this.cache.removeAll(), this._invokeAll((function(t) {
                            return t._markDefs && t._markDefs()
                        })), Promise.all(this._invokeAll((function(t) {
                            return t.beforeRoot && t.beforeRoot()
                        }))).then((function() {
                            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                        })).then((function(e) {
                            const s = {
                                scene: e[0][r.scene || 0],
                                scenes: e[0],
                                animations: e[1],
                                cameras: e[2],
                                asset: r.asset,
                                parser: n,
                                userData: {}
                            };
                            Y(i, s, r), J(s, r), Promise.all(n._invokeAll((function(t) {
                                return t.afterRoot && t.afterRoot(s)
                            }))).then((function() {
                                t(s)
                            }))
                        })).catch(e)
                    }
                    _markDefs() {
                        const t = this.json.nodes || [],
                            e = this.json.skins || [],
                            n = this.json.meshes || [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = e[n].joints;
                            for (let e = 0, n = r.length; e < n; e++) t[r[e]].isBone = !0
                        }
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = t[e];
                            void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
                        }
                    }
                    _addNodeRef(t, e) {
                        void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e] ++)
                    }
                    _getNodeRef(t, e, n) {
                        if (t.refs[e] <= 1) return n;
                        const r = n.clone(),
                            i = (t, e) => {
                                const n = this.associations.get(t);
                                null != n && this.associations.set(e, n);
                                for (const [n, r] of t.children.entries()) i(r, e.children[n])
                            };
                        return i(n, r), r.name += "_instance_" + t.uses[e] ++, r
                    }
                    _invokeOne(t) {
                        const e = Object.values(this.plugins);
                        e.push(this);
                        for (let n = 0; n < e.length; n++) {
                            const r = t(e[n]);
                            if (r) return r
                        }
                        return null
                    }
                    _invokeAll(t) {
                        const e = Object.values(this.plugins);
                        e.unshift(this);
                        const n = [];
                        for (let r = 0; r < e.length; r++) {
                            const i = t(e[r]);
                            i && n.push(i)
                        }
                        return n
                    }
                    getDependency(t, e) {
                        const n = t + ":" + e;
                        let r = this.cache.get(n);
                        if (!r) {
                            switch (t) {
                                case "scene":
                                    r = this.loadScene(e);
                                    break;
                                case "node":
                                    r = this.loadNode(e);
                                    break;
                                case "mesh":
                                    r = this._invokeOne((function(t) {
                                        return t.loadMesh && t.loadMesh(e)
                                    }));
                                    break;
                                case "accessor":
                                    r = this.loadAccessor(e);
                                    break;
                                case "bufferView":
                                    r = this._invokeOne((function(t) {
                                        return t.loadBufferView && t.loadBufferView(e)
                                    }));
                                    break;
                                case "buffer":
                                    r = this.loadBuffer(e);
                                    break;
                                case "material":
                                    r = this._invokeOne((function(t) {
                                        return t.loadMaterial && t.loadMaterial(e)
                                    }));
                                    break;
                                case "texture":
                                    r = this._invokeOne((function(t) {
                                        return t.loadTexture && t.loadTexture(e)
                                    }));
                                    break;
                                case "skin":
                                    r = this.loadSkin(e);
                                    break;
                                case "animation":
                                    r = this.loadAnimation(e);
                                    break;
                                case "camera":
                                    r = this.loadCamera(e);
                                    break;
                                default:
                                    throw new Error("Unknown type: " + t)
                            }
                            this.cache.add(n, r)
                        }
                        return r
                    }
                    getDependencies(t) {
                        let e = this.cache.get(t);
                        if (!e) {
                            const n = this,
                                r = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                            e = Promise.all(r.map((function(e, r) {
                                return n.getDependency(t, r)
                            }))), this.cache.add(t, e)
                        }
                        return e
                    }
                    loadBuffer(t) {
                        const e = this.json.buffers[t],
                            n = this.fileLoader;
                        if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                        if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[a.KHR_BINARY_GLTF].body);
                        const r = this.options;
                        return new Promise((function(t, i) {
                            n.load(q(e.uri, r.path), t, void 0, (function() {
                                i(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
                            }))
                        }))
                    }
                    loadBufferView(t) {
                        const e = this.json.bufferViews[t];
                        return this.getDependency("buffer", e.buffer).then((function(t) {
                            const n = e.byteLength || 0,
                                r = e.byteOffset || 0;
                            return t.slice(r, r + n)
                        }))
                    }
                    loadAccessor(t) {
                        const e = this,
                            n = this.json,
                            i = this.json.accessors[t];
                        if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                        const s = [];
                        return void 0 !== i.bufferView ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), void 0 !== i.sparse && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then((function(t) {
                            const s = t[0],
                                o = U[i.type],
                                a = z[i.componentType],
                                c = a.BYTES_PER_ELEMENT,
                                l = c * o,
                                u = i.byteOffset || 0,
                                h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                                d = !0 === i.normalized;
                            let p, f;
                            if (h && h !== l) {
                                const t = Math.floor(u / h),
                                    n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + t + ":" + i.count;
                                let l = e.cache.get(n);
                                l || (p = new a(s, t * h, i.count * h / c), l = new r.vpT(p, h / c), e.cache.add(n, l)), f = new r.kB5(l, o, u % h / c, d)
                            } else p = null === s ? new a(i.count * o) : new a(s, u, i.count * o), f = new r.TlE(p, o, d);
                            if (void 0 !== i.sparse) {
                                const e = U.SCALAR,
                                    n = z[i.sparse.indices.componentType],
                                    c = i.sparse.indices.byteOffset || 0,
                                    l = i.sparse.values.byteOffset || 0,
                                    u = new n(t[1], c, i.sparse.count * e),
                                    h = new a(t[2], l, i.sparse.count * o);
                                null !== s && (f = new r.TlE(f.array.slice(), f.itemSize, f.normalized));
                                for (let t = 0, e = u.length; t < e; t++) {
                                    const e = u[t];
                                    if (f.setX(e, h[t * o]), o >= 2 && f.setY(e, h[t * o + 1]), o >= 3 && f.setZ(e, h[t * o + 2]), o >= 4 && f.setW(e, h[t * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                }
                            }
                            return f
                        }))
                    }
                    loadTexture(t) {
                        const e = this.json,
                            n = this.options,
                            r = e.textures[t],
                            i = e.images[r.source];
                        let s = this.textureLoader;
                        if (i.uri) {
                            const t = n.manager.getHandler(i.uri);
                            null !== t && (s = t)
                        }
                        return this.loadTextureImage(t, i, s)
                    }
                    loadTextureImage(t, e, n) {
                        const i = this,
                            s = this.json,
                            o = this.options,
                            a = s.textures[t],
                            c = (e.uri || e.bufferView) + ":" + a.sampler;
                        if (this.textureCache[c]) return this.textureCache[c];
                        const l = r.lh0 || self.webkitURL;
                        let u = e.uri || "",
                            h = !1;
                        if (void 0 !== e.bufferView) u = i.getDependency("bufferView", e.bufferView).then((function(t) {
                            h = !0;
                            const n = new r.yFI([t], {
                                type: e.mimeType
                            });
                            return u = l.createObjectURL(n), u
                        }));
                        else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                        const d = Promise.resolve(u).then((function(t) {
                            return new Promise((function(e, i) {
                                let s = e;
                                !0 === n.isImageBitmapLoader && (s = function(t) {
                                    const n = new r.xEZ(t);
                                    n.needsUpdate = !0, e(n)
                                }), n.load(q(t, o.path), s, void 0, i)
                            }))
                        })).then((function(e) {
                            !0 === h && l.revokeObjectURL(u), e.flipY = !1, a.name && (e.name = a.name);
                            const n = (s.samplers || {})[a.sampler] || {};
                            return e.magFilter = F[n.magFilter] || r.wem, e.minFilter = F[n.minFilter] || r.D1R, e.wrapS = k[n.wrapS] || r.rpg, e.wrapT = k[n.wrapT] || r.rpg, i.associations.set(e, {
                                textures: t
                            }), e
                        })).catch((function() {
                            return console.error("THREE.GLTFLoader: Couldn't load texture", u), null
                        }));
                        return this.textureCache[c] = d, d
                    }
                    assignTexture(t, e, n) {
                        const r = this;
                        return this.getDependency("texture", n.index).then((function(i) {
                            if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), r.extensions[a.KHR_TEXTURE_TRANSFORM]) {
                                const t = void 0 !== n.extensions ? n.extensions[a.KHR_TEXTURE_TRANSFORM] : void 0;
                                if (t) {
                                    const e = r.associations.get(i);
                                    i = r.extensions[a.KHR_TEXTURE_TRANSFORM].extendTexture(i, t), r.associations.set(i, e)
                                }
                            }
                            return t[e] = i, i
                        }))
                    }
                    assignFinalMaterial(t) {
                        const e = t.geometry;
                        let n = t.material;
                        const i = void 0 === e.attributes.tangent,
                            s = void 0 !== e.attributes.color,
                            o = void 0 === e.attributes.normal;
                        if (t.isPoints) {
                            const t = "PointsMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new r.UY4, r.F5T.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
                        } else if (t.isLine) {
                            const t = "LineBasicMaterial:" + n.uuid;
                            let e = this.cache.get(t);
                            e || (e = new r.nls, r.F5T.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e
                        }
                        if (i || s || o) {
                            let t = "ClonedMaterial:" + n.uuid + ":";
                            n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), i && (t += "derivative-tangents:"), s && (t += "vertex-colors:"), o && (t += "flat-shading:");
                            let e = this.cache.get(t);
                            e || (e = n.clone(), s && (e.vertexColors = !0), o && (e.flatShading = !0), i && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
                        }
                        n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n
                    }
                    getMaterialType() {
                        return r.Wid
                    }
                    loadMaterial(t) {
                        const e = this,
                            n = this.json,
                            i = this.extensions,
                            s = n.materials[t];
                        let o;
                        const c = {},
                            l = s.extensions || {},
                            u = [];
                        if (l[a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                            const t = i[a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                            o = t.getMaterialType(), u.push(t.extendParams(c, s, e))
                        } else if (l[a.KHR_MATERIALS_UNLIT]) {
                            const t = i[a.KHR_MATERIALS_UNLIT];
                            o = t.getMaterialType(), u.push(t.extendParams(c, s, e))
                        } else {
                            const n = s.pbrMetallicRoughness || {};
                            if (c.color = new r.Ilk(1, 1, 1), c.opacity = 1, Array.isArray(n.baseColorFactor)) {
                                const t = n.baseColorFactor;
                                c.color.fromArray(t), c.opacity = t[3]
                            }
                            void 0 !== n.baseColorTexture && u.push(e.assignTexture(c, "map", n.baseColorTexture)), c.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, c.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (u.push(e.assignTexture(c, "metalnessMap", n.metallicRoughnessTexture)), u.push(e.assignTexture(c, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne((function(e) {
                                return e.getMaterialType && e.getMaterialType(t)
                            })), u.push(Promise.all(this._invokeAll((function(e) {
                                return e.extendMaterialParams && e.extendMaterialParams(t, c)
                            }))))
                        }!0 === s.doubleSided && (c.side = r.ehD);
                        const h = s.alphaMode || W;
                        if (h === Z ? (c.transparent = !0, c.depthWrite = !1) : (c.format = r.UCm, c.transparent = !1, h === j && (c.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)), void 0 !== s.normalTexture && o !== r.vBJ && (u.push(e.assignTexture(c, "normalMap", s.normalTexture)), c.normalScale = new r.FM8(1, 1), void 0 !== s.normalTexture.scale)) {
                            const t = s.normalTexture.scale;
                            c.normalScale.set(t, t)
                        }
                        return void 0 !== s.occlusionTexture && o !== r.vBJ && (u.push(e.assignTexture(c, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (c.aoMapIntensity = s.occlusionTexture.strength)), void 0 !== s.emissiveFactor && o !== r.vBJ && (c.emissive = (new r.Ilk).fromArray(s.emissiveFactor)), void 0 !== s.emissiveTexture && o !== r.vBJ && u.push(e.assignTexture(c, "emissiveMap", s.emissiveTexture)), Promise.all(u).then((function() {
                            let n;
                            return n = o === S ? i[a.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(c) : new o(c), s.name && (n.name = s.name), n.map && (n.map.encoding = r.knz), n.emissiveMap && (n.emissiveMap.encoding = r.knz), J(n, s), e.associations.set(n, {
                                materials: t
                            }), s.extensions && Y(i, n, s), n
                        }))
                    }
                    createUniqueName(t) {
                        const e = r.iUV.sanitizeNodeName(t || "");
                        let n = e;
                        for (let t = 1; this.nodeNamesUsed[n]; ++t) n = e + "_" + t;
                        return this.nodeNamesUsed[n] = !0, n
                    }
                    loadGeometries(t) {
                        const e = this,
                            n = this.extensions,
                            i = this.primitiveCache;

                        function s(t) {
                            return n[a.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
                                return it(n, t, e)
                            }))
                        }
                        const o = [];
                        for (let n = 0, c = t.length; n < c; n++) {
                            const c = t[n],
                                l = Q(c),
                                u = i[l];
                            if (u) o.push(u.promise);
                            else {
                                let t;
                                t = c.extensions && c.extensions[a.KHR_DRACO_MESH_COMPRESSION] ? s(c) : it(new r.u9r, c, e), i[l] = {
                                    primitive: c,
                                    promise: t
                                }, o.push(t)
                            }
                        }
                        return Promise.all(o)
                    }
                    loadMesh(t) {
                        const e = this,
                            n = this.json,
                            i = this.extensions,
                            s = n.meshes[t],
                            o = s.primitives,
                            a = [];
                        for (let t = 0, e = o.length; t < e; t++) {
                            const e = void 0 === o[t].material ? X(this.cache) : this.getDependency("material", o[t].material);
                            a.push(e)
                        }
                        return a.push(e.loadGeometries(o)), Promise.all(a).then((function(n) {
                            const a = n.slice(0, n.length - 1),
                                c = n[n.length - 1],
                                l = [];
                            for (let n = 0, u = c.length; n < u; n++) {
                                const u = c[n],
                                    h = o[n];
                                let d;
                                const p = a[n];
                                if (h.mode === O || h.mode === N || h.mode === B || void 0 === h.mode) d = !0 === s.isSkinnedMesh ? new r.TUv(u, p) : new r.Kj0(u, p), !0 !== d.isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(), h.mode === N ? d.geometry = st(d.geometry, r.UlW) : h.mode === B && (d.geometry = st(d.geometry, r.z$h));
                                else if (h.mode === C) d = new r.ejS(u, p);
                                else if (h.mode === D) d = new r.x12(u, p);
                                else if (h.mode === I) d = new r.blk(u, p);
                                else {
                                    if (h.mode !== P) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                                    d = new r.woe(u, p)
                                }
                                Object.keys(d.geometry.morphAttributes).length > 0 && K(d, s), d.name = e.createUniqueName(s.name || "mesh_" + t), J(d, s), h.extensions && Y(i, d, h), e.assignFinalMaterial(d), l.push(d)
                            }
                            for (let n = 0, r = l.length; n < r; n++) e.associations.set(l[n], {
                                meshes: t,
                                primitives: n
                            });
                            if (1 === l.length) return l[0];
                            const u = new r.ZAu;
                            e.associations.set(u, {
                                meshes: t
                            });
                            for (let t = 0, e = l.length; t < e; t++) u.add(l[t]);
                            return u
                        }))
                    }
                    loadCamera(t) {
                        let e;
                        const n = this.json.cameras[t],
                            i = n[n.type];
                        if (i) return "perspective" === n.type ? e = new r.cPb(r.M8C.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (e = new r.iKG(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (e.name = this.createUniqueName(n.name)), J(e, n), Promise.resolve(e);
                        console.warn("THREE.GLTFLoader: Missing camera parameters.")
                    }
                    loadSkin(t) {
                        const e = this.json.skins[t],
                            n = {
                                joints: e.joints
                            };
                        return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
                            return n.inverseBindMatrices = t, n
                        }))
                    }
                    loadAnimation(t) {
                        const e = this.json.animations[t],
                            n = [],
                            i = [],
                            s = [],
                            o = [],
                            a = [];
                        for (let t = 0, r = e.channels.length; t < r; t++) {
                            const r = e.channels[t],
                                c = e.samplers[r.sampler],
                                l = r.target,
                                u = void 0 !== l.node ? l.node : l.id,
                                h = void 0 !== e.parameters ? e.parameters[c.input] : c.input,
                                d = void 0 !== e.parameters ? e.parameters[c.output] : c.output;
                            n.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), s.push(this.getDependency("accessor", d)), o.push(c), a.push(l)
                        }
                        return Promise.all([Promise.all(n), Promise.all(i), Promise.all(s), Promise.all(o), Promise.all(a)]).then((function(n) {
                            const i = n[0],
                                s = n[1],
                                o = n[2],
                                a = n[3],
                                c = n[4],
                                l = [];
                            for (let t = 0, e = i.length; t < e; t++) {
                                const e = i[t],
                                    n = s[t],
                                    u = o[t],
                                    h = a[t],
                                    d = c[t];
                                if (void 0 === e) continue;
                                let p;
                                switch (e.updateMatrix(), e.matrixAutoUpdate = !0, G[d.path]) {
                                    case G.weights:
                                        p = r.dUE;
                                        break;
                                    case G.rotation:
                                        p = r.iLg;
                                        break;
                                    case G.position:
                                    case G.scale:
                                    default:
                                        p = r.yC1
                                }
                                const f = e.name ? e.name : e.uuid,
                                    m = void 0 !== h.interpolation ? V[h.interpolation] : r.NMF,
                                    g = [];
                                G[d.path] === G.weights ? e.traverse((function(t) {
                                    !0 === t.isMesh && t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid)
                                })) : g.push(f);
                                let v = u.array;
                                if (u.normalized) {
                                    const t = tt(v.constructor),
                                        e = new Float32Array(v.length);
                                    for (let n = 0, r = v.length; n < r; n++) e[n] = v[n] * t;
                                    v = e
                                }
                                for (let t = 0, e = g.length; t < e; t++) {
                                    const e = new p(g[t] + "." + G[d.path], n.array, v, m);
                                    "CUBICSPLINE" === h.interpolation && (e.createInterpolant = function(t) {
                                        return new(this instanceof r.iLg ? R : A)(this.times, this.values, this.getValueSize() / 3, t)
                                    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(e)
                                }
                            }
                            const u = e.name ? e.name : "animation_" + t;
                            return new r.m7l(u, void 0, l)
                        }))
                    }
                    createNodeMesh(t) {
                        const e = this.json,
                            n = this,
                            r = e.nodes[t];
                        return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(t) {
                            const e = n._getNodeRef(n.meshCache, r.mesh, t);
                            return void 0 !== r.weights && e.traverse((function(t) {
                                if (t.isMesh)
                                    for (let e = 0, n = r.weights.length; e < n; e++) t.morphTargetInfluences[e] = r.weights[e]
                            })), e
                        }))
                    }
                    loadNode(t) {
                        const e = this.json,
                            n = this.extensions,
                            i = this,
                            s = e.nodes[t],
                            o = s.name ? i.createUniqueName(s.name) : "";
                        return function() {
                            const e = [],
                                n = i._invokeOne((function(e) {
                                    return e.createNodeMesh && e.createNodeMesh(t)
                                }));
                            return n && e.push(n), void 0 !== s.camera && e.push(i.getDependency("camera", s.camera).then((function(t) {
                                return i._getNodeRef(i.cameraCache, s.camera, t)
                            }))), i._invokeAll((function(e) {
                                return e.createNodeAttachment && e.createNodeAttachment(t)
                            })).forEach((function(t) {
                                e.push(t)
                            })), Promise.all(e)
                        }().then((function(e) {
                            let a;
                            if (a = !0 === s.isBone ? new r.N$j : e.length > 1 ? new r.ZAu : 1 === e.length ? e[0] : new r.Tme, a !== e[0])
                                for (let t = 0, n = e.length; t < n; t++) a.add(e[t]);
                            if (s.name && (a.userData.name = s.name, a.name = o), J(a, s), s.extensions && Y(n, a, s), void 0 !== s.matrix) {
                                const t = new r.yGw;
                                t.fromArray(s.matrix), a.applyMatrix4(t)
                            } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
                            return i.associations.has(a) || i.associations.set(a, {}), i.associations.get(a).nodes = t, a
                        }))
                    }
                    loadScene(t) {
                        const e = this.json,
                            n = this.extensions,
                            i = this.json.scenes[t],
                            s = this,
                            o = new r.ZAu;
                        i.name && (o.name = s.createUniqueName(i.name)), J(o, i), i.extensions && Y(n, o, i);
                        const a = i.nodes || [],
                            c = [];
                        for (let t = 0, n = a.length; t < n; t++) c.push(nt(a[t], o, e, s));
                        return Promise.all(c).then((function() {
                            return s.associations = (t => {
                                const e = new Map;
                                for (const [t, n] of s.associations)(t instanceof r.F5T || t instanceof r.xEZ) && e.set(t, n);
                                return t.traverse(t => {
                                    const n = s.associations.get(t);
                                    null != n && e.set(t, n)
                                }), e
                            })(o), o
                        }))
                    }
                }

                function nt(t, e, n, i) {
                    const s = n.nodes[t];
                    return i.getDependency("node", t).then((function(t) {
                        if (void 0 === s.skin) return t;
                        let e;
                        return i.getDependency("skin", s.skin).then((function(t) {
                            e = t;
                            const n = [];
                            for (let t = 0, r = e.joints.length; t < r; t++) n.push(i.getDependency("node", e.joints[t]));
                            return Promise.all(n)
                        })).then((function(n) {
                            return t.traverse((function(t) {
                                if (!t.isMesh) return;
                                const i = [],
                                    s = [];
                                for (let t = 0, o = n.length; t < o; t++) {
                                    const o = n[t];
                                    if (o) {
                                        i.push(o);
                                        const n = new r.yGw;
                                        void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t), s.push(n)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
                                }
                                t.bind(new r.OdW(i, s), t.matrixWorld)
                            })), t
                        }))
                    })).then((function(t) {
                        e.add(t);
                        const r = [];
                        if (s.children) {
                            const e = s.children;
                            for (let s = 0, o = e.length; s < o; s++) {
                                const o = e[s];
                                r.push(nt(o, t, n, i))
                            }
                        }
                        return Promise.all(r)
                    }))
                }

                function rt(t, e, n) {
                    const i = e.attributes,
                        s = new r.ZzF;
                    if (void 0 === i.POSITION) return; {
                        const t = n.json.accessors[i.POSITION],
                            e = t.min,
                            o = t.max;
                        if (void 0 === e || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (s.set(new r.Pa4(e[0], e[1], e[2]), new r.Pa4(o[0], o[1], o[2])), t.normalized) {
                            const e = tt(z[t.componentType]);
                            s.min.multiplyScalar(e), s.max.multiplyScalar(e)
                        }
                    }
                    const o = e.targets;
                    if (void 0 !== o) {
                        const t = new r.Pa4,
                            e = new r.Pa4;
                        for (let r = 0, i = o.length; r < i; r++) {
                            const i = o[r];
                            if (void 0 !== i.POSITION) {
                                const r = n.json.accessors[i.POSITION],
                                    s = r.min,
                                    o = r.max;
                                if (void 0 !== s && void 0 !== o) {
                                    if (e.setX(Math.max(Math.abs(s[0]), Math.abs(o[0]))), e.setY(Math.max(Math.abs(s[1]), Math.abs(o[1]))), e.setZ(Math.max(Math.abs(s[2]), Math.abs(o[2]))), r.normalized) {
                                        const t = tt(z[r.componentType]);
                                        e.multiplyScalar(t)
                                    }
                                    t.max(e)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        s.expandByVector(t)
                    }
                    t.boundingBox = s;
                    const a = new r.aLr;
                    s.getCenter(a.center), a.radius = s.min.distanceTo(s.max) / 2, t.boundingSphere = a
                }

                function it(t, e, n) {
                    const r = e.attributes,
                        i = [];

                    function s(e, r) {
                        return n.getDependency("accessor", e).then((function(e) {
                            t.setAttribute(r, e)
                        }))
                    }
                    for (const e in r) {
                        const n = H[e] || e.toLowerCase();
                        n in t.attributes || i.push(s(r[e], n))
                    }
                    if (void 0 !== e.indices && !t.index) {
                        const r = n.getDependency("accessor", e.indices).then((function(e) {
                            t.setIndex(e)
                        }));
                        i.push(r)
                    }
                    return J(t, e), rt(t, e, n), Promise.all(i).then((function() {
                        return void 0 !== e.targets ? function(t, e, n) {
                            let r = !1,
                                i = !1;
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                if (void 0 !== n.POSITION && (r = !0), void 0 !== n.NORMAL && (i = !0), r && i) break
                            }
                            if (!r && !i) return Promise.resolve(t);
                            const s = [],
                                o = [];
                            for (let a = 0, c = e.length; a < c; a++) {
                                const c = e[a];
                                if (r) {
                                    const e = void 0 !== c.POSITION ? n.getDependency("accessor", c.POSITION) : t.attributes.position;
                                    s.push(e)
                                }
                                if (i) {
                                    const e = void 0 !== c.NORMAL ? n.getDependency("accessor", c.NORMAL) : t.attributes.normal;
                                    o.push(e)
                                }
                            }
                            return Promise.all([Promise.all(s), Promise.all(o)]).then((function(e) {
                                const n = e[0],
                                    s = e[1];
                                return r && (t.morphAttributes.position = n), i && (t.morphAttributes.normal = s), t.morphTargetsRelative = !0, t
                            }))
                        }(t, e.targets, n) : t
                    }))
                }

                function st(t, e) {
                    let n = t.getIndex();
                    if (null === n) {
                        const e = [],
                            r = t.getAttribute("position");
                        if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
                        for (let t = 0; t < r.count; t++) e.push(t);
                        t.setIndex(e), n = t.getIndex()
                    }
                    const i = n.count - 2,
                        s = [];
                    if (e === r.z$h)
                        for (let t = 1; t <= i; t++) s.push(n.getX(0)), s.push(n.getX(t)), s.push(n.getX(t + 1));
                    else
                        for (let t = 0; t < i; t++) t % 2 == 0 ? (s.push(n.getX(t)), s.push(n.getX(t + 1)), s.push(n.getX(t + 2))) : (s.push(n.getX(t + 2)), s.push(n.getX(t + 1)), s.push(n.getX(t)));
                    s.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    const o = t.clone();
                    return o.setIndex(s), o
                }
            },
            5017: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Y: function() {
                        return M
                    }
                });
                class r {
                    constructor(t, e) {
                        this.parts = t, this.options = e
                    }
                }
                for (var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = new Uint8Array(256), o = 0; o < i.length; o++) s[i.charCodeAt(o)] = o;
                class a {
                    createObjectURL(t) {
                        if (t instanceof r) {
                            const e = function(t) {
                                for (var e, n = "", r = new Uint8Array(t), s = r.byteLength, o = s % 3, a = s - o, c = 0; c < a; c += 3) e = r[c] << 16 | r[c + 1] << 8 | r[c + 2], n += i[(16515072 & e) >> 18] + i[(258048 & e) >> 12] + i[(4032 & e) >> 6] + i[63 & e];
                                return 1 == o ? (e = r[a], n += i[(252 & e) >> 2] + i[(3 & e) << 4] + "==") : 2 == o && (e = r[a] << 8 | r[a + 1], n += i[(64512 & e) >> 10] + i[(1008 & e) >> 4] + i[(15 & e) << 2] + "="), n
                            }(t.parts[0]);
                            return `data:${t.options.type};base64,${e}`
                        }
                        return ""
                    }
                    revokeObjectURL() {}
                }

                function c(t) {
                    if ((t = (t = "" + t).replace(/[ \t\n\f\r]/g, "")).length % 4 == 0 && (t = t.replace(/==?$/, "")), t.length % 4 == 1 || /[^+/0-9A-Za-z]/.test(t)) return null;
                    let e = "",
                        n = 0,
                        r = 0;
                    for (let i = 0; i < t.length; i++) n <<= 6, n |= l(t[i]), r += 6, 24 === r && (e += String.fromCharCode((16711680 & n) >> 16), e += String.fromCharCode((65280 & n) >> 8), e += String.fromCharCode(255 & n), n = r = 0);
                    return 12 === r ? (n >>= 4, e += String.fromCharCode(n)) : 18 === r && (n >>= 2, e += String.fromCharCode((65280 & n) >> 8), e += String.fromCharCode(255 & n)), e
                }

                function l(t) {
                    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(t);
                    return e < 0 ? void 0 : e
                }
                var u = n(198);
                const h = new WeakMap,
                    d = new WeakMap,
                    p = new WeakMap;

                function f(t, e = {}) {
                    e.target = e.target || this, "function" == typeof this["on" + t] && this["on" + t].call(this, e)
                }

                function m(t, e = {}) {
                    this.readyState = t, e.readyState = t, f.call(this, "readystatechange", e)
                }
                const {
                    platform: g
                } = wx.getSystemInfoSync();
                class v extends u.Z {
                    constructor() {
                        super(), this.onabort = null, this.onerror = null, this.onload = null, this.onloadstart = null, this.onprogress = null, this.ontimeout = null, this.onloadend = null, this.onreadystatechange = null, this.readyState = 0, this.response = null, this.responseText = null, this.responseType = "text", this.dataType = "string", this.responseXML = null, this.status = 0, this.statusText = "", this.upload = {}, this.withCredentials = !1, h.set(this, {
                            "content-type": "application/x-www-form-urlencoded"
                        }), d.set(this, {})
                    }
                    abort() {
                        const t = p.get(this);
                        t && t.abort()
                    }
                    getAllResponseHeaders() {
                        const t = d.get(this);
                        return Object.keys(t).map(e => `${e}: ${t[e]}`).join("\n")
                    }
                    getResponseHeader(t) {
                        return d.get(this)[t]
                    }
                    open(t, e) {
                        this._method = t, this._url = e, m.call(this, v.OPENED)
                    }
                    overrideMimeType() {}
                    send(t = "") {
                        if (this.readyState !== v.OPENED) throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED."); {
                            const n = this._url,
                                r = h.get(this),
                                i = this.responseType,
                                s = this.dataType,
                                o = function(t) {
                                    return !/^(http|https|ftp|wxfile):\/\/.*/i.test(t)
                                }(n);
                            let a;
                            "arraybuffer" === i || (a = "utf8"), delete this.response, this.response = null;
                            let c = !1;
                            const l = ({
                                    data: t,
                                    statusCode: e,
                                    header: n
                                }) => {
                                    if (!c) {
                                        if (c = !0, e = void 0 === e ? 200 : e, "string" != typeof t && !(t instanceof ArrayBuffer)) try {
                                            t = JSON.stringify(t)
                                        } catch (t) {}
                                        this.status = e, n && d.set(this, n), f.call(this, "loadstart"), m.call(this, v.HEADERS_RECEIVED), m.call(this, v.LOADING), this.response = t, t instanceof ArrayBuffer ? Object.defineProperty(this, "responseText", {
                                            enumerable: !0,
                                            configurable: !0,
                                            get: function() {
                                                throw "InvalidStateError : responseType is " + this.responseType
                                            }
                                        }) : this.responseText = t, m.call(this, v.DONE), f.call(this, "load"), f.call(this, "loadend")
                                    }
                                },
                                u = ({
                                    errMsg: t
                                }) => {
                                    c || (c = !0, -1 !== t.indexOf("abort") ? f.call(this, "abort") : f.call(this, "error", {
                                        message: t
                                    }), f.call(this, "loadend"), o && console.warn(t))
                                };
                            if (o) {
                                const t = wx.getFileSystemManager();
                                var e = {
                                    filePath: n,
                                    success: l,
                                    fail: u
                                };
                                return a && (e.encoding = a), void t.readFile(e)
                            }
                            const p = "arraybuffer" === i && "ios" === g && v.useFetchPatch;
                            wx.request({
                                data: t,
                                url: n,
                                method: this._method,
                                header: r,
                                dataType: s,
                                responseType: i,
                                enableCache: !1,
                                success: l,
                                fail: u
                            }), p && setTimeout((function() {
                                wx.request({
                                    data: t,
                                    url: n,
                                    method: this._method,
                                    header: r,
                                    dataType: s,
                                    responseType: i,
                                    enableCache: !0,
                                    success: l,
                                    fail: u
                                })
                            }), v.fetchPatchDelay)
                        }
                    }
                    setRequestHeader(t, e) {
                        const n = h.get(this);
                        n[t] = e, h.set(this, n)
                    }
                    addEventListener(t, e) {
                        "function" == typeof e && (this["on" + t] = (t = {}) => {
                            t.target = t.target || this, e.call(this, t)
                        })
                    }
                    removeEventListener(t, e) {
                        this["on" + t] === e && (this["on" + t] = null)
                    }
                }
                v.UNSEND = 0, v.OPENED = 1, v.HEADERS_RECEIVED = 2, v.LOADING = 3, v.DONE = 4, v.useFetchPatch = !1, v.fetchPatchDelay = 200;
                var y = function(t) {
                    return t = (t = t.trim()).replace(/<!--[\s\S]*?-->/g, ""), {
                        declaration: e(),
                        root: n()
                    };

                    function e() {
                        if (!s(/^<\?xml\s*/)) return;
                        const t = {
                            attributes: {}
                        };
                        for (; !o() && !a("?>");) {
                            const e = r();
                            if (!e) return t;
                            t.attributes[e.name] = e.value
                        }
                        return s(/\?>\s*/), s(/<!DOCTYPE[^>]*>\s/), t
                    }

                    function n() {
                        const t = s(/^<([\w-:.]+)\s*/);
                        if (!t) return;
                        const e = {
                            name: t[1],
                            attributes: {},
                            children: []
                        };
                        for (; !(o() || a(">") || a("?>") || a("/>"));) {
                            const t = r();
                            if (!t) return e;
                            e.attributes[t.name] = t.value
                        }
                        if (s(/^\s*\/>\s*/)) return e;
                        let i;
                        for (s(/\??>\s*/), e.content = function() {
                                const t = s(/^([^<]*)/);
                                return t ? t[1] : ""
                            }(); i = n();) e.children.push(i);
                        return s(/^<\/[\w-:.]+>\s*/), e
                    }

                    function r() {
                        const t = s(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);
                        if (t) return {
                            name: t[1],
                            value: i(t[2])
                        }
                    }

                    function i(t) {
                        return t.replace(/^['"]|['"]$/g, "")
                    }

                    function s(e) {
                        const n = t.match(e);
                        if (n) return t = t.slice(n[0].length), n
                    }

                    function o() {
                        return 0 == t.length
                    }

                    function a(e) {
                        return 0 == t.indexOf(e)
                    }
                };

                function x(t, e) {
                    e(t), t.children.forEach(t => x(t, e))
                }
                class _ {
                    parseFromString(t) {
                        const e = y(t),
                            n = {
                                hasAttribute(t) {
                                    return void 0 !== this.attributes[t]
                                }, getAttribute(t) {
                                    return this.attributes[t]
                                }, getElementsByTagName(t) {
                                    const e = [];
                                    return this.childNodes.forEach(n => x(n, n => t === n.name && e.push(n))), e
                                }
                            };
                        x(e.root, t => {
                            t.nodeType = 1, t.nodeName = t.name, t.style = new Proxy((t.attributes.style || "").split(";").reduce((t, e) => {
                                if (e) {
                                    let [n, r] = e.split(":");
                                    t[n.trim()] = r.trim()
                                }
                                return t
                            }, {}), {get: (t, e) => t[e] || ""
                            }), t.textContent = t.content, t.childNodes = t.children, t.__proto__ = n
                        });
                        const r = {
                            documentElement: e.root,
                            childNodes: [e.root]
                        };
                        return r.__proto__ = n, r
                    }
                }
                class b {
                    decode(t) {
                        t instanceof ArrayBuffer && (t = new Uint8Array(t));
                        let e = "";
                        for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                        try {
                            return decodeURIComponent(escape(e))
                        } catch (t) {
                            return e
                        }
                    }
                }

                function w() {
                    return wx.createOffscreenCanvas()
                }
                class M {
                    constructor(t, e, n) {
                        const r = wx.getSystemInfoSync(),
                            i = "android" === r.platform;
                        this.canvas = t, this.canvasW = void 0 === e ? t.width : e, this.canvasH = void 0 === n ? t.height : n, this.document = {
                            createElementNS: (e, n) => "canvas" === n ? t : "img" === n ? t.createImage() : void 0
                        }, this.window = {
                            innerWidth: r.windowWidth,
                            innerHeight: r.windowHeight,
                            devicePixelRatio: r.pixelRatio,
                            URL: new a,
                            AudioContext: function() {},
                            requestAnimationFrame: this.canvas.requestAnimationFrame,
                            cancelAnimationFrame: this.canvas.cancelAnimationFrame,
                            DeviceOrientationEvent: {
                                requestPermission: () => Promise.resolve("granted")
                            },
                            DOMParser: _,
                            TextDecoder: b
                        }, [this.canvas, this.document, this.window].forEach(t => {
                            const e = t.__proto__;
                            t.__proto__ = {}, t.__proto__.__proto__ = e,
                                function(t, e) {
                                    for (let n of Object.getOwnPropertyNames(e))
                                        if ("constructor" !== n && "prototype" !== n && "name" !== n) {
                                            let r = Object.getOwnPropertyDescriptor(e, n);
                                            Object.defineProperty(t, n, r)
                                        }
                                }(t.__proto__, u.Z.prototype)
                        }), this.patchCanvas(), this.onDeviceMotionChange = t => {
                            t.type = "deviceorientation", i && (t.alpha *= -1, t.beta *= -1, t.gamma *= -1), this.window.dispatchEvent(t)
                        }
                    }
                    patchCanvas() {
                        const {
                            canvasH: t,
                            canvasW: e
                        } = this;
                        Object.defineProperty(this.canvas, "style", {
                            get() {
                                return {
                                    width: this.width + "px",
                                    height: this.height + "px"
                                }
                            }
                        }), Object.defineProperty(this.canvas, "clientHeight", {
                            get() {
                                return t || this.height
                            }
                        }), Object.defineProperty(this.canvas, "clientWidth", {
                            get() {
                                return e || this.width
                            }
                        }), this.canvas.ownerDocument = this.document
                    }
                    patchXHR() {
                        return v.useFetchPatch = !0, this
                    }
                    getGlobals() {
                        return {
                            atob: c,
                            Blob: r,
                            window: this.window,
                            document: this.document,
                            HTMLCanvasElement: void 0,
                            XMLHttpRequest: v,
                            OffscreenCanvas: w,
                            createImageBitmap: void 0
                        }
                    }
                    enableDeviceOrientation(t) {
                        return new Promise((e, n) => {
                            wx.onDeviceMotionChange(this.onDeviceMotionChange), wx.startDeviceMotionListening({
                                interval: t,
                                success: t => {
                                    e(t), this.enabledDeviceMotion = !0
                                },
                                fail: n
                            })
                        })
                    }
                    disableDeviceOrientation() {
                        return new Promise((t, e) => {
                            wx.offDeviceMotionChange(this.onDeviceMotionChange), this.enabledDeviceMotion && wx.stopDeviceMotionListening({
                                success: () => {
                                    t(), this.enabledDeviceMotion = !1
                                },
                                fail: e
                            })
                        })
                    }
                    dispatchTouchEvent(t = {}) {
                        const e = {...this
                            },
                            n = t.changedTouches.map(t => new u.X(t)),
                            r = {
                                changedTouches: n,
                                touches: t.touches.map(t => new u.X(t)),
                                targetTouches: Array.prototype.slice.call(t.touches.map(t => new u.X(t))),
                                timeStamp: t.timeStamp,
                                target: e,
                                currentTarget: e,
                                type: t.type,
                                cancelBubble: !1,
                                cancelable: !1
                            };
                        if (this.canvas.dispatchEvent(r), n.length) {
                            const e = n[0],
                                r = {
                                    pageX: e.pageX,
                                    pageY: e.pageY,
                                    pointerId: e.identifier,
                                    type: {
                                        touchstart: "pointerdown",
                                        touchmove: "pointermove",
                                        touchend: "pointerup"
                                    }[t.type],
                                    pointerType: "touch"
                                };
                            this.canvas.dispatchEvent(r)
                        }
                    }
                    dispose() {
                        this.disableDeviceOrientation(), this.canvas.width = 0, this.canvas.height = 0, this.canvas && (this.canvas.ownerDocument = null), this.onDeviceMotionChange = null, this.document = null, this.window = null, this.canvas = null
                    }
                }
            },
            198: function(t, e, n) {
                "use strict";
                n.d(e, {
                    X: function() {
                        return i
                    },
                    Z: function() {
                        return s
                    }
                });
                const r = new WeakMap;
                class i {
                    constructor(t) {
                        this.identifier = t.identifier, this.force = void 0 === t.force ? 1 : t.force, this.pageX = void 0 === t.pageX ? t.x : t.pageX, this.pageY = void 0 === t.pageY ? t.y : t.pageY, this.clientX = void 0 === t.clientX ? t.x : t.clientX, this.clientY = void 0 === t.clientY ? t.y : t.clientY, this.screenX = this.pageX, this.screenY = this.pageY
                    }
                }
                class s {
                    constructor() {
                        r.set(this, {})
                    }
                    addEventListener(t, e, n = {}) {
                        let i = r.get(this);
                        i || (i = {}, r.set(this, i)), i[t] || (i[t] = []), i[t].push(e), n.capture, n.once, n.passive
                    }
                    removeEventListener(t, e) {
                        const n = r.get(this);
                        if (n) {
                            const r = n[t];
                            if (r && r.length > 0)
                                for (let t = r.length; t--; t > 0)
                                    if (r[t] === e) {
                                        r.splice(t, 1);
                                        break
                                    }
                        }
                    }
                    dispatchEvent(t = {}) {
                        "function" != typeof t.preventDefault && (t.preventDefault = () => {}), "function" != typeof t.stopPropagation && (t.stopPropagation = () => {});
                        const e = r.get(this);
                        if (e) {
                            const n = e[t.type];
                            if (n)
                                for (let e = 0; e < n.length; e++) n[e](t)
                        }
                    }
                    releasePointerCapture() {}
                    setPointerCapture() {}
                }
            },
            907: function(t, e, n) {
                "use strict";

                function r(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
                    return r
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            3878: function(t, e, n) {
                "use strict";

                function r(t) {
                    if (Array.isArray(t)) return t
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            7326: function(t, e, n) {
                "use strict";

                function r(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            5861: function(t, e, n) {
                "use strict";

                function r(t, e, n, r, i, s, o) {
                    try {
                        var a = t[s](o),
                            c = a.value
                    } catch (t) {
                        return void n(t)
                    }
                    a.done ? e(c) : Promise.resolve(c).then(r, i)
                }

                function i(t) {
                    return function() {
                        var e = this,
                            n = arguments;
                        return new Promise((function(i, s) {
                            var o = t.apply(e, n);

                            function a(t) {
                                r(o, i, s, a, c, "next", t)
                            }

                            function c(t) {
                                r(o, i, s, a, c, "throw", t)
                            }
                            a(void 0)
                        }))
                    }
                }
                n.d(e, {
                    Z: function() {
                        return i
                    }
                })
            },
            864: function(t, e, n) {
                "use strict";

                function r(t, e) {
                    if (e.has(t)) throw new TypeError("Cannot initialize the same private elements twice on an object")
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            5671: function(t, e, n) {
                "use strict";

                function r(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            1519: function(t, e, n) {
                "use strict";

                function r(t, e, n) {
                    if (!e.has(t)) throw new TypeError("attempted to " + n + " private field on non-instance");
                    return e.get(t)
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            6033: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(1519);

                function i(t, e) {
                    return function(t, e) {
                        return e.get ? e.get.call(t) : e.value
                    }(t, (0, r.Z)(t, e, "get"))
                }
            },
            2346: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(864);

                function i(t, e, n) {
                    (0, r.Z)(t, e), e.set(t, n)
                }
            },
            3092: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(1519);

                function i(t, e, n) {
                    return function(t, e, n) {
                        if (e.set) e.set.call(t, n);
                        else {
                            if (!e.writable) throw new TypeError("attempted to set read only private field");
                            e.value = n
                        }
                    }(t, (0, r.Z)(t, e, "set"), n), n
                }
            },
            3889: function(t, e, n) {
                "use strict";

                function r(t, e, n) {
                    if (!e.has(t)) throw new TypeError("attempted to get private field on non-instance");
                    return n
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            101: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(864);

                function i(t, e) {
                    (0, r.Z)(t, e), e.add(t)
                }
            },
            3144: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return s
                    }
                });
                var r = n(9142);

                function i(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var i = e[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (0, r.Z)(i.key), i)
                    }
                }

                function s(t, e, n) {
                    return e && i(t.prototype, e), n && i(t, n), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), t
                }
            },
            7762: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(181);

                function i(t, e) {
                    var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                    if (!n) {
                        if (Array.isArray(t) || (n = (0, r.Z)(t)) || e && t && "number" == typeof t.length) {
                            n && (t = n);
                            var i = 0,
                                s = function() {};
                            return {
                                s: s,
                                n: function() {
                                    return i >= t.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t[i++]
                                    }
                                },
                                e: function(t) {
                                    throw t
                                },
                                f: s
                            }
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }
                    var o, a = !0,
                        c = !1;
                    return {
                        s: function() {
                            n = n.call(t)
                        },
                        n: function() {
                            var t = n.next();
                            return a = t.done, t
                        },
                        e: function(t) {
                            c = !0, o = t
                        },
                        f: function() {
                            try {
                                a || null == n.return || n.return()
                            } finally {
                                if (c) throw o
                            }
                        }
                    }
                }
            },
            7277: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return c
                    }
                });
                var r = n(1120),
                    i = n(8814),
                    s = n(1002),
                    o = n(7326);

                function a(t, e) {
                    if (e && ("object" === (0, s.Z)(e) || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return (0, o.Z)(t)
                }

                function c(t) {
                    var e = (0, i.Z)();
                    return function() {
                        var n, i = (0, r.Z)(t);
                        if (e) {
                            var s = (0, r.Z)(this).constructor;
                            n = Reflect.construct(i, arguments, s)
                        } else n = i.apply(this, arguments);
                        return a(this, n)
                    }
                }
            },
            4942: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(9142);

                function i(t, e, n) {
                    return (e = (0, r.Z)(e)) in t ? Object.defineProperty(t, e, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = n, t
                }
            },
            8301: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(8415);

                function i() {
                    return (i = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t, e, n) {
                        var i = (0, r.Z)(t, e);
                        if (i) {
                            var s = Object.getOwnPropertyDescriptor(i, e);
                            return s.get ? s.get.call(arguments.length < 3 ? t : n) : s.value
                        }
                    }).apply(this, arguments)
                }
            },
            1120: function(t, e, n) {
                "use strict";

                function r(t) {
                    return (r = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            136: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(9611);

                function i(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), e && (0, r.Z)(t, e)
                }
            },
            8814: function(t, e, n) {
                "use strict";

                function r() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            9199: function(t, e, n) {
                "use strict";

                function r(t) {
                    if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            5267: function(t, e, n) {
                "use strict";

                function r() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            1413: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return s
                    }
                });
                var r = n(4942);

                function i(t, e) {
                    var n = Object.keys(t);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(t);
                        e && (r = r.filter((function(e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        }))), n.push.apply(n, r)
                    }
                    return n
                }

                function s(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = null != arguments[e] ? arguments[e] : {};
                        e % 2 ? i(Object(n), !0).forEach((function(e) {
                            (0, r.Z)(t, e, n[e])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : i(Object(n)).forEach((function(e) {
                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                        }))
                    }
                    return t
                }
            },
            4165: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(1002);

                function i() {
                    i = function() {
                        return e
                    };
                    var t, e = {},
                        n = Object.prototype,
                        s = n.hasOwnProperty,
                        o = Object.defineProperty || function(t, e, n) {
                            t[e] = n.value
                        },
                        a = "function" == typeof Symbol ? Symbol : {},
                        c = a.iterator || "@@iterator",
                        l = a.asyncIterator || "@@asyncIterator",
                        u = a.toStringTag || "@@toStringTag";

                    function h(t, e, n) {
                        return Object.defineProperty(t, e, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }), t[e]
                    }
                    try {
                        h({}, "")
                    } catch (t) {
                        h = function(t, e, n) {
                            return t[e] = n
                        }
                    }

                    function d(t, e, n, r) {
                        var i = e && e.prototype instanceof y ? e : y,
                            s = Object.create(i.prototype),
                            a = new C(r || []);
                        return o(s, "_invoke", {
                            value: A(t, n, a)
                        }), s
                    }

                    function p(t, e, n) {
                        try {
                            return {
                                type: "normal",
                                arg: t.call(e, n)
                            }
                        } catch (t) {
                            return {
                                type: "throw",
                                arg: t
                            }
                        }
                    }
                    e.wrap = d;
                    var f = "suspendedStart",
                        m = "executing",
                        g = "completed",
                        v = {};

                    function y() {}

                    function x() {}

                    function _() {}
                    var b = {};
                    h(b, c, (function() {
                        return this
                    }));
                    var w = Object.getPrototypeOf,
                        M = w && w(w(I([])));
                    M && M !== n && s.call(M, c) && (b = M);
                    var S = _.prototype = y.prototype = Object.create(b);

                    function T(t) {
                        ["next", "throw", "return"].forEach((function(e) {
                            h(t, e, (function(t) {
                                return this._invoke(e, t)
                            }))
                        }))
                    }

                    function E(t, e) {
                        function n(i, o, a, c) {
                            var l = p(t[i], t, o);
                            if ("throw" !== l.type) {
                                var u = l.arg,
                                    h = u.value;
                                return h && "object" == (0, r.Z)(h) && s.call(h, "__await") ? e.resolve(h.__await).then((function(t) {
                                    n("next", t, a, c)
                                }), (function(t) {
                                    n("throw", t, a, c)
                                })) : e.resolve(h).then((function(t) {
                                    u.value = t, a(u)
                                }), (function(t) {
                                    return n("throw", t, a, c)
                                }))
                            }
                            c(l.arg)
                        }
                        var i;
                        o(this, "_invoke", {
                            value: function(t, r) {
                                function s() {
                                    return new e((function(e, i) {
                                        n(t, r, e, i)
                                    }))
                                }
                                return i = i ? i.then(s, s) : s()
                            }
                        })
                    }

                    function A(e, n, r) {
                        var i = f;
                        return function(s, o) {
                            if (i === m) throw new Error("Generator is already running");
                            if (i === g) {
                                if ("throw" === s) throw o;
                                return {
                                    value: t,
                                    done: !0
                                }
                            }
                            for (r.method = s, r.arg = o;;) {
                                var a = r.delegate;
                                if (a) {
                                    var c = L(a, r);
                                    if (c) {
                                        if (c === v) continue;
                                        return c
                                    }
                                }
                                if ("next" === r.method) r.sent = r._sent = r.arg;
                                else if ("throw" === r.method) {
                                    if (i === f) throw i = g, r.arg;
                                    r.dispatchException(r.arg)
                                } else "return" === r.method && r.abrupt("return", r.arg);
                                i = m;
                                var l = p(e, n, r);
                                if ("normal" === l.type) {
                                    if (i = r.done ? g : "suspendedYield", l.arg === v) continue;
                                    return {
                                        value: l.arg,
                                        done: r.done
                                    }
                                }
                                "throw" === l.type && (i = g, r.method = "throw", r.arg = l.arg)
                            }
                        }
                    }

                    function L(e, n) {
                        var r = n.method,
                            i = e.iterator[r];
                        if (i === t) return n.delegate = null, "throw" === r && e.iterator.return && (n.method = "return", n.arg = t, L(e, n), "throw" === n.method) || "return" !== r && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + r + "' method")), v;
                        var s = p(i, e.iterator, n.arg);
                        if ("throw" === s.type) return n.method = "throw", n.arg = s.arg, n.delegate = null, v;
                        var o = s.arg;
                        return o ? o.done ? (n[e.resultName] = o.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, v) : o : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, v)
                    }

                    function R(t) {
                        var e = {
                            tryLoc: t[0]
                        };
                        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e)
                    }

                    function P(t) {
                        var e = t.completion || {};
                        e.type = "normal", delete e.arg, t.completion = e
                    }

                    function C(t) {
                        this.tryEntries = [{
                            tryLoc: "root"
                        }], t.forEach(R, this), this.reset(!0)
                    }

                    function I(e) {
                        if (e || "" === e) {
                            var n = e[c];
                            if (n) return n.call(e);
                            if ("function" == typeof e.next) return e;
                            if (!isNaN(e.length)) {
                                var i = -1,
                                    o = function n() {
                                        for (; ++i < e.length;)
                                            if (s.call(e, i)) return n.value = e[i], n.done = !1, n;
                                        return n.value = t, n.done = !0, n
                                    };
                                return o.next = o
                            }
                        }
                        throw new TypeError((0, r.Z)(e) + " is not iterable")
                    }
                    return x.prototype = _, o(S, "constructor", {
                        value: _,
                        configurable: !0
                    }), o(_, "constructor", {
                        value: x,
                        configurable: !0
                    }), x.displayName = h(_, u, "GeneratorFunction"), e.isGeneratorFunction = function(t) {
                        var e = "function" == typeof t && t.constructor;
                        return !!e && (e === x || "GeneratorFunction" === (e.displayName || e.name))
                    }, e.mark = function(t) {
                        return Object.setPrototypeOf ? Object.setPrototypeOf(t, _) : (t.__proto__ = _, h(t, u, "GeneratorFunction")), t.prototype = Object.create(S), t
                    }, e.awrap = function(t) {
                        return {
                            __await: t
                        }
                    }, T(E.prototype), h(E.prototype, l, (function() {
                        return this
                    })), e.AsyncIterator = E, e.async = function(t, n, r, i, s) {
                        void 0 === s && (s = Promise);
                        var o = new E(d(t, n, r, i), s);
                        return e.isGeneratorFunction(n) ? o : o.next().then((function(t) {
                            return t.done ? t.value : o.next()
                        }))
                    }, T(S), h(S, u, "Generator"), h(S, c, (function() {
                        return this
                    })), h(S, "toString", (function() {
                        return "[object Generator]"
                    })), e.keys = function(t) {
                        var e = Object(t),
                            n = [];
                        for (var r in e) n.push(r);
                        return n.reverse(),
                            function t() {
                                for (; n.length;) {
                                    var r = n.pop();
                                    if (r in e) return t.value = r, t.done = !1, t
                                }
                                return t.done = !0, t
                            }
                    }, e.values = I, C.prototype = {
                        constructor: C,
                        reset: function(e) {
                            if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(P), !e)
                                for (var n in this) "t" === n.charAt(0) && s.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                        },
                        stop: function() {
                            this.done = !0;
                            var t = this.tryEntries[0].completion;
                            if ("throw" === t.type) throw t.arg;
                            return this.rval
                        },
                        dispatchException: function(e) {
                            if (this.done) throw e;
                            var n = this;

                            function r(r, i) {
                                return a.type = "throw", a.arg = e, n.next = r, i && (n.method = "next", n.arg = t), !!i
                            }
                            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                                var o = this.tryEntries[i],
                                    a = o.completion;
                                if ("root" === o.tryLoc) return r("end");
                                if (o.tryLoc <= this.prev) {
                                    var c = s.call(o, "catchLoc"),
                                        l = s.call(o, "finallyLoc");
                                    if (c && l) {
                                        if (this.prev < o.catchLoc) return r(o.catchLoc, !0);
                                        if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                    } else if (c) {
                                        if (this.prev < o.catchLoc) return r(o.catchLoc, !0)
                                    } else {
                                        if (!l) throw new Error("try statement without catch or finally");
                                        if (this.prev < o.finallyLoc) return r(o.finallyLoc)
                                    }
                                }
                            }
                        },
                        abrupt: function(t, e) {
                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                var r = this.tryEntries[n];
                                if (r.tryLoc <= this.prev && s.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                    var i = r;
                                    break
                                }
                            }
                            i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
                            var o = i ? i.completion : {};
                            return o.type = t, o.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, v) : this.complete(o)
                        },
                        complete: function(t, e) {
                            if ("throw" === t.type) throw t.arg;
                            return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), v
                        },
                        finish: function(t) {
                            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                                var n = this.tryEntries[e];
                                if (n.finallyLoc === t) return this.complete(n.completion, n.afterLoc), P(n), v
                            }
                        },
                        catch: function(t) {
                            for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                                var n = this.tryEntries[e];
                                if (n.tryLoc === t) {
                                    var r = n.completion;
                                    if ("throw" === r.type) {
                                        var i = r.arg;
                                        P(n)
                                    }
                                    return i
                                }
                            }
                            throw new Error("illegal catch attempt")
                        },
                        delegateYield: function(e, n, r) {
                            return this.delegate = {
                                iterator: I(e),
                                resultName: n,
                                nextLoc: r
                            }, "next" === this.method && (this.arg = t), v
                        }
                    }, e
                }
            },
            4433: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return o
                    }
                });
                var r = n(8415),
                    i = n(4942);

                function s(t, e, n, o) {
                    return (s = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(t, e, n, s) {
                        var o, a = (0, r.Z)(t, e);
                        if (a) {
                            if ((o = Object.getOwnPropertyDescriptor(a, e)).set) return o.set.call(s, n), !0;
                            if (!o.writable) return !1
                        }
                        if (o = Object.getOwnPropertyDescriptor(s, e)) {
                            if (!o.writable) return !1;
                            o.value = n, Object.defineProperty(s, e, o)
                        } else(0, i.Z)(s, e, n);
                        return !0
                    })(t, e, n, o)
                }

                function o(t, e, n, r, i) {
                    if (!s(t, e, n, r || t) && i) throw new TypeError("failed to set property");
                    return n
                }
            },
            9611: function(t, e, n) {
                "use strict";

                function r(t, e) {
                    return (r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            9439: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return o
                    }
                });
                var r = n(3878);
                var i = n(181),
                    s = n(5267);

                function o(t, e) {
                    return (0, r.Z)(t) || function(t, e) {
                        var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (null != n) {
                            var r, i, s, o, a = [],
                                c = !0,
                                l = !1;
                            try {
                                if (s = (n = n.call(t)).next, 0 === e) {
                                    if (Object(n) !== n) return;
                                    c = !1
                                } else
                                    for (; !(c = (r = s.call(n)).done) && (a.push(r.value), a.length !== e); c = !0);
                            } catch (t) {
                                l = !0, i = t
                            } finally {
                                try {
                                    if (!c && null != n.return && (o = n.return(), Object(o) !== o)) return
                                } finally {
                                    if (l) throw i
                                }
                            }
                            return a
                        }
                    }(t, e) || (0, i.Z)(t, e) || (0, s.Z)()
                }
            },
            8415: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(1120);

                function i(t, e) {
                    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = (0, r.Z)(t)););
                    return t
                }
            },
            4506: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return a
                    }
                });
                var r = n(3878),
                    i = n(9199),
                    s = n(181),
                    o = n(5267);

                function a(t) {
                    return (0, r.Z)(t) || (0, i.Z)(t) || (0, s.Z)(t) || (0, o.Z)()
                }
            },
            3433: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return o
                    }
                });
                var r = n(907);
                var i = n(9199),
                    s = n(181);

                function o(t) {
                    return function(t) {
                        if (Array.isArray(t)) return (0, r.Z)(t)
                    }(t) || (0, i.Z)(t) || (0, s.Z)(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }
            },
            9142: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(1002);

                function i(t) {
                    var e = function(t, e) {
                        if ("object" !== (0, r.Z)(t) || null === t) return t;
                        var n = t[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var i = n.call(t, e || "default");
                            if ("object" !== (0, r.Z)(i)) return i;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === e ? String : Number)(t)
                    }(t, "string");
                    return "symbol" === (0, r.Z)(e) ? e : String(e)
                }
            },
            1002: function(t, e, n) {
                "use strict";

                function r(t) {
                    return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    } : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }
                n.d(e, {
                    Z: function() {
                        return r
                    }
                })
            },
            181: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return i
                    }
                });
                var r = n(907);

                function i(t, e) {
                    if (t) {
                        if ("string" == typeof t) return (0, r.Z)(t, e);
                        var n = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? (0, r.Z)(t, e) : void 0
                    }
                }
            },
            8737: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return a
                    }
                });
                var r = n(1120),
                    i = n(9611);
                var s = n(8814);

                function o(t, e, n) {
                    return (o = (0, s.Z)() ? Reflect.construct.bind() : function(t, e, n) {
                        var r = [null];
                        r.push.apply(r, e);
                        var s = new(Function.bind.apply(t, r));
                        return n && (0, i.Z)(s, n.prototype), s
                    }).apply(null, arguments)
                }

                function a(t) {
                    var e = "function" == typeof Map ? new Map : void 0;
                    return (a = function(t) {
                        if (null === t || ! function(t) {
                                try {
                                    return -1 !== Function.toString.call(t).indexOf("[native code]")
                                } catch (e) {
                                    return "function" == typeof t
                                }
                            }(t)) return t;
                        if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== e) {
                            if (e.has(t)) return e.get(t);
                            e.set(t, n)
                        }

                        function n() {
                            return o(t, arguments, (0, r.Z)(this).constructor)
                        }
                        return n.prototype = Object.create(t.prototype, {
                            constructor: {
                                value: n,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), (0, i.Z)(n, t)
                    })(t)
                }
            },
            6183: function(t, e, n) {
                "use strict";
                var r = n(2119),
                    i = n(6092),
                    s = (0, r.Z)(i.Z, "Map");
                e.Z = s
            },
            7685: function(t, e, n) {
                "use strict";
                var r = n(6092).Z.Symbol;
                e.Z = r
            },
            5510: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return h
                    }
                });
                var r = function(t, e) {
                        for (var n = -1, r = Array(t); ++n < t;) r[n] = e(n);
                        return r
                    },
                    i = n(4732),
                    s = n(7771),
                    o = n(6706),
                    a = /^(?:0|[1-9]\d*)$/;
                var c = function(t, e) {
                        var n = typeof t;
                        return !!(e = null == e ? 9007199254740991 : e) && ("number" == n || "symbol" != n && a.test(t)) && t > -1 && t % 1 == 0 && t < e
                    },
                    l = n(7212),
                    u = Object.prototype.hasOwnProperty;
                var h = function(t, e) {
                    var n = (0, s.Z)(t),
                        a = !n && (0, i.Z)(t),
                        h = !n && !a && (0, o.Z)(t),
                        d = !n && !a && !h && (0, l.Z)(t),
                        p = n || a || h || d,
                        f = p ? r(t.length, String) : [],
                        m = f.length;
                    for (var g in t) !e && !u.call(t, g) || p && ("length" == g || h && ("offset" == g || "parent" == g) || d && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || c(g, m)) || f.push(g);
                    return f
                }
            },
            3243: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return d
                    }
                });
                var r = n(7685),
                    i = Object.prototype,
                    s = i.hasOwnProperty,
                    o = i.toString,
                    a = r.Z ? r.Z.toStringTag : void 0;
                var c = function(t) {
                        var e = s.call(t, a),
                            n = t[a];
                        try {
                            t[a] = void 0;
                            var r = !0
                        } catch (t) {}
                        var i = o.call(t);
                        return r && (e ? t[a] = n : delete t[a]), i
                    },
                    l = Object.prototype.toString;
                var u = function(t) {
                        return l.call(t)
                    },
                    h = r.Z ? r.Z.toStringTag : void 0;
                var d = function(t) {
                    return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : h && h in Object(t) ? c(t) : u(t)
                }
            },
            8448: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return o
                    }
                });
                var r = n(2764),
                    i = (0, n(1851).Z)(Object.keys, Object),
                    s = Object.prototype.hasOwnProperty;
                var o = function(t) {
                    if (!(0, r.Z)(t)) return i(t);
                    var e = [];
                    for (var n in Object(t)) s.call(t, n) && "constructor" != n && e.push(n);
                    return e
                }
            },
            1162: function(t, e) {
                "use strict";
                e.Z = function(t) {
                    return function(e) {
                        return t(e)
                    }
                }
            },
            7215: function(t, e) {
                "use strict";
                e.Z = function(t, e) {
                    var n = -1,
                        r = t.length;
                    for (e || (e = Array(r)); ++n < r;) e[n] = t[n];
                    return e
                }
            },
            3413: function(t, e) {
                "use strict";
                var n = "object" == typeof global && global && global.Object === Object && global;
                e.Z = n
            },
            2119: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return v
                    }
                });
                var r = n(3234),
                    i = n(6092).Z["__core-js_shared__"],
                    s = function() {
                        var t = /[^.]+$/.exec(i && i.keys && i.keys.IE_PROTO || "");
                        return t ? "Symbol(src)_1." + t : ""
                    }();
                var o = function(t) {
                        return !!s && s in t
                    },
                    a = n(7226),
                    c = n(19),
                    l = /^\[object .+?Constructor\]$/,
                    u = Function.prototype,
                    h = Object.prototype,
                    d = u.toString,
                    p = h.hasOwnProperty,
                    f = RegExp("^" + d.call(p).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                var m = function(t) {
                    return !(!(0, a.Z)(t) || o(t)) && ((0, r.Z)(t) ? f : l).test((0, c.Z)(t))
                };
                var g = function(t, e) {
                    return null == t ? void 0 : t[e]
                };
                var v = function(t, e) {
                    var n = g(t, e);
                    return m(n) ? n : void 0
                }
            },
            4158: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return M
                    }
                });
                var r = n(2119),
                    i = n(6092),
                    s = (0, r.Z)(i.Z, "DataView"),
                    o = n(6183),
                    a = (0, r.Z)(i.Z, "Promise"),
                    c = (0, r.Z)(i.Z, "Set"),
                    l = (0, r.Z)(i.Z, "WeakMap"),
                    u = n(3243),
                    h = n(19),
                    d = "[object Map]",
                    p = "[object Promise]",
                    f = "[object Set]",
                    m = "[object WeakMap]",
                    g = "[object DataView]",
                    v = (0, h.Z)(s),
                    y = (0, h.Z)(o.Z),
                    x = (0, h.Z)(a),
                    _ = (0, h.Z)(c),
                    b = (0, h.Z)(l),
                    w = u.Z;
                (s && w(new s(new ArrayBuffer(1))) != g || o.Z && w(new o.Z) != d || a && w(a.resolve()) != p || c && w(new c) != f || l && w(new l) != m) && (w = function(t) {
                    var e = (0, u.Z)(t),
                        n = "[object Object]" == e ? t.constructor : void 0,
                        r = n ? (0, h.Z)(n) : "";
                    if (r) switch (r) {
                        case v:
                            return g;
                        case y:
                            return d;
                        case x:
                            return p;
                        case _:
                            return f;
                        case b:
                            return m
                    }
                    return e
                });
                var M = w
            },
            2764: function(t, e) {
                "use strict";
                var n = Object.prototype;
                e.Z = function(t) {
                    var e = t && t.constructor;
                    return t === ("function" == typeof e && e.prototype || n)
                }
            },
            8351: function(t, e, n) {
                "use strict";
                var r = n(3413),
                    i = "object" == typeof exports && exports && !exports.nodeType && exports,
                    s = i && "object" == typeof module && module && !module.nodeType && module,
                    o = s && s.exports === i && r.Z.process,
                    a = function() {
                        try {
                            return s && s.require && s.require("util").types || o && o.binding && o.binding("util")
                        } catch (t) {}
                    }();
                e.Z = a
            },
            1851: function(t, e) {
                "use strict";
                e.Z = function(t, e) {
                    return function(n) {
                        return t(e(n))
                    }
                }
            },
            6092: function(t, e, n) {
                "use strict";
                var r = n(3413),
                    i = "object" == typeof self && self && self.Object === Object && self,
                    s = r.Z || i || Function("return this")();
                e.Z = s
            },
            19: function(t, e) {
                "use strict";
                var n = Function.prototype.toString;
                e.Z = function(t) {
                    if (null != t) {
                        try {
                            return n.call(t)
                        } catch (t) {}
                        try {
                            return t + ""
                        } catch (t) {}
                    }
                    return ""
                }
            },
            2882: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return re
                    }
                });
                var r = function() {
                    this.__data__ = [], this.size = 0
                };
                var i = function(t, e) {
                    return t === e || t != t && e != e
                };
                var s = function(t, e) {
                        for (var n = t.length; n--;)
                            if (i(t[n][0], e)) return n;
                        return -1
                    },
                    o = Array.prototype.splice;
                var a = function(t) {
                    var e = this.__data__,
                        n = s(e, t);
                    return !(n < 0) && (n == e.length - 1 ? e.pop() : o.call(e, n, 1), --this.size, !0)
                };
                var c = function(t) {
                    var e = this.__data__,
                        n = s(e, t);
                    return n < 0 ? void 0 : e[n][1]
                };
                var l = function(t) {
                    return s(this.__data__, t) > -1
                };
                var u = function(t, e) {
                    var n = this.__data__,
                        r = s(n, t);
                    return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
                };

                function h(t) {
                    var e = -1,
                        n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n;) {
                        var r = t[e];
                        this.set(r[0], r[1])
                    }
                }
                h.prototype.clear = r, h.prototype.delete = a, h.prototype.get = c, h.prototype.has = l, h.prototype.set = u;
                var d = h;
                var p = function() {
                    this.__data__ = new d, this.size = 0
                };
                var f = function(t) {
                    var e = this.__data__,
                        n = e.delete(t);
                    return this.size = e.size, n
                };
                var m = function(t) {
                    return this.__data__.get(t)
                };
                var g = function(t) {
                        return this.__data__.has(t)
                    },
                    v = n(6183),
                    y = n(2119),
                    x = (0, y.Z)(Object, "create");
                var _ = function() {
                    this.__data__ = x ? x(null) : {}, this.size = 0
                };
                var b = function(t) {
                        var e = this.has(t) && delete this.__data__[t];
                        return this.size -= e ? 1 : 0, e
                    },
                    w = Object.prototype.hasOwnProperty;
                var M = function(t) {
                        var e = this.__data__;
                        if (x) {
                            var n = e[t];
                            return "__lodash_hash_undefined__" === n ? void 0 : n
                        }
                        return w.call(e, t) ? e[t] : void 0
                    },
                    S = Object.prototype.hasOwnProperty;
                var T = function(t) {
                    var e = this.__data__;
                    return x ? void 0 !== e[t] : S.call(e, t)
                };
                var E = function(t, e) {
                    var n = this.__data__;
                    return this.size += this.has(t) ? 0 : 1, n[t] = x && void 0 === e ? "__lodash_hash_undefined__" : e, this
                };

                function A(t) {
                    var e = -1,
                        n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n;) {
                        var r = t[e];
                        this.set(r[0], r[1])
                    }
                }
                A.prototype.clear = _, A.prototype.delete = b, A.prototype.get = M, A.prototype.has = T, A.prototype.set = E;
                var L = A;
                var R = function() {
                    this.size = 0, this.__data__ = {
                        hash: new L,
                        map: new(v.Z || d),
                        string: new L
                    }
                };
                var P = function(t) {
                    var e = typeof t;
                    return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
                };
                var C = function(t, e) {
                    var n = t.__data__;
                    return P(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
                };
                var I = function(t) {
                    var e = C(this, t).delete(t);
                    return this.size -= e ? 1 : 0, e
                };
                var D = function(t) {
                    return C(this, t).get(t)
                };
                var O = function(t) {
                    return C(this, t).has(t)
                };
                var N = function(t, e) {
                    var n = C(this, t),
                        r = n.size;
                    return n.set(t, e), this.size += n.size == r ? 0 : 1, this
                };

                function B(t) {
                    var e = -1,
                        n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n;) {
                        var r = t[e];
                        this.set(r[0], r[1])
                    }
                }
                B.prototype.clear = R, B.prototype.delete = I, B.prototype.get = D, B.prototype.has = O, B.prototype.set = N;
                var z = B;
                var F = function(t, e) {
                    var n = this.__data__;
                    if (n instanceof d) {
                        var r = n.__data__;
                        if (!v.Z || r.length < 199) return r.push([t, e]), this.size = ++n.size, this;
                        n = this.__data__ = new z(r)
                    }
                    return n.set(t, e), this.size = n.size, this
                };

                function k(t) {
                    var e = this.__data__ = new d(t);
                    this.size = e.size
                }
                k.prototype.clear = p, k.prototype.delete = f, k.prototype.get = m, k.prototype.has = g, k.prototype.set = F;
                var U = k;
                var H = function(t, e) {
                        for (var n = -1, r = null == t ? 0 : t.length; ++n < r && !1 !== e(t[n], n, t););
                        return t
                    },
                    G = function() {
                        try {
                            var t = (0, y.Z)(Object, "defineProperty");
                            return t({}, "", {}), t
                        } catch (t) {}
                    }();
                var V = function(t, e, n) {
                        "__proto__" == e && G ? G(t, e, {
                            configurable: !0,
                            enumerable: !0,
                            value: n,
                            writable: !0
                        }) : t[e] = n
                    },
                    W = Object.prototype.hasOwnProperty;
                var j = function(t, e, n) {
                    var r = t[e];
                    W.call(t, e) && i(r, n) && (void 0 !== n || e in t) || V(t, e, n)
                };
                var Z = function(t, e, n, r) {
                        var i = !n;
                        n || (n = {});
                        for (var s = -1, o = e.length; ++s < o;) {
                            var a = e[s],
                                c = r ? r(n[a], t[a], a, n, t) : void 0;
                            void 0 === c && (c = t[a]), i ? V(n, a, c) : j(n, a, c)
                        }
                        return n
                    },
                    q = n(7179);
                var X = function(t, e) {
                        return t && Z(e, (0, q.Z)(e), t)
                    },
                    Y = n(5510),
                    J = n(7226),
                    K = n(2764);
                var Q = function(t) {
                        var e = [];
                        if (null != t)
                            for (var n in Object(t)) e.push(n);
                        return e
                    },
                    $ = Object.prototype.hasOwnProperty;
                var tt = function(t) {
                        if (!(0, J.Z)(t)) return Q(t);
                        var e = (0, K.Z)(t),
                            n = [];
                        for (var r in t)("constructor" != r || !e && $.call(t, r)) && n.push(r);
                        return n
                    },
                    et = n(585);
                var nt = function(t) {
                    return (0, et.Z)(t) ? (0, Y.Z)(t, !0) : tt(t)
                };
                var rt = function(t, e) {
                        return t && Z(e, nt(e), t)
                    },
                    it = n(6092),
                    st = "object" == typeof exports && exports && !exports.nodeType && exports,
                    ot = st && "object" == typeof module && module && !module.nodeType && module,
                    at = ot && ot.exports === st ? it.Z.Buffer : void 0,
                    ct = at ? at.allocUnsafe : void 0;
                var lt = function(t, e) {
                        if (e) return t.slice();
                        var n = t.length,
                            r = ct ? ct(n) : new t.constructor(n);
                        return t.copy(r), r
                    },
                    ut = n(7215);
                var ht = function(t, e) {
                    for (var n = -1, r = null == t ? 0 : t.length, i = 0, s = []; ++n < r;) {
                        var o = t[n];
                        e(o, n, t) && (s[i++] = o)
                    }
                    return s
                };
                var dt = function() {
                        return []
                    },
                    pt = Object.prototype.propertyIsEnumerable,
                    ft = Object.getOwnPropertySymbols,
                    mt = ft ? function(t) {
                        return null == t ? [] : (t = Object(t), ht(ft(t), (function(e) {
                            return pt.call(t, e)
                        })))
                    } : dt;
                var gt = function(t, e) {
                    return Z(t, mt(t), e)
                };
                var vt = function(t, e) {
                        for (var n = -1, r = e.length, i = t.length; ++n < r;) t[i + n] = e[n];
                        return t
                    },
                    yt = (0, n(1851).Z)(Object.getPrototypeOf, Object),
                    xt = Object.getOwnPropertySymbols ? function(t) {
                        for (var e = []; t;) vt(e, mt(t)), t = yt(t);
                        return e
                    } : dt;
                var _t = function(t, e) {
                        return Z(t, xt(t), e)
                    },
                    bt = n(7771);
                var wt = function(t, e, n) {
                    var r = e(t);
                    return (0, bt.Z)(t) ? r : vt(r, n(t))
                };
                var Mt = function(t) {
                    return wt(t, q.Z, mt)
                };
                var St = function(t) {
                        return wt(t, nt, xt)
                    },
                    Tt = n(4158),
                    Et = Object.prototype.hasOwnProperty;
                var At = function(t) {
                        var e = t.length,
                            n = new t.constructor(e);
                        return e && "string" == typeof t[0] && Et.call(t, "index") && (n.index = t.index, n.input = t.input), n
                    },
                    Lt = it.Z.Uint8Array;
                var Rt = function(t) {
                    var e = new t.constructor(t.byteLength);
                    return new Lt(e).set(new Lt(t)), e
                };
                var Pt = function(t, e) {
                        var n = e ? Rt(t.buffer) : t.buffer;
                        return new t.constructor(n, t.byteOffset, t.byteLength)
                    },
                    Ct = /\w*$/;
                var It = function(t) {
                        var e = new t.constructor(t.source, Ct.exec(t));
                        return e.lastIndex = t.lastIndex, e
                    },
                    Dt = n(7685),
                    Ot = Dt.Z ? Dt.Z.prototype : void 0,
                    Nt = Ot ? Ot.valueOf : void 0;
                var Bt = function(t) {
                    return Nt ? Object(Nt.call(t)) : {}
                };
                var zt = function(t, e) {
                    var n = e ? Rt(t.buffer) : t.buffer;
                    return new t.constructor(n, t.byteOffset, t.length)
                };
                var Ft = function(t, e, n) {
                        var r = t.constructor;
                        switch (e) {
                            case "[object ArrayBuffer]":
                                return Rt(t);
                            case "[object Boolean]":
                            case "[object Date]":
                                return new r(+t);
                            case "[object DataView]":
                                return Pt(t, n);
                            case "[object Float32Array]":
                            case "[object Float64Array]":
                            case "[object Int8Array]":
                            case "[object Int16Array]":
                            case "[object Int32Array]":
                            case "[object Uint8Array]":
                            case "[object Uint8ClampedArray]":
                            case "[object Uint16Array]":
                            case "[object Uint32Array]":
                                return zt(t, n);
                            case "[object Map]":
                                return new r;
                            case "[object Number]":
                            case "[object String]":
                                return new r(t);
                            case "[object RegExp]":
                                return It(t);
                            case "[object Set]":
                                return new r;
                            case "[object Symbol]":
                                return Bt(t)
                        }
                    },
                    kt = Object.create,
                    Ut = function() {
                        function t() {}
                        return function(e) {
                            if (!(0, J.Z)(e)) return {};
                            if (kt) return kt(e);
                            t.prototype = e;
                            var n = new t;
                            return t.prototype = void 0, n
                        }
                    }();
                var Ht = function(t) {
                        return "function" != typeof t.constructor || (0, K.Z)(t) ? {} : Ut(yt(t))
                    },
                    Gt = n(6706),
                    Vt = n(8533);
                var Wt = function(t) {
                        return (0, Vt.Z)(t) && "[object Map]" == (0, Tt.Z)(t)
                    },
                    jt = n(1162),
                    Zt = n(8351),
                    qt = Zt.Z && Zt.Z.isMap,
                    Xt = qt ? (0, jt.Z)(qt) : Wt;
                var Yt = function(t) {
                        return (0, Vt.Z)(t) && "[object Set]" == (0, Tt.Z)(t)
                    },
                    Jt = Zt.Z && Zt.Z.isSet,
                    Kt = Jt ? (0, jt.Z)(Jt) : Yt,
                    Qt = "[object Arguments]",
                    $t = "[object Function]",
                    te = "[object Object]",
                    ee = {};
                ee[Qt] = ee["[object Array]"] = ee["[object ArrayBuffer]"] = ee["[object DataView]"] = ee["[object Boolean]"] = ee["[object Date]"] = ee["[object Float32Array]"] = ee["[object Float64Array]"] = ee["[object Int8Array]"] = ee["[object Int16Array]"] = ee["[object Int32Array]"] = ee["[object Map]"] = ee["[object Number]"] = ee[te] = ee["[object RegExp]"] = ee["[object Set]"] = ee["[object String]"] = ee["[object Symbol]"] = ee["[object Uint8Array]"] = ee["[object Uint8ClampedArray]"] = ee["[object Uint16Array]"] = ee["[object Uint32Array]"] = !0, ee["[object Error]"] = ee[$t] = ee["[object WeakMap]"] = !1;
                var ne = function t(e, n, r, i, s, o) {
                    var a, c = 1 & n,
                        l = 2 & n,
                        u = 4 & n;
                    if (r && (a = s ? r(e, i, s, o) : r(e)), void 0 !== a) return a;
                    if (!(0, J.Z)(e)) return e;
                    var h = (0, bt.Z)(e);
                    if (h) {
                        if (a = At(e), !c) return (0, ut.Z)(e, a)
                    } else {
                        var d = (0, Tt.Z)(e),
                            p = d == $t || "[object GeneratorFunction]" == d;
                        if ((0, Gt.Z)(e)) return lt(e, c);
                        if (d == te || d == Qt || p && !s) {
                            if (a = l || p ? {} : Ht(e), !c) return l ? _t(e, rt(a, e)) : gt(e, X(a, e))
                        } else {
                            if (!ee[d]) return s ? e : {};
                            a = Ft(e, d, c)
                        }
                    }
                    o || (o = new U);
                    var f = o.get(e);
                    if (f) return f;
                    o.set(e, a), Kt(e) ? e.forEach((function(i) {
                        a.add(t(i, n, r, i, e, o))
                    })) : Xt(e) && e.forEach((function(i, s) {
                        a.set(s, t(i, n, r, s, e, o))
                    }));
                    var m = u ? l ? St : Mt : l ? nt : q.Z,
                        g = h ? void 0 : m(e);
                    return H(g || e, (function(i, s) {
                        g && (i = e[s = i]), j(a, s, t(i, n, r, s, e, o))
                    })), a
                };
                var re = function(t) {
                    return ne(t, 4)
                }
            },
            4732: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return l
                    }
                });
                var r = n(3243),
                    i = n(8533);
                var s = function(t) {
                        return (0, i.Z)(t) && "[object Arguments]" == (0, r.Z)(t)
                    },
                    o = Object.prototype,
                    a = o.hasOwnProperty,
                    c = o.propertyIsEnumerable,
                    l = s(function() {
                        return arguments
                    }()) ? s : function(t) {
                        return (0, i.Z)(t) && a.call(t, "callee") && !c.call(t, "callee")
                    }
            },
            7771: function(t, e) {
                "use strict";
                var n = Array.isArray;
                e.Z = n
            },
            585: function(t, e, n) {
                "use strict";
                var r = n(3234),
                    i = n(1656);
                e.Z = function(t) {
                    return null != t && (0, i.Z)(t.length) && !(0, r.Z)(t)
                }
            },
            6706: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return c
                    }
                });
                var r = n(6092);
                var i = function() {
                        return !1
                    },
                    s = "object" == typeof exports && exports && !exports.nodeType && exports,
                    o = s && "object" == typeof module && module && !module.nodeType && module,
                    a = o && o.exports === s ? r.Z.Buffer : void 0,
                    c = (a ? a.isBuffer : void 0) || i
            },
            9697: function(t, e, n) {
                "use strict";
                var r = n(8448),
                    i = n(4158),
                    s = n(4732),
                    o = n(7771),
                    a = n(585),
                    c = n(6706),
                    l = n(2764),
                    u = n(7212),
                    h = Object.prototype.hasOwnProperty;
                e.Z = function(t) {
                    if (null == t) return !0;
                    if ((0, a.Z)(t) && ((0, o.Z)(t) || "string" == typeof t || "function" == typeof t.splice || (0, c.Z)(t) || (0, u.Z)(t) || (0, s.Z)(t))) return !t.length;
                    var e = (0, i.Z)(t);
                    if ("[object Map]" == e || "[object Set]" == e) return !t.size;
                    if ((0, l.Z)(t)) return !(0, r.Z)(t).length;
                    for (var n in t)
                        if (h.call(t, n)) return !1;
                    return !0
                }
            },
            3234: function(t, e, n) {
                "use strict";
                var r = n(3243),
                    i = n(7226);
                e.Z = function(t) {
                    if (!(0, i.Z)(t)) return !1;
                    var e = (0, r.Z)(t);
                    return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
                }
            },
            1656: function(t, e) {
                "use strict";
                e.Z = function(t) {
                    return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
                }
            },
            7226: function(t, e) {
                "use strict";
                e.Z = function(t) {
                    var e = typeof t;
                    return null != t && ("object" == e || "function" == e)
                }
            },
            8533: function(t, e) {
                "use strict";
                e.Z = function(t) {
                    return null != t && "object" == typeof t
                }
            },
            7212: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return h
                    }
                });
                var r = n(3243),
                    i = n(1656),
                    s = n(8533),
                    o = {};
                o["[object Float32Array]"] = o["[object Float64Array]"] = o["[object Int8Array]"] = o["[object Int16Array]"] = o["[object Int32Array]"] = o["[object Uint8Array]"] = o["[object Uint8ClampedArray]"] = o["[object Uint16Array]"] = o["[object Uint32Array]"] = !0, o["[object Arguments]"] = o["[object Array]"] = o["[object ArrayBuffer]"] = o["[object Boolean]"] = o["[object DataView]"] = o["[object Date]"] = o["[object Error]"] = o["[object Function]"] = o["[object Map]"] = o["[object Number]"] = o["[object Object]"] = o["[object RegExp]"] = o["[object Set]"] = o["[object String]"] = o["[object WeakMap]"] = !1;
                var a = function(t) {
                        return (0, s.Z)(t) && (0, i.Z)(t.length) && !!o[(0, r.Z)(t)]
                    },
                    c = n(1162),
                    l = n(8351),
                    u = l.Z && l.Z.isTypedArray,
                    h = u ? (0, c.Z)(u) : a
            },
            7179: function(t, e, n) {
                "use strict";
                var r = n(5510),
                    i = n(8448),
                    s = n(585);
                e.Z = function(t) {
                    return (0, s.Z)(t) ? (0, r.Z)(t) : (0, i.Z)(t)
                }
            },
            8395: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return m
                    }
                });
                var r = n(7215),
                    i = Math.floor,
                    s = Math.random;
                var o = function(t, e) {
                    return t + i(s() * (e - t + 1))
                };
                var a = function(t, e) {
                    var n = -1,
                        r = t.length,
                        i = r - 1;
                    for (e = void 0 === e ? r : e; ++n < e;) {
                        var s = o(n, i),
                            a = t[s];
                        t[s] = t[n], t[n] = a
                    }
                    return t.length = e, t
                };
                var c = function(t) {
                    return a((0, r.Z)(t))
                };
                var l = function(t, e) {
                    for (var n = -1, r = null == t ? 0 : t.length, i = Array(r); ++n < r;) i[n] = e(t[n], n, t);
                    return i
                };
                var u = function(t, e) {
                        return l(e, (function(e) {
                            return t[e]
                        }))
                    },
                    h = n(7179);
                var d = function(t) {
                    return null == t ? [] : u(t, (0, h.Z)(t))
                };
                var p = function(t) {
                        return a(d(t))
                    },
                    f = n(7771);
                var m = function(t) {
                    return ((0, f.Z)(t) ? c : p)(t)
                }
            },
            9606: function(t, e, n) {
                "use strict";
                n.d(e, {
                    Z: function() {
                        return b
                    }
                });
                var r = n(7226),
                    i = n(6092),
                    s = function() {
                        return i.Z.Date.now()
                    },
                    o = /\s/;
                var a = function(t) {
                        for (var e = t.length; e-- && o.test(t.charAt(e)););
                        return e
                    },
                    c = /^\s+/;
                var l = function(t) {
                        return t ? t.slice(0, a(t) + 1).replace(c, "") : t
                    },
                    u = n(3243),
                    h = n(8533);
                var d = function(t) {
                        return "symbol" == typeof t || (0, h.Z)(t) && "[object Symbol]" == (0, u.Z)(t)
                    },
                    p = /^[-+]0x[0-9a-f]+$/i,
                    f = /^0b[01]+$/i,
                    m = /^0o[0-7]+$/i,
                    g = parseInt;
                var v = function(t) {
                        if ("number" == typeof t) return t;
                        if (d(t)) return NaN;
                        if ((0, r.Z)(t)) {
                            var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                            t = (0, r.Z)(e) ? e + "" : e
                        }
                        if ("string" != typeof t) return 0 === t ? t : +t;
                        t = l(t);
                        var n = f.test(t);
                        return n || m.test(t) ? g(t.slice(2), n ? 2 : 8) : p.test(t) ? NaN : +t
                    },
                    y = Math.max,
                    x = Math.min;
                var _ = function(t, e, n) {
                    var i, o, a, c, l, u, h = 0,
                        d = !1,
                        p = !1,
                        f = !0;
                    if ("function" != typeof t) throw new TypeError("Expected a function");

                    function m(e) {
                        var n = i,
                            r = o;
                        return i = o = void 0, h = e, c = t.apply(r, n)
                    }

                    function g(t) {
                        return h = t, l = setTimeout(b, e), d ? m(t) : c
                    }

                    function _(t) {
                        var n = t - u;
                        return void 0 === u || n >= e || n < 0 || p && t - h >= a
                    }

                    function b() {
                        var t = s();
                        if (_(t)) return w(t);
                        l = setTimeout(b, function(t) {
                            var n = e - (t - u);
                            return p ? x(n, a - (t - h)) : n
                        }(t))
                    }

                    function w(t) {
                        return l = void 0, f && i ? m(t) : (i = o = void 0, c)
                    }

                    function M() {
                        var t = s(),
                            n = _(t);
                        if (i = arguments, o = this, u = t, n) {
                            if (void 0 === l) return g(u);
                            if (p) return clearTimeout(l), l = setTimeout(b, e), m(u)
                        }
                        return void 0 === l && (l = setTimeout(b, e)), c
                    }
                    return e = v(e) || 0, (0, r.Z)(n) && (d = !!n.leading, a = (p = "maxWait" in n) ? y(v(n.maxWait) || 0, e) : a, f = "trailing" in n ? !!n.trailing : f), M.cancel = function() {
                        void 0 !== l && clearTimeout(l), h = 0, i = u = o = l = void 0
                    }, M.flush = function() {
                        return void 0 === l ? c : w(s())
                    }, M
                };
                var b = function(t, e, n) {
                    var i = !0,
                        s = !0;
                    if ("function" != typeof t) throw new TypeError("Expected a function");
                    return (0, r.Z)(n) && (i = "leading" in n ? !!n.leading : i, s = "trailing" in n ? !!n.trailing : s), _(t, e, {
                        leading: i,
                        maxWait: e,
                        trailing: s
                    })
                }
            }
        }
    ]);